'use strict';

<<<<<<< HEAD
var $TypeError = require('es-errors/type');
// var $BigInt = GetIntrinsic('%BigInt%', true);
<<<<<<< HEAD
// var $pow = require('math-intrinsics/pow');
=======
var GetIntrinsic = require('get-intrinsic');

var $TypeError = GetIntrinsic('%TypeError%');
// var $BigInt = GetIntrinsic('%BigInt%', true);
// var $pow = GetIntrinsic('%Math.pow%');
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
// var $pow = GetIntrinsic('%Math.pow%');
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)

// var BinaryAnd = require('./BinaryAnd');
// var BinaryOr = require('./BinaryOr');
// var BinaryXor = require('./BinaryXor');
<<<<<<< HEAD
=======
var Type = require('./Type');
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
// var modulo = require('./modulo');

// var zero = $BigInt && $BigInt(0);
// var negOne = $BigInt && $BigInt(-1);
// var two = $BigInt && $BigInt(2);

// https://262.ecma-international.org/11.0/#sec-bigintbitwiseop

module.exports = function BigIntBitwiseOp(op, x, y) {
	if (op !== '&' && op !== '|' && op !== '^') {
		throw new $TypeError('Assertion failed: `op` must be `&`, `|`, or `^`');
	}
<<<<<<< HEAD
	if (typeof x !== 'bigint' || typeof y !== 'bigint') {
=======
	if (Type(x) !== 'BigInt' || Type(y) !== 'BigInt') {
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
		throw new $TypeError('`x` and `y` must be BigInts');
	}

	if (op === '&') {
		return x & y;
	}
	if (op === '|') {
		return x | y;
	}
	return x ^ y;
	/*
	var result = zero;
	var shift = 0;
	while (x !== zero && x !== negOne && y !== zero && y !== negOne) {
		var xDigit = modulo(x, two);
		var yDigit = modulo(y, two);
		if (op === '&') {
			result += $pow(2, shift) * BinaryAnd(xDigit, yDigit);
		} else if (op === '|') {
			result += $pow(2, shift) * BinaryOr(xDigit, yDigit);
		} else if (op === '^') {
			result += $pow(2, shift) * BinaryXor(xDigit, yDigit);
		}
		shift += 1;
		x = (x - xDigit) / two;
		y = (y - yDigit) / two;
	}
	var tmp;
	if (op === '&') {
		tmp = BinaryAnd(modulo(x, two), modulo(y, two));
	} else if (op === '|') {
		tmp = BinaryAnd(modulo(x, two), modulo(y, two));
	} else {
		tmp = BinaryXor(modulo(x, two), modulo(y, two));
	}
	if (tmp !== 0) {
		result -= $pow(2, shift);
	}
	return result;
	*/
};
