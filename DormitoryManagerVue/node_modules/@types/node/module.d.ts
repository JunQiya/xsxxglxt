/**
 * @since v0.3.7
 * @experimental
 */
<<<<<<< HEAD
declare module "module" {
    import { URL } from "node:url";
    import { MessagePort } from "node:worker_threads";
    namespace Module {
<<<<<<< HEAD
        export { Module };
    }
    namespace Module {
        /**
         * A list of the names of all modules provided by Node.js. Can be used to verify
         * if a module is maintained by a third party or not.
         *
         * Note: the list doesn't contain prefix-only modules like `node:test`.
         * @since v9.3.0, v8.10.0, v6.13.0
         */
        const builtinModules: readonly string[];
        /**
         * @since v12.2.0
         * @param path Filename to be used to construct the require
         * function. Must be a file URL object, file URL string, or absolute path
         * string.
         */
        function createRequire(path: string | URL): NodeJS.Require;
        namespace constants {
            /**
             * The following constants are returned as the `status` field in the object returned by
             * {@link enableCompileCache} to indicate the result of the attempt to enable the
             * [module compile cache](https://nodejs.org/docs/latest-v24.x/api/module.html#module-compile-cache).
             * @since v22.8.0
             */
            namespace compileCacheStatus {
                /**
                 * Node.js has enabled the compile cache successfully. The directory used to store the
                 * compile cache will be returned in the `directory` field in the
                 * returned object.
                 */
                const ENABLED: number;
                /**
                 * The compile cache has already been enabled before, either by a previous call to
                 * {@link enableCompileCache}, or by the `NODE_COMPILE_CACHE=dir`
                 * environment variable. The directory used to store the
                 * compile cache will be returned in the `directory` field in the
                 * returned object.
                 */
                const ALREADY_ENABLED: number;
                /**
                 * Node.js fails to enable the compile cache. This can be caused by the lack of
                 * permission to use the specified directory, or various kinds of file system errors.
                 * The detail of the failure will be returned in the `message` field in the
                 * returned object.
                 */
                const FAILED: number;
                /**
                 * Node.js cannot enable the compile cache because the environment variable
                 * `NODE_DISABLE_COMPILE_CACHE=1` has been set.
                 */
                const DISABLED: number;
            }
        }
        interface EnableCompileCacheResult {
            /**
             * One of the {@link constants.compileCacheStatus}
             */
            status: number;
            /**
             * If Node.js cannot enable the compile cache, this contains
             * the error message. Only set if `status` is `module.constants.compileCacheStatus.FAILED`.
             */
            message?: string;
            /**
             * If the compile cache is enabled, this contains the directory
             * where the compile cache is stored. Only set if  `status` is
             * `module.constants.compileCacheStatus.ENABLED` or
             * `module.constants.compileCacheStatus.ALREADY_ENABLED`.
             */
            directory?: string;
        }
        /**
         * Enable [module compile cache](https://nodejs.org/docs/latest-v24.x/api/module.html#module-compile-cache)
         * in the current Node.js instance.
         *
         * If `cacheDir` is not specified, Node.js will either use the directory specified by the
         * `NODE_COMPILE_CACHE=dir` environment variable if it's set, or use
         * `path.join(os.tmpdir(), 'node-compile-cache')` otherwise. For general use cases, it's
         * recommended to call `module.enableCompileCache()` without specifying the `cacheDir`,
         * so that the directory can be overridden by the `NODE_COMPILE_CACHE` environment
         * variable when necessary.
         *
         * Since compile cache is supposed to be a quiet optimization that is not required for the
         * application to be functional, this method is designed to not throw any exception when the
         * compile cache cannot be enabled. Instead, it will return an object containing an error
         * message in the `message` field to aid debugging.
         * If compile cache is enabled successfully, the `directory` field in the returned object
         * contains the path to the directory where the compile cache is stored. The `status`
         * field in the returned object would be one of the `module.constants.compileCacheStatus`
         * values to indicate the result of the attempt to enable the
         * [module compile cache](https://nodejs.org/docs/latest-v24.x/api/module.html#module-compile-cache).
         *
         * This method only affects the current Node.js instance. To enable it in child worker threads,
         * either call this method in child worker threads too, or set the
         * `process.env.NODE_COMPILE_CACHE` value to compile cache directory so the behavior can
         * be inherited into the child workers. The directory can be obtained either from the
         * `directory` field returned by this method, or with {@link getCompileCacheDir}.
         * @since v22.8.0
         * @param cacheDir Optional path to specify the directory where the compile cache
         * will be stored/retrieved.
         */
        function enableCompileCache(cacheDir?: string): EnableCompileCacheResult;
        /**
         * Flush the [module compile cache](https://nodejs.org/docs/latest-v24.x/api/module.html#module-compile-cache)
         * accumulated from modules already loaded
         * in the current Node.js instance to disk. This returns after all the flushing
         * file system operations come to an end, no matter they succeed or not. If there
         * are any errors, this will fail silently, since compile cache misses should not
         * interfere with the actual operation of the application.
         * @since v22.10.0
         */
        function flushCompileCache(): void;
        /**
         * @since v22.8.0
         * @return Path to the [module compile cache](https://nodejs.org/docs/latest-v24.x/api/module.html#module-compile-cache)
         * directory if it is enabled, or `undefined` otherwise.
         */
        function getCompileCacheDir(): string | undefined;
        /**
         * ```text
         * /path/to/project
         *   ├ packages/
         *     ├ bar/
         *       ├ bar.js
         *       └ package.json // name = '@foo/bar'
         *     └ qux/
         *       ├ node_modules/
         *         └ some-package/
         *           └ package.json // name = 'some-package'
         *       ├ qux.js
         *       └ package.json // name = '@foo/qux'
         *   ├ main.js
         *   └ package.json // name = '@foo'
         * ```
         * ```js
         * // /path/to/project/packages/bar/bar.js
         * import { findPackageJSON } from 'node:module';
         *
         * findPackageJSON('..', import.meta.url);
         * // '/path/to/project/package.json'
         * // Same result when passing an absolute specifier instead:
         * findPackageJSON(new URL('../', import.meta.url));
         * findPackageJSON(import.meta.resolve('../'));
         *
         * findPackageJSON('some-package', import.meta.url);
         * // '/path/to/project/packages/bar/node_modules/some-package/package.json'
         * // When passing an absolute specifier, you might get a different result if the
         * // resolved module is inside a subfolder that has nested `package.json`.
         * findPackageJSON(import.meta.resolve('some-package'));
         * // '/path/to/project/packages/bar/node_modules/some-package/some-subfolder/package.json'
         *
         * findPackageJSON('@foo/qux', import.meta.url);
         * // '/path/to/project/packages/qux/package.json'
         * ```
         * @since v22.14.0
         * @param specifier The specifier for the module whose `package.json` to
         * retrieve. When passing a _bare specifier_, the `package.json` at the root of
         * the package is returned. When passing a _relative specifier_ or an _absolute specifier_,
         * the closest parent `package.json` is returned.
         * @param base The absolute location (`file:` URL string or FS path) of the
         * containing  module. For CJS, use `__filename` (not `__dirname`!); for ESM, use
         * `import.meta.url`. You do not need to pass it if `specifier` is an _absolute specifier_.
         * @returns A path if the `package.json` is found. When `startLocation`
         * is a package, the package's root `package.json`; when a relative or unresolved, the closest
         * `package.json` to the `startLocation`.
         */
        function findPackageJSON(specifier: string | URL, base?: string | URL): string | undefined;
        /**
         * @since v18.6.0, v16.17.0
         */
        function isBuiltin(moduleName: string): boolean;
        interface RegisterOptions<Data> {
            /**
             * If you want to resolve `specifier` relative to a
             * base URL, such as `import.meta.url`, you can pass that URL here. This
             * property is ignored if the `parentURL` is supplied as the second argument.
             * @default 'data:'
             */
            parentURL?: string | URL | undefined;
            /**
             * Any arbitrary, cloneable JavaScript value to pass into the
             * {@link initialize} hook.
             */
            data?: Data | undefined;
            /**
             * [Transferable objects](https://nodejs.org/docs/latest-v24.x/api/worker_threads.html#portpostmessagevalue-transferlist)
             * to be passed into the `initialize` hook.
             */
            transferList?: any[] | undefined;
        }
        /* eslint-disable @definitelytyped/no-unnecessary-generics */
        /**
         * Register a module that exports hooks that customize Node.js module
         * resolution and loading behavior. See
         * [Customization hooks](https://nodejs.org/docs/latest-v24.x/api/module.html#customization-hooks).
         *
         * This feature requires `--allow-worker` if used with the
         * [Permission Model](https://nodejs.org/docs/latest-v24.x/api/permissions.html#permission-model).
         * @since v20.6.0, v18.19.0
         * @param specifier Customization hooks to be registered; this should be
         * the same string that would be passed to `import()`, except that if it is
         * relative, it is resolved relative to `parentURL`.
         * @param parentURL f you want to resolve `specifier` relative to a base
         * URL, such as `import.meta.url`, you can pass that URL here.
         */
        function register<Data = any>(
            specifier: string | URL,
            parentURL?: string | URL,
            options?: RegisterOptions<Data>,
        ): void;
        function register<Data = any>(specifier: string | URL, options?: RegisterOptions<Data>): void;
        interface RegisterHooksOptions {
            /**
             * See [load hook](https://nodejs.org/docs/latest-v24.x/api/module.html#loadurl-context-nextload).
             * @default undefined
             */
            load?: LoadHookSync | undefined;
            /**
             * See [resolve hook](https://nodejs.org/docs/latest-v24.x/api/module.html#resolvespecifier-context-nextresolve).
             * @default undefined
             */
            resolve?: ResolveHookSync | undefined;
        }
        interface ModuleHooks {
            /**
             * Deregister the hook instance.
             */
            deregister(): void;
        }
        /**
         * Register [hooks](https://nodejs.org/docs/latest-v24.x/api/module.html#customization-hooks)
         * that customize Node.js module resolution and loading behavior.
         * @since v22.15.0
         * @experimental
         */
        function registerHooks(options: RegisterHooksOptions): ModuleHooks;
        interface StripTypeScriptTypesOptions {
            /**
             * Possible values are:
             * * `'strip'` Only strip type annotations without performing the transformation of TypeScript features.
             * * `'transform'` Strip type annotations and transform TypeScript features to JavaScript.
             * @default 'strip'
             */
            mode?: "strip" | "transform" | undefined;
            /**
             * Only when `mode` is `'transform'`, if `true`, a source map
             * will be generated for the transformed code.
             * @default false
             */
            sourceMap?: boolean | undefined;
            /**
             * Specifies the source url used in the source map.
             */
            sourceUrl?: string | undefined;
        }
        /**
         * `module.stripTypeScriptTypes()` removes type annotations from TypeScript code. It
         * can be used to strip type annotations from TypeScript code before running it
         * with `vm.runInContext()` or `vm.compileFunction()`.
         * By default, it will throw an error if the code contains TypeScript features
         * that require transformation such as `Enums`,
         * see [type-stripping](https://nodejs.org/docs/latest-v24.x/api/typescript.md#type-stripping) for more information.
         * When mode is `'transform'`, it also transforms TypeScript features to JavaScript,
         * see [transform TypeScript features](https://nodejs.org/docs/latest-v24.x/api/typescript.md#typescript-features) for more information.
         * When mode is `'strip'`, source maps are not generated, because locations are preserved.
         * If `sourceMap` is provided, when mode is `'strip'`, an error will be thrown.
         *
         * _WARNING_: The output of this function should not be considered stable across Node.js versions,
         * due to changes in the TypeScript parser.
         *
         * ```js
         * import { stripTypeScriptTypes } from 'node:module';
         * const code = 'const a: number = 1;';
         * const strippedCode = stripTypeScriptTypes(code);
         * console.log(strippedCode);
         * // Prints: const a         = 1;
         * ```
         *
         * If `sourceUrl` is provided, it will be used appended as a comment at the end of the output:
         *
         * ```js
         * import { stripTypeScriptTypes } from 'node:module';
         * const code = 'const a: number = 1;';
         * const strippedCode = stripTypeScriptTypes(code, { mode: 'strip', sourceUrl: 'source.ts' });
         * console.log(strippedCode);
         * // Prints: const a         = 1\n\n//# sourceURL=source.ts;
         * ```
         *
         * When `mode` is `'transform'`, the code is transformed to JavaScript:
         *
         * ```js
         * import { stripTypeScriptTypes } from 'node:module';
         * const code = `
         *   namespace MathUtil {
         *     export const add = (a: number, b: number) => a + b;
         *   }`;
         * const strippedCode = stripTypeScriptTypes(code, { mode: 'transform', sourceMap: true });
         * console.log(strippedCode);
         * // Prints:
         * // var MathUtil;
         * // (function(MathUtil) {
         * //     MathUtil.add = (a, b)=>a + b;
         * // })(MathUtil || (MathUtil = {}));
         * // # sourceMappingURL=data:application/json;base64, ...
         * ```
         * @since v22.13.0
         * @param code The code to strip type annotations from.
         * @returns The code with type annotations stripped.
         */
        function stripTypeScriptTypes(code: string, options?: StripTypeScriptTypesOptions): string;
        /* eslint-enable @definitelytyped/no-unnecessary-generics */
=======
declare module 'module' {
    import { URL } from 'node:url';
    namespace Module {
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)
        /**
         * The `module.syncBuiltinESMExports()` method updates all the live bindings for
         * builtin `ES Modules` to match the properties of the `CommonJS` exports. It
         * does not add or remove exported names from the `ES Modules`.
         *
         * ```js
<<<<<<< HEAD
<<<<<<< HEAD
         * import fs from 'node:fs';
         * import assert from 'node:assert';
         * import { syncBuiltinESMExports } from 'node:module';
=======
         * const fs = require('fs');
         * const assert = require('assert');
         * const { syncBuiltinESMExports } = require('module');
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
         * const fs = require('node:fs');
         * const assert = require('node:assert');
         * const { syncBuiltinESMExports } = require('node:module');
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)
         *
         * fs.readFile = newAPI;
         *
         * delete fs.readFileSync;
         *
         * function newAPI() {
         *   // ...
         * }
         *
         * fs.newAPI = newAPI;
         *
         * syncBuiltinESMExports();
         *
<<<<<<< HEAD
         * import('node:fs').then((esmFS) => {
=======
         * import('fs').then((esmFS) => {
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
         *   // It syncs the existing readFile property with the new value
         *   assert.strictEqual(esmFS.readFile, newAPI);
         *   // readFileSync has been deleted from the required fs
         *   assert.strictEqual('readFileSync' in fs, false);
         *   // syncBuiltinESMExports() does not remove readFileSync from esmFS
         *   assert.strictEqual('readFileSync' in esmFS, true);
         *   // syncBuiltinESMExports() does not add names
         *   assert.strictEqual(esmFS.newAPI, undefined);
         * });
         * ```
         * @since v12.12.0
         */
        function syncBuiltinESMExports(): void;
<<<<<<< HEAD
<<<<<<< HEAD
        interface ImportAttributes extends NodeJS.Dict<string> {
            type?: string | undefined;
        }
        type ImportPhase = "source" | "evaluation";
        type ModuleFormat =
            | "addon"
            | "builtin"
            | "commonjs"
            | "commonjs-typescript"
            | "json"
            | "module"
            | "module-typescript"
            | "wasm";
        type ModuleSource = string | ArrayBuffer | NodeJS.TypedArray;
        /**
         * The `initialize` hook provides a way to define a custom function that runs in
         * the hooks thread when the hooks module is initialized. Initialization happens
         * when the hooks module is registered via {@link register}.
         *
         * This hook can receive data from a {@link register} invocation, including
         * ports and other transferable objects. The return value of `initialize` can be a
         * `Promise`, in which case it will be awaited before the main application thread
         * execution resumes.
         */
        type InitializeHook<Data = any> = (data: Data) => void | Promise<void>;
        interface ResolveHookContext {
            /**
             * Export conditions of the relevant `package.json`
             */
            conditions: string[];
            /**
             *  An object whose key-value pairs represent the assertions for the module to import
             */
            importAttributes: ImportAttributes;
            /**
             * The module importing this one, or undefined if this is the Node.js entry point
             */
            parentURL: string | undefined;
        }
        interface ResolveFnOutput {
            /**
             * A hint to the load hook (it might be ignored); can be an intermediary value.
             */
            format?: string | null | undefined;
            /**
             * The import attributes to use when caching the module (optional; if excluded the input will be used)
             */
            importAttributes?: ImportAttributes | undefined;
            /**
             * A signal that this hook intends to terminate the chain of `resolve` hooks.
             * @default false
             */
            shortCircuit?: boolean | undefined;
            /**
             * The absolute URL to which this input resolves
             */
            url: string;
        }
        /**
         * The `resolve` hook chain is responsible for telling Node.js where to find and
         * how to cache a given `import` statement or expression, or `require` call. It can
         * optionally return a format (such as `'module'`) as a hint to the `load` hook. If
         * a format is specified, the `load` hook is ultimately responsible for providing
         * the final `format` value (and it is free to ignore the hint provided by
         * `resolve`); if `resolve` provides a `format`, a custom `load` hook is required
         * even if only to pass the value to the Node.js default `load` hook.
         */
        type ResolveHook = (
            specifier: string,
            context: ResolveHookContext,
            nextResolve: (
                specifier: string,
                context?: Partial<ResolveHookContext>,
            ) => ResolveFnOutput | Promise<ResolveFnOutput>,
        ) => ResolveFnOutput | Promise<ResolveFnOutput>;
        type ResolveHookSync = (
            specifier: string,
            context: ResolveHookContext,
            nextResolve: (
                specifier: string,
                context?: Partial<ResolveHookContext>,
            ) => ResolveFnOutput,
        ) => ResolveFnOutput;
        interface LoadHookContext {
            /**
             * Export conditions of the relevant `package.json`
             */
            conditions: string[];
            /**
             * The format optionally supplied by the `resolve` hook chain (can be an intermediary value).
             */
            format: string | null | undefined;
            /**
             *  An object whose key-value pairs represent the assertions for the module to import
             */
            importAttributes: ImportAttributes;
        }
        interface LoadFnOutput {
            format: string | null | undefined;
            /**
             * A signal that this hook intends to terminate the chain of `resolve` hooks.
             * @default false
             */
            shortCircuit?: boolean | undefined;
            /**
             * The source for Node.js to evaluate
             */
            source?: ModuleSource | undefined;
        }
        /**
         * The `load` hook provides a way to define a custom method of determining how a
         * URL should be interpreted, retrieved, and parsed. It is also in charge of
         * validating the import attributes.
         */
        type LoadHook = (
            url: string,
            context: LoadHookContext,
            nextLoad: (
                url: string,
                context?: Partial<LoadHookContext>,
            ) => LoadFnOutput | Promise<LoadFnOutput>,
        ) => LoadFnOutput | Promise<LoadFnOutput>;
        type LoadHookSync = (
            url: string,
            context: LoadHookContext,
            nextLoad: (
                url: string,
                context?: Partial<LoadHookContext>,
            ) => LoadFnOutput,
        ) => LoadFnOutput;
        interface SourceMapsSupport {
            /**
             * If the source maps support is enabled
             */
            enabled: boolean;
            /**
             * If the support is enabled for files in `node_modules`.
             */
            nodeModules: boolean;
            /**
             * If the support is enabled for generated code from `eval` or `new Function`.
             */
            generatedCode: boolean;
        }
        /**
         * This method returns whether the [Source Map v3](https://tc39.es/ecma426/) support for stack
         * traces is enabled.
         * @since v23.7.0, v22.14.0
         */
        function getSourceMapsSupport(): SourceMapsSupport;
=======
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)
        /**
         * `path` is the resolved path for the file for which a corresponding source map
         * should be fetched.
         * @since v13.7.0, v12.17.0
<<<<<<< HEAD
         * @return Returns `module.SourceMap` if a source map is found, `undefined` otherwise.
         */
<<<<<<< HEAD
        function findSourceMap(path: string): SourceMap | undefined;
        interface SetSourceMapsSupportOptions {
            /**
             * If enabling the support for files in `node_modules`.
             * @default false
             */
            nodeModules?: boolean | undefined;
            /**
             * If enabling the support for generated code from `eval` or `new Function`.
             * @default false
             */
            generatedCode?: boolean | undefined;
        }
        /**
         * This function enables or disables the [Source Map v3](https://tc39.es/ecma426/) support for
         * stack traces.
         *
         * It provides same features as launching Node.js process with commandline options
         * `--enable-source-maps`, with additional options to alter the support for files
         * in `node_modules` or generated codes.
         *
         * Only source maps in JavaScript files that are loaded after source maps has been
         * enabled will be parsed and loaded. Preferably, use the commandline options
         * `--enable-source-maps` to avoid losing track of source maps of modules loaded
         * before this API call.
         * @since v23.7.0, v22.14.0
         */
        function setSourceMapsSupport(enabled: boolean, options?: SetSourceMapsSupportOptions): void;
        interface SourceMapConstructorOptions {
            /**
             * @since v21.0.0, v20.5.0
             */
            lineLengths?: readonly number[] | undefined;
        }
=======
         */
        function findSourceMap(path: string, error?: Error): SourceMap;
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
        function findSourceMap(path: string, error?: Error): SourceMap;
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)
        interface SourceMapPayload {
            file: string;
            version: number;
            sources: string[];
            sourcesContent: string[];
            names: string[];
            mappings: string;
            sourceRoot: string;
        }
        interface SourceMapping {
            generatedLine: number;
            generatedColumn: number;
            originalSource: string;
            originalLine: number;
            originalColumn: number;
        }
<<<<<<< HEAD
        interface SourceOrigin {
            /**
             * The name of the range in the source map, if one was provided
             */
            name?: string;
            /**
             * The file name of the original source, as reported in the SourceMap
             */
            fileName: string;
            /**
             * The 1-indexed lineNumber of the corresponding call site in the original source
             */
            lineNumber: number;
            /**
             * The 1-indexed columnNumber of the corresponding call site in the original source
             */
            columnNumber: number;
        }
=======
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
        /**
         * @since v13.7.0, v12.17.0
         */
        class SourceMap {
<<<<<<< HEAD
<<<<<<< HEAD
            constructor(payload: SourceMapPayload, options?: SourceMapConstructorOptions);
=======
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)
            /**
             * Getter for the payload used to construct the `SourceMap` instance.
             */
            readonly payload: SourceMapPayload;
<<<<<<< HEAD
<<<<<<< HEAD
=======
            constructor(payload: SourceMapPayload);
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)
            /**
             * Given a line offset and column offset in the generated source
             * file, returns an object representing the SourceMap range in the
             * original file if found, or an empty object if not.
             *
             * The object returned contains the following keys:
             *
             * The returned value represents the raw range as it appears in the
             * SourceMap, based on zero-indexed offsets, _not_ 1-indexed line and
             * column numbers as they appear in Error messages and CallSite
             * objects.
             *
             * To get the corresponding 1-indexed line and column numbers from a
             * lineNumber and columnNumber as they are reported by Error stacks
             * and CallSite objects, use `sourceMap.findOrigin(lineNumber, columnNumber)`
             * @param lineOffset The zero-indexed line number offset in the generated source
             * @param columnOffset The zero-indexed column number offset in the generated source
             */
            findEntry(lineOffset: number, columnOffset: number): SourceMapping;
            /**
             * Given a 1-indexed `lineNumber` and `columnNumber` from a call site in the generated source,
             * find the corresponding call site location in the original source.
             *
             * If the `lineNumber` and `columnNumber` provided are not found in any source map,
             * then an empty object is returned.
             * @param lineNumber The 1-indexed line number of the call site in the generated source
             * @param columnNumber The 1-indexed column number of the call site in the generated source
             */
            findOrigin(lineNumber: number, columnNumber: number): SourceOrigin | {};
        }
        /** @deprecated Use `ImportAttributes` instead */
        interface ImportAssertions extends ImportAttributes {}
        interface ImportAttributes extends NodeJS.Dict<string> {
            type?: string | undefined;
        }
        type ModuleFormat = "builtin" | "commonjs" | "json" | "module" | "wasm";
        type ModuleSource = string | ArrayBuffer | NodeJS.TypedArray;
        interface GlobalPreloadContext {
            port: MessagePort;
        }
        /**
         * @deprecated This hook will be removed in a future version.
         * Use `initialize` instead. When a loader has an `initialize` export, `globalPreload` will be ignored.
         *
         * Sometimes it might be necessary to run some code inside of the same global scope that the application runs in.
         * This hook allows the return of a string that is run as a sloppy-mode script on startup.
         *
         * @param context Information to assist the preload code
         * @return Code to run before application startup
         */
        type GlobalPreloadHook = (context: GlobalPreloadContext) => string;
        /**
         * The `initialize` hook provides a way to define a custom function that runs in the hooks thread
         * when the hooks module is initialized. Initialization happens when the hooks module is registered via `register`.
         *
         * This hook can receive data from a `register` invocation, including ports and other transferrable objects.
         * The return value of `initialize` can be a `Promise`, in which case it will be awaited before the main application thread execution resumes.
         */
        type InitializeHook<Data = any> = (data: Data) => void | Promise<void>;
        interface ResolveHookContext {
            /**
             * Export conditions of the relevant `package.json`
             */
            conditions: string[];
            /**
             * @deprecated Use `importAttributes` instead
             */
            importAssertions: ImportAttributes;
            /**
             *  An object whose key-value pairs represent the assertions for the module to import
             */
            importAttributes: ImportAttributes;
            /**
             * The module importing this one, or undefined if this is the Node.js entry point
             */
            parentURL: string | undefined;
        }
        interface ResolveFnOutput {
            /**
             * A hint to the load hook (it might be ignored)
             */
            format?: ModuleFormat | null | undefined;
            /**
             * @deprecated Use `importAttributes` instead
             */
            importAssertions?: ImportAttributes | undefined;
            /**
             * The import attributes to use when caching the module (optional; if excluded the input will be used)
             */
            importAttributes?: ImportAttributes | undefined;
            /**
             * A signal that this hook intends to terminate the chain of `resolve` hooks.
             * @default false
             */
            shortCircuit?: boolean | undefined;
            /**
             * The absolute URL to which this input resolves
             */
            url: string;
        }
        /**
         * The `resolve` hook chain is responsible for resolving file URL for a given module specifier and parent URL, and optionally its format (such as `'module'`) as a hint to the `load` hook.
         * If a format is specified, the load hook is ultimately responsible for providing the final `format` value (and it is free to ignore the hint provided by `resolve`);
         * if `resolve` provides a format, a custom `load` hook is required even if only to pass the value to the Node.js default `load` hook.
         *
         * @param specifier The specified URL path of the module to be resolved
         * @param context
         * @param nextResolve The subsequent `resolve` hook in the chain, or the Node.js default `resolve` hook after the last user-supplied resolve hook
         */
        type ResolveHook = (
            specifier: string,
            context: ResolveHookContext,
            nextResolve: (
                specifier: string,
                context?: ResolveHookContext,
            ) => ResolveFnOutput | Promise<ResolveFnOutput>,
        ) => ResolveFnOutput | Promise<ResolveFnOutput>;
        interface LoadHookContext {
            /**
             * Export conditions of the relevant `package.json`
             */
            conditions: string[];
            /**
             * The format optionally supplied by the `resolve` hook chain
             */
            format: ModuleFormat;
            /**
             * @deprecated Use `importAttributes` instead
             */
            importAssertions: ImportAttributes;
            /**
             *  An object whose key-value pairs represent the assertions for the module to import
             */
            importAttributes: ImportAttributes;
        }
        interface LoadFnOutput {
            format: ModuleFormat;
            /**
             * A signal that this hook intends to terminate the chain of `resolve` hooks.
             * @default false
             */
            shortCircuit?: boolean | undefined;
            /**
             * The source for Node.js to evaluate
             */
            source?: ModuleSource;
        }
        /**
         * The `load` hook provides a way to define a custom method of determining how a URL should be interpreted, retrieved, and parsed.
         * It is also in charge of validating the import assertion.
         *
         * @param url The URL/path of the module to be loaded
         * @param context Metadata about the module
         * @param nextLoad The subsequent `load` hook in the chain, or the Node.js default `load` hook after the last user-supplied `load` hook
         */
        type LoadHook = (
            url: string,
            context: LoadHookContext,
            nextLoad: (url: string, context?: LoadHookContext) => LoadFnOutput | Promise<LoadFnOutput>,
        ) => LoadFnOutput | Promise<LoadFnOutput>;
    }
    interface RegisterOptions<Data> {
        parentURL: string | URL;
        data?: Data | undefined;
        transferList?: any[] | undefined;
    }
    interface Module extends NodeModule {}
    class Module {
        static runMain(): void;
        static wrap(code: string): string;
        static createRequire(path: string | URL): NodeRequire;
        static builtinModules: string[];
        static isBuiltin(moduleName: string): boolean;
        static Module: typeof Module;
        static register<Data = any>(
            specifier: string | URL,
            parentURL?: string | URL,
            options?: RegisterOptions<Data>,
        ): void;
        static register<Data = any>(specifier: string | URL, options?: RegisterOptions<Data>): void;
        constructor(id: string, parent?: Module);
    }
    global {
        interface ImportMeta {
            /**
             * The directory name of the current module. This is the same as the `path.dirname()` of the `import.meta.filename`.
             * **Caveat:** only present on `file:` modules.
             */
            dirname: string;
            /**
             * The full absolute path and filename of the current module, with symlinks resolved.
             * This is the same as the `url.fileURLToPath()` of the `import.meta.url`.
             * **Caveat:** only local modules support this property. Modules not using the `file:` protocol will not provide it.
             */
            filename: string;
            /**
             * The absolute `file:` URL of the module.
             */
            url: string;
            /**
             * Provides a module-relative resolution function scoped to each module, returning
             * the URL string.
             *
             * Second `parent` parameter is only used when the `--experimental-import-meta-resolve`
             * command flag enabled.
             *
             * @since v20.6.0
             *
             * @param specifier The module specifier to resolve relative to `parent`.
             * @param parent The absolute parent module URL to resolve from.
             * @returns The absolute (`file:`) URL string for the resolved module.
             */
            resolve(specifier: string, parent?: string | URL | undefined): string;
        }
    }
    export = Module;
}
declare module "node:module" {
    import module = require("module");
=======
            constructor(payload: SourceMapPayload);
            /**
             * Given a line number and column number in the generated source file, returns
             * an object representing the position in the original file. The object returned
             * consists of the following keys:
             */
            findEntry(line: number, column: number): SourceMapping;
        }
    }
    interface Module extends NodeModule {}
    class Module {
        static runMain(): void;
        static wrap(code: string): string;
        static createRequire(path: string | URL): NodeRequire;
        static builtinModules: string[];
        static isBuiltin(moduleName: string): boolean;
        static Module: typeof Module;
        constructor(id: string, parent?: Module);
    }
    global {
        interface ImportMeta {
            url: string;
            /**
             * @experimental
             * This feature is only available with the `--experimental-import-meta-resolve`
             * command flag enabled.
             *
             * Provides a module-relative resolution function scoped to each module, returning
             * the URL string.
             *
             * @param specified The module specifier to resolve relative to `parent`.
             * @param parent The absolute parent module URL to resolve from. If none
             * is specified, the value of `import.meta.url` is used as the default.
             */
            resolve?(specified: string, parent?: string | URL): Promise<string>;
        }
    }
    export = Module;
}
declare module 'node:module' {
    import module = require('module');
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
    export = module;
}
