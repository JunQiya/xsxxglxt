'use strict';

<<<<<<< HEAD
// / <reference types="node" />

var callBind = require('call-bind');
var forEach = require('for-each');
var gOPD = require('gopd');
var isTypedArray = require('is-typed-array');
var typedArrays = require('possible-typed-array-names');
var gPO = require('reflect.getprototypeof/polyfill')();

/** @typedef {(value: import('.').TypedArray) => number} TypedArrayLengthGetter */
/** @typedef {{ [k in `$${import('.').TypedArrayName}` | '__proto__']: k extends '__proto__' ? null : TypedArrayLengthGetter }} Cache */

/** @type {Cache} */
// @ts-expect-error TS doesn't seem to have a "will eventually satisfy" type
var getters = { __proto__: null };
var oDP = Object.defineProperty;
if (gOPD) {
	var getLength = /** @type {TypedArrayLengthGetter} */ function (x) {
		return x.length;
	};
	forEach(typedArrays, /** @type {(typedArray: import('.').TypedArrayName) => void} */ function (typedArray) {
		var TA = global[typedArray];
		// In Safari 7, Typed Array constructors are typeof object
		if (typeof TA === 'function' || typeof TA === 'object') {
			var Proto = TA.prototype;
			// @ts-expect-error TS doesn't narrow types inside callbacks, which is weird
			var descriptor = gOPD(Proto, 'length');
			if (!descriptor) {
				var superProto = gPO(Proto);
				// @ts-expect-error TS doesn't narrow types inside callbacks, which is weird
=======
var forEach = require('for-each');
var callBind = require('call-bind');

var typedArrays = [
	'Float32Array',
	'Float64Array',
	'Int8Array',
	'Int16Array',
	'Int32Array',
	'Uint8Array',
	'Uint8ClampedArray',
	'Uint16Array',
	'Uint32Array',
	'BigInt64Array',
	'BigUint64Array'
];

var getters = {};
var hasProto = [].__proto__ === Array.prototype; // eslint-disable-line no-proto
var gOPD = Object.getOwnPropertyDescriptor;
var oDP = Object.defineProperty;
if (gOPD) {
	var getLength = function (x) {
		return x.length;
	};
	forEach(typedArrays, function (typedArray) {
		// In Safari 7, Typed Array constructors are typeof object
		if (typeof global[typedArray] === 'function' || typeof global[typedArray] === 'object') {
			var Proto = global[typedArray].prototype;
			var descriptor = gOPD(Proto, 'length');
			if (!descriptor && hasProto) {
				var superProto = Proto.__proto__; // eslint-disable-line no-proto
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
				descriptor = gOPD(superProto, 'length');
			}
			// Opera 12.16 has a magic length data property on instances AND on Proto
			if (descriptor && descriptor.get) {
<<<<<<< HEAD
				// eslint-disable-next-line no-extra-parens
				getters[/** @type {`$${import('.').TypedArrayName}`} */ ('$' + typedArray)] = callBind(descriptor.get);
			} else if (oDP) {
				// this is likely an engine where instances have a magic length data property
				var arr = new global[typedArray](2);
				// @ts-expect-error TS doesn't narrow types inside callbacks, which is weird
=======
				getters[typedArray] = callBind(descriptor.get);
			} else if (oDP) {
				// this is likely an engine where instances have a magic length data property
				var arr = new global[typedArray](2);
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
				descriptor = gOPD(arr, 'length');
				if (descriptor && descriptor.configurable) {
					oDP(arr, 'length', { value: 3 });
				}
				if (arr.length === 2) {
<<<<<<< HEAD
				// eslint-disable-next-line no-extra-parens
					getters[/** @type {`$${import('.').TypedArrayName}`} */ ('$' + typedArray)] = getLength;
=======
					getters[typedArray] = getLength;
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
				}
			}
		}
	});
}

<<<<<<< HEAD
/** @type {TypedArrayLengthGetter} */
var tryTypedArrays = function tryAllTypedArrays(value) {
	/** @type {number} */ var foundLength;
	// @ts-expect-error not sure why this won't work
	forEach(getters, /** @type {(getter: TypedArrayLengthGetter) => void} */ function (getter) {
=======
var tryTypedArrays = function tryAllTypedArrays(value) {
	var foundLength;
	forEach(getters, function (getter) {
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
		if (typeof foundLength !== 'number') {
			try {
				var length = getter(value);
				if (typeof length === 'number') {
					foundLength = length;
				}
			} catch (e) {}
		}
	});
<<<<<<< HEAD
	// @ts-expect-error TS can't guarantee the above callback is invoked sync
	return foundLength;
};

/** @type {import('.')} */
=======
	return foundLength;
};

var isTypedArray = require('is-typed-array');

>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
module.exports = function typedArrayLength(value) {
	if (!isTypedArray(value)) {
		return false;
	}
	return tryTypedArrays(value);
};
