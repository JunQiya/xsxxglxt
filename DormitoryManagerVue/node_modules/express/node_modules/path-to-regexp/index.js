/**
<<<<<<< HEAD
<<<<<<< HEAD
 * Expose `pathToRegexp`.
 */

module.exports = pathToRegexp;
=======
 * Expose `pathtoRegexp`.
 */

module.exports = pathtoRegexp;
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
 * Expose `pathtoRegexp`.
 */

module.exports = pathtoRegexp;
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)

/**
 * Match matching groups in a regular expression.
 */
<<<<<<< HEAD
<<<<<<< HEAD
var MATCHING_GROUP_REGEXP = /\\.|\((?:\?<(.*?)>)?(?!\?)/g;
=======
var MATCHING_GROUP_REGEXP = /\((?!\?)/g;
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
var MATCHING_GROUP_REGEXP = /\((?!\?)/g;
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)

/**
 * Normalize the given path string,
 * returning a regular expression.
 *
 * An empty array should be passed,
 * which will contain the placeholder
 * key names. For example "/user/:id" will
 * then contain ["id"].
 *
 * @param  {String|RegExp|Array} path
 * @param  {Array} keys
 * @param  {Object} options
 * @return {RegExp}
 * @api private
 */

<<<<<<< HEAD
<<<<<<< HEAD
function pathToRegexp(path, keys, options) {
=======
function pathtoRegexp(path, keys, options) {
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
function pathtoRegexp(path, keys, options) {
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)
  options = options || {};
  keys = keys || [];
  var strict = options.strict;
  var end = options.end !== false;
  var flags = options.sensitive ? '' : 'i';
<<<<<<< HEAD
<<<<<<< HEAD
  var lookahead = options.lookahead !== false;
=======
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)
  var extraOffset = 0;
  var keysOffset = keys.length;
  var i = 0;
  var name = 0;
<<<<<<< HEAD
<<<<<<< HEAD
  var pos = 0;
  var backtrack = '';
=======
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)
  var m;

  if (path instanceof RegExp) {
    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {
<<<<<<< HEAD
<<<<<<< HEAD
      if (m[0][0] === '\\') continue;

      keys.push({
        name: m[1] || name++,
=======
      keys.push({
        name: name++,
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
      keys.push({
        name: name++,
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)
        optional: false,
        offset: m.index
      });
    }

    return path;
  }

  if (Array.isArray(path)) {
    // Map array parts into regexps and return their source. We also pass
    // the same keys and options instance into every generation to get
    // consistent matching groups before we join the sources together.
    path = path.map(function (value) {
<<<<<<< HEAD
<<<<<<< HEAD
      return pathToRegexp(value, keys, options).source;
=======
      return pathtoRegexp(value, keys, options).source;
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)
    });

    return new RegExp('(?:' + path.join('|') + ')', flags);
  }

  path = ('^' + path + (strict ? '' : path[path.length - 1] === '/' ? '?' : '/?'))
    .replace(/\/\(/g, '/(?:')
    .replace(/([\/\.])/g, '\\$1')
    .replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function (match, slash, format, key, capture, star, optional, offset) {
      slash = slash || '';
      format = format || '';
      capture = capture || '([^\\/' + format + ']+?)';
      optional = optional || '';
<<<<<<< HEAD
      capture = capture ?
        capture.replace(/\\.|\*/, function (m) { return m === '*' ? '(.*)' : m; }) :
        (backtrack ? '((?:(?!/|' + backtrack + ').)+?)' : '([^/' + format + ']+?)');
=======
      return pathtoRegexp(value, keys, options).source;
    });

    return new RegExp('(?:' + path.join('|') + ')', flags);
  }

  path = ('^' + path + (strict ? '' : path[path.length - 1] === '/' ? '?' : '/?'))
    .replace(/\/\(/g, '/(?:')
    .replace(/([\/\.])/g, '\\$1')
    .replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function (match, slash, format, key, capture, star, optional, offset) {
      slash = slash || '';
      format = format || '';
      capture = capture || '([^\\/' + format + ']+?)';
      optional = optional || '';
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)

      keys.push({
        name: key,
        optional: !!optional,
        offset: offset + extraOffset
      });

<<<<<<< HEAD
<<<<<<< HEAD
      var result = '(?:'
        + format + slash + capture
        + (star ? '((?:[/' + format + '].+?)?)' : '')
=======
=======
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)
      var result = ''
        + (optional ? '' : slash)
        + '(?:'
        + format + (optional ? slash : '') + capture
        + (star ? '((?:[\\/' + format + '].+?)?)' : '')
<<<<<<< HEAD
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)
        + ')'
        + optional;

      extraOffset += result.length - match.length;

      return result;
<<<<<<< HEAD
<<<<<<< HEAD
=======
=======
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)
    })
    .replace(/\*/g, function (star, index) {
      var len = keys.length

      while (len-- > keysOffset && keys[len].offset > index) {
        keys[len].offset += 3; // Replacement length minus asterisk length.
      }

      return '(.*)';
<<<<<<< HEAD
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)
    });

  // This is a workaround for handling unnamed matching groups.
  while (m = MATCHING_GROUP_REGEXP.exec(path)) {
<<<<<<< HEAD
<<<<<<< HEAD
    if (m[0][0] === '\\') continue;
=======
=======
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)
    var escapeCount = 0;
    var index = m.index;

    while (path.charAt(--index) === '\\') {
      escapeCount++;
    }

    // It's possible to escape the bracket.
    if (escapeCount % 2 === 1) {
      continue;
    }
<<<<<<< HEAD
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)

    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {
      keys.splice(keysOffset + i, 0, {
        name: name++, // Unnamed matching groups must be consistently linear.
        optional: false,
        offset: m.index
      });
    }

    i++;
  }

<<<<<<< HEAD
<<<<<<< HEAD
  path += strict ? '' : path[path.length - 1] === '/' ? '?' : '/?';

=======
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)
  // If the path is non-ending, match until the end or a slash.
  path += (end ? '$' : (path[path.length - 1] === '/' ? '' : '(?=\\/|$)'));

<<<<<<< HEAD
  return new RegExp('^' + path, flags);
=======
  // If the path is non-ending, match until the end or a slash.
  path += (end ? '$' : (path[path.length - 1] === '/' ? '' : '(?=\\/|$)'));

  return new RegExp(path, flags);
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
  return new RegExp(path, flags);
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)
};
