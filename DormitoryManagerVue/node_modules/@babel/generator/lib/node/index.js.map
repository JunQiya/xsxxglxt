<<<<<<< HEAD
<<<<<<< HEAD
{"version":3,"names":["whitespace","require","parens","_t","FLIPPED_ALIAS_KEYS","VISITOR_KEYS","isCallExpression","isDecorator","isExpressionStatement","isMemberExpression","isNewExpression","isParenthesizedExpression","TokenContext","exports","normal","expressionStatement","arrowBody","exportDefault","arrowFlowReturnType","forInitHead","forInHead","forOfHead","forInOrInitHeadAccumulate","forInOrInitHeadAccumulatePassThroughMask","expandAliases","obj","map","Map","add","type","func","fn","get","set","node","parent","stack","getRawIdentifier","_fn","Object","keys","aliases","alias","expandedParens","expandedWhitespaceNodes","nodes","isOrHasCallExpression","object","needsWhitespace","_expandedWhitespaceNo","expression","flag","needsWhitespaceBefore","needsWhitespaceAfter","needsParens","tokenContext","_expandedParens$get","callee","isDecoratorMemberExpression","computed","property","isLastChild","child","visitorKeys","i","length","val","Array","isArray","j"],"sources":["../../src/node/index.ts"],"sourcesContent":["import * as whitespace from \"./whitespace.ts\";\nimport * as parens from \"./parentheses.ts\";\nimport {\n  FLIPPED_ALIAS_KEYS,\n  VISITOR_KEYS,\n  isCallExpression,\n  isDecorator,\n  isExpressionStatement,\n  isMemberExpression,\n  isNewExpression,\n  isParenthesizedExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nimport type { WhitespaceFlag } from \"./whitespace.ts\";\n\nexport const enum TokenContext {\n  normal = 0,\n  expressionStatement = 1 << 0,\n  arrowBody = 1 << 1,\n  exportDefault = 1 << 2,\n  arrowFlowReturnType = 1 << 3,\n  forInitHead = 1 << 4,\n  forInHead = 1 << 5,\n  forOfHead = 1 << 6,\n  // This flag lives across the token boundary, and will\n  // be reset after forIn or forInit head is printed\n  forInOrInitHeadAccumulate = 1 << 7,\n  forInOrInitHeadAccumulatePassThroughMask = 0x80,\n}\n\ntype NodeHandler<R> = (\n  node: t.Node,\n  // todo:\n  // node: K extends keyof typeof t\n  //   ? Extract<typeof t[K], { type: \"string\" }>\n  //   : t.Node,\n  parent: t.Node,\n  tokenContext?: number,\n  getRawIdentifier?: (node: t.Identifier) => string,\n) => R | undefined;\n\nexport type NodeHandlers<R> = {\n  [K in string]?: NodeHandler<R>;\n};\n\nfunction expandAliases<R>(obj: NodeHandlers<R>) {\n  const map = new Map<string, NodeHandler<R>>();\n\n  function add(type: string, func: NodeHandler<R>) {\n    const fn = map.get(type);\n    map.set(\n      type,\n      fn\n        ? function (node, parent, stack, getRawIdentifier) {\n            return (\n              fn(node, parent, stack, getRawIdentifier) ??\n              func(node, parent, stack, getRawIdentifier)\n            );\n          }\n        : func,\n    );\n  }\n\n  for (const type of Object.keys(obj)) {\n    const aliases = FLIPPED_ALIAS_KEYS[type];\n    if (aliases) {\n      for (const alias of aliases) {\n        add(alias, obj[type]!);\n      }\n    } else {\n      add(type, obj[type]!);\n    }\n  }\n\n  return map;\n}\n\n// Rather than using `t.is` on each object property, we pre-expand any type aliases\n// into concrete types so that the 'find' call below can be as fast as possible.\nconst expandedParens = expandAliases(parens);\nconst expandedWhitespaceNodes = expandAliases(whitespace.nodes);\n\nfunction isOrHasCallExpression(node: t.Node): boolean {\n  if (isCallExpression(node)) {\n    return true;\n  }\n\n  return isMemberExpression(node) && isOrHasCallExpression(node.object);\n}\n\nexport function needsWhitespace(\n  node: t.Node,\n  parent: t.Node,\n  type: WhitespaceFlag,\n): boolean {\n  if (!node) return false;\n\n  if (isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  const flag = expandedWhitespaceNodes.get(node.type)?.(node, parent);\n\n  if (typeof flag === \"number\") {\n    return (flag & type) !== 0;\n  }\n\n  return false;\n}\n\nexport function needsWhitespaceBefore(node: t.Node, parent: t.Node) {\n  return needsWhitespace(node, parent, 1);\n}\n\nexport function needsWhitespaceAfter(node: t.Node, parent: t.Node) {\n  return needsWhitespace(node, parent, 2);\n}\n\nexport function needsParens(\n  node: t.Node,\n  parent: t.Node | null,\n  tokenContext?: number,\n  getRawIdentifier?: (node: t.Identifier) => string,\n): boolean {\n  if (!parent) return false;\n\n  if (isNewExpression(parent) && parent.callee === node) {\n    if (isOrHasCallExpression(node)) return true;\n  }\n\n  if (isDecorator(parent)) {\n    return (\n      !isDecoratorMemberExpression(node) &&\n      !(isCallExpression(node) && isDecoratorMemberExpression(node.callee)) &&\n      !isParenthesizedExpression(node)\n    );\n  }\n\n  return (\n    expandedParens.get(node.type)?.(\n      node,\n      parent,\n      tokenContext,\n      getRawIdentifier,\n    ) || false\n  );\n}\n\nfunction isDecoratorMemberExpression(node: t.Node): boolean {\n  switch (node.type) {\n    case \"Identifier\":\n      return true;\n    case \"MemberExpression\":\n      return (\n        !node.computed &&\n        node.property.type === \"Identifier\" &&\n        isDecoratorMemberExpression(node.object)\n      );\n    default:\n      return false;\n  }\n}\n\nexport function isLastChild(parent: t.Node, child: t.Node) {\n  const visitorKeys = VISITOR_KEYS[parent.type];\n  for (let i = visitorKeys.length - 1; i >= 0; i--) {\n    const val = (parent as any)[visitorKeys[i]] as t.Node | t.Node[] | null;\n    if (val === child) {\n      return true;\n    } else if (Array.isArray(val)) {\n      let j = val.length - 1;\n      while (j >= 0 && val[j] === null) j--;\n      return j >= 0 && val[j] === child;\n    } else if (val) {\n      return false;\n    }\n  }\n  return false;\n}\n"],"mappings":"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","ignoreList":[]}
=======
{"version":3,"names":["FLIPPED_ALIAS_KEYS","isCallExpression","isExpressionStatement","isMemberExpression","isNewExpression","expandAliases","obj","newObj","add","type","func","fn","node","parent","stack","result","Object","keys","aliases","alias","expandedParens","parens","expandedWhitespaceNodes","whitespace","nodes","find","printStack","isOrHasCallExpression","object","needsWhitespace","expression","flag","needsWhitespaceBefore","needsWhitespaceAfter","needsParens","callee"],"sources":["../../src/node/index.ts"],"sourcesContent":["import * as whitespace from \"./whitespace\";\nimport * as parens from \"./parentheses\";\nimport {\n  FLIPPED_ALIAS_KEYS,\n  isCallExpression,\n  isExpressionStatement,\n  isMemberExpression,\n  isNewExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nimport type { WhitespaceFlag } from \"./whitespace\";\n\nexport type NodeHandlers<R> = {\n  [K in string]?: (\n    node: K extends t.Node[\"type\"] ? Extract<t.Node, { type: K }> : t.Node,\n    // todo:\n    // node: K extends keyof typeof t\n    //   ? Extract<typeof t[K], { type: \"string\" }>\n    //   : t.Node,\n    parent: t.Node,\n    stack: t.Node[],\n  ) => R;\n};\n\nfunction expandAliases<R>(obj: NodeHandlers<R>) {\n  const newObj: NodeHandlers<R> = {};\n\n  function add(\n    type: string,\n    func: (node: t.Node, parent: t.Node, stack: t.Node[]) => R,\n  ) {\n    const fn = newObj[type];\n    newObj[type] = fn\n      ? function (node, parent, stack) {\n          const result = fn(node, parent, stack);\n\n          return result == null ? func(node, parent, stack) : result;\n        }\n      : func;\n  }\n\n  for (const type of Object.keys(obj)) {\n    const aliases = FLIPPED_ALIAS_KEYS[type];\n    if (aliases) {\n      for (const alias of aliases) {\n        add(alias, obj[type]);\n      }\n    } else {\n      add(type, obj[type]);\n    }\n  }\n\n  return newObj;\n}\n\n// Rather than using `t.is` on each object property, we pre-expand any type aliases\n// into concrete types so that the 'find' call below can be as fast as possible.\nconst expandedParens = expandAliases(parens);\nconst expandedWhitespaceNodes = expandAliases(whitespace.nodes);\n\nfunction find<R>(\n  obj: NodeHandlers<R>,\n  node: t.Node,\n  parent: t.Node,\n  printStack?: t.Node[],\n): R | null {\n  const fn = obj[node.type];\n  return fn ? fn(node, parent, printStack) : null;\n}\n\nfunction isOrHasCallExpression(node: t.Node): boolean {\n  if (isCallExpression(node)) {\n    return true;\n  }\n\n  return isMemberExpression(node) && isOrHasCallExpression(node.object);\n}\n\nexport function needsWhitespace(\n  node: t.Node,\n  parent: t.Node,\n  type: WhitespaceFlag,\n): boolean {\n  if (!node) return false;\n\n  if (isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  const flag = find(expandedWhitespaceNodes, node, parent);\n\n  if (typeof flag === \"number\") {\n    return (flag & type) !== 0;\n  }\n\n  return false;\n}\n\nexport function needsWhitespaceBefore(node: t.Node, parent: t.Node) {\n  return needsWhitespace(node, parent, 1);\n}\n\nexport function needsWhitespaceAfter(node: t.Node, parent: t.Node) {\n  return needsWhitespace(node, parent, 2);\n}\n\nexport function needsParens(\n  node: t.Node,\n  parent: t.Node,\n  printStack?: t.Node[],\n) {\n  if (!parent) return false;\n\n  if (isNewExpression(parent) && parent.callee === node) {\n    if (isOrHasCallExpression(node)) return true;\n  }\n\n  return find(expandedParens, node, parent, printStack);\n}\n"],"mappings":"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"}
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
{"version":3,"names":["whitespace","require","parens","_t","FLIPPED_ALIAS_KEYS","isCallExpression","isExpressionStatement","isMemberExpression","isNewExpression","expandAliases","obj","map","Map","add","type","func","fn","get","set","node","parent","stack","_fn","Object","keys","aliases","alias","expandedParens","expandedWhitespaceNodes","nodes","isOrHasCallExpression","object","needsWhitespace","_expandedWhitespaceNo","expression","flag","needsWhitespaceBefore","needsWhitespaceAfter","needsParens","printStack","_expandedParens$get","callee"],"sources":["../../src/node/index.ts"],"sourcesContent":["import * as whitespace from \"./whitespace.ts\";\nimport * as parens from \"./parentheses.ts\";\nimport {\n  FLIPPED_ALIAS_KEYS,\n  isCallExpression,\n  isExpressionStatement,\n  isMemberExpression,\n  isNewExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\nimport type { WhitespaceFlag } from \"./whitespace.ts\";\n\ntype NodeHandler<R> = (\n  node: t.Node,\n  // todo:\n  // node: K extends keyof typeof t\n  //   ? Extract<typeof t[K], { type: \"string\" }>\n  //   : t.Node,\n  parent: t.Node,\n  stack?: t.Node[],\n) => R;\n\nexport type NodeHandlers<R> = {\n  [K in string]?: NodeHandler<R>;\n};\n\nfunction expandAliases<R>(obj: NodeHandlers<R>) {\n  const map = new Map<string, NodeHandler<R>>();\n\n  function add(type: string, func: NodeHandler<R>) {\n    const fn = map.get(type);\n    map.set(\n      type,\n      fn\n        ? function (node, parent, stack) {\n            return fn(node, parent, stack) ?? func(node, parent, stack);\n          }\n        : func,\n    );\n  }\n\n  for (const type of Object.keys(obj)) {\n    const aliases = FLIPPED_ALIAS_KEYS[type];\n    if (aliases) {\n      for (const alias of aliases) {\n        add(alias, obj[type]);\n      }\n    } else {\n      add(type, obj[type]);\n    }\n  }\n\n  return map;\n}\n\n// Rather than using `t.is` on each object property, we pre-expand any type aliases\n// into concrete types so that the 'find' call below can be as fast as possible.\nconst expandedParens = expandAliases(parens);\nconst expandedWhitespaceNodes = expandAliases(whitespace.nodes);\n\nfunction isOrHasCallExpression(node: t.Node): boolean {\n  if (isCallExpression(node)) {\n    return true;\n  }\n\n  return isMemberExpression(node) && isOrHasCallExpression(node.object);\n}\n\nexport function needsWhitespace(\n  node: t.Node,\n  parent: t.Node,\n  type: WhitespaceFlag,\n): boolean {\n  if (!node) return false;\n\n  if (isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  const flag = expandedWhitespaceNodes.get(node.type)?.(node, parent);\n\n  if (typeof flag === \"number\") {\n    return (flag & type) !== 0;\n  }\n\n  return false;\n}\n\nexport function needsWhitespaceBefore(node: t.Node, parent: t.Node) {\n  return needsWhitespace(node, parent, 1);\n}\n\nexport function needsWhitespaceAfter(node: t.Node, parent: t.Node) {\n  return needsWhitespace(node, parent, 2);\n}\n\nexport function needsParens(\n  node: t.Node,\n  parent: t.Node,\n  printStack?: t.Node[],\n) {\n  if (!parent) return false;\n\n  if (isNewExpression(parent) && parent.callee === node) {\n    if (isOrHasCallExpression(node)) return true;\n  }\n\n  return expandedParens.get(node.type)?.(node, parent, printStack);\n}\n"],"mappings":"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","ignoreList":[]}
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)
