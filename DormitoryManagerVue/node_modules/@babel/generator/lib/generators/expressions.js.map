<<<<<<< HEAD
<<<<<<< HEAD
{"version":3,"names":["_t","require","_index","isCallExpression","isLiteral","isMemberExpression","isNewExpression","isPattern","UnaryExpression","node","operator","word","space","token","print","argument","DoExpression","async","body","ParenthesizedExpression","exit","enterDelimited","expression","rightParens","UpdateExpression","prefix","ConditionalExpression","test","consequent","alternate","NewExpression","parent","callee","format","minified","arguments","length","optional","typeArguments","typeParameters","tokenMap","endMatches","printList","shouldPrintTrailingComma","SequenceExpression","expressions","ThisExpression","Super","_shouldPrintDecoratorsBeforeExport","decoratorsBeforeExport","start","declaration","Decorator","newline","OptionalMemberExpression","computed","property","object","TypeError","value","OptionalCallExpression","CallExpression","Import","AwaitExpression","YieldExpression","delegate","EmptyStatement","semicolon","ExpressionStatement","tokenContext","TokenContext","expressionStatement","AssignmentPattern","left","type","typeAnnotation","right","AssignmentExpression","_endsWithDiv","BindExpression","MemberExpression","MetaProperty","meta","PrivateName","id","V8IntrinsicIdentifier","name","ModuleExpression","indent","directives","dedent","rightBrace"],"sources":["../../src/generators/expressions.ts"],"sourcesContent":["import type Printer from \"../printer.ts\";\nimport {\n  isCallExpression,\n  isLiteral,\n  isMemberExpression,\n  isNewExpression,\n  isPattern,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport { TokenContext } from \"../node/index.ts\";\n\nexport function UnaryExpression(this: Printer, node: t.UnaryExpression) {\n  const { operator } = node;\n  if (\n    operator === \"void\" ||\n    operator === \"delete\" ||\n    operator === \"typeof\" ||\n    // throwExpressions\n    operator === \"throw\"\n  ) {\n    this.word(operator);\n    this.space();\n  } else {\n    this.token(operator);\n  }\n\n  this.print(node.argument);\n}\n\nexport function DoExpression(this: Printer, node: t.DoExpression) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n  this.word(\"do\");\n  this.space();\n  this.print(node.body);\n}\n\nexport function ParenthesizedExpression(\n  this: Printer,\n  node: t.ParenthesizedExpression,\n) {\n  this.token(\"(\");\n  const exit = this.enterDelimited();\n  this.print(node.expression);\n  exit();\n  this.rightParens(node);\n}\n\nexport function UpdateExpression(this: Printer, node: t.UpdateExpression) {\n  if (node.prefix) {\n    this.token(node.operator);\n    this.print(node.argument);\n  } else {\n    this.print(node.argument, true);\n    this.token(node.operator);\n  }\n}\n\nexport function ConditionalExpression(\n  this: Printer,\n  node: t.ConditionalExpression,\n) {\n  this.print(node.test);\n  this.space();\n  this.token(\"?\");\n  this.space();\n  this.print(node.consequent);\n  this.space();\n  this.token(\":\");\n  this.space();\n  this.print(node.alternate);\n}\n\nexport function NewExpression(\n  this: Printer,\n  node: t.NewExpression,\n  parent: t.Node,\n) {\n  this.word(\"new\");\n  this.space();\n  this.print(node.callee);\n  if (\n    this.format.minified &&\n    node.arguments.length === 0 &&\n    // @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8\n    !node.optional &&\n    !isCallExpression(parent, { callee: node }) &&\n    !isMemberExpression(parent) &&\n    !isNewExpression(parent)\n  ) {\n    return;\n  }\n\n  this.print(node.typeArguments);\n  if (!process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8\n    this.print(node.typeParameters); // Legacy TS AST\n    // @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8\n    if (node.optional) {\n      this.token(\"?.\");\n    }\n  }\n\n  if (\n    node.arguments.length === 0 &&\n    this.tokenMap &&\n    !this.tokenMap.endMatches(node, \")\")\n  ) {\n    return;\n  }\n\n  this.token(\"(\");\n  const exit = this.enterDelimited();\n  this.printList(node.arguments, this.shouldPrintTrailingComma(\")\"));\n  exit();\n  this.rightParens(node);\n}\n\nexport function SequenceExpression(this: Printer, node: t.SequenceExpression) {\n  this.printList(node.expressions);\n}\n\nexport function ThisExpression(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function Super(this: Printer) {\n  this.word(\"super\");\n}\n\nexport function _shouldPrintDecoratorsBeforeExport(\n  this: Printer,\n  node: t.ExportDeclaration & { declaration: t.ClassDeclaration },\n) {\n  if (typeof this.format.decoratorsBeforeExport === \"boolean\") {\n    return this.format.decoratorsBeforeExport;\n  }\n  return (\n    typeof node.start === \"number\" && node.start === node.declaration.start\n  );\n}\n\nexport function Decorator(this: Printer, node: t.Decorator) {\n  this.token(\"@\");\n  this.print(node.expression);\n  this.newline();\n}\n\nexport function OptionalMemberExpression(\n  this: Printer,\n  node: t.OptionalMemberExpression,\n) {\n  let { computed } = node;\n  const { optional, property } = node;\n\n  this.print(node.object);\n\n  if (!computed && isMemberExpression(property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  // @ts-expect-error todo(flow->ts) maybe instead of typeof check specific literal types?\n  if (isLiteral(property) && typeof property.value === \"number\") {\n    computed = true;\n  }\n  if (optional) {\n    this.token(\"?.\");\n  }\n\n  if (computed) {\n    this.token(\"[\");\n    this.print(property);\n    this.token(\"]\");\n  } else {\n    if (!optional) {\n      this.token(\".\");\n    }\n    this.print(property);\n  }\n}\n\nexport function OptionalCallExpression(\n  this: Printer,\n  node: t.OptionalCallExpression,\n) {\n  this.print(node.callee);\n\n  if (!process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8\n    this.print(node.typeParameters); // legacy TS AST\n  }\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  this.print(node.typeArguments);\n\n  this.token(\"(\");\n  const exit = this.enterDelimited();\n  this.printList(node.arguments);\n  exit();\n  this.rightParens(node);\n}\n\nexport function CallExpression(this: Printer, node: t.CallExpression) {\n  this.print(node.callee);\n\n  this.print(node.typeArguments);\n  if (!process.env.BABEL_8_BREAKING) {\n    // @ts-ignore(Babel 7 vs Babel 8) Removed in Babel 8\n    this.print(node.typeParameters); // legacy TS AST\n  }\n  this.token(\"(\");\n  const exit = this.enterDelimited();\n  this.printList(node.arguments, this.shouldPrintTrailingComma(\")\"));\n  exit();\n  this.rightParens(node);\n}\n\nexport function Import(this: Printer) {\n  this.word(\"import\");\n}\n\nexport function AwaitExpression(this: Printer, node: t.AwaitExpression) {\n  this.word(\"await\");\n  this.space();\n  this.print(node.argument);\n}\n\nexport function YieldExpression(this: Printer, node: t.YieldExpression) {\n  if (node.delegate) {\n    this.word(\"yield\", true);\n    this.token(\"*\");\n    if (node.argument) {\n      this.space();\n      // line terminators are allowed after yield*\n      this.print(node.argument);\n    }\n  } else if (node.argument) {\n    this.word(\"yield\", true);\n    this.space();\n    this.print(node.argument);\n  } else {\n    this.word(\"yield\");\n  }\n}\n\nexport function EmptyStatement(this: Printer) {\n  this.semicolon(true /* force */);\n}\n\nexport function ExpressionStatement(\n  this: Printer,\n  node: t.ExpressionStatement,\n) {\n  this.tokenContext |= TokenContext.expressionStatement;\n  this.print(node.expression);\n  this.semicolon();\n}\n\nexport function AssignmentPattern(this: Printer, node: t.AssignmentPattern) {\n  this.print(node.left);\n  if (node.left.type === \"Identifier\" || isPattern(node.left)) {\n    if (node.left.optional) this.token(\"?\");\n    this.print(node.left.typeAnnotation);\n  }\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right);\n}\n\nexport function AssignmentExpression(\n  this: Printer,\n  node: t.AssignmentExpression | t.BinaryExpression | t.LogicalExpression,\n) {\n  this.print(node.left);\n\n  this.space();\n  if (node.operator === \"in\" || node.operator === \"instanceof\") {\n    this.word(node.operator);\n  } else {\n    this.token(node.operator);\n    this._endsWithDiv = node.operator === \"/\";\n  }\n  this.space();\n\n  this.print(node.right);\n}\n\nexport function BindExpression(this: Printer, node: t.BindExpression) {\n  this.print(node.object);\n  this.token(\"::\");\n  this.print(node.callee);\n}\n\nexport {\n  AssignmentExpression as BinaryExpression,\n  AssignmentExpression as LogicalExpression,\n};\n\nexport function MemberExpression(this: Printer, node: t.MemberExpression) {\n  this.print(node.object);\n\n  if (!node.computed && isMemberExpression(node.property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  let computed = node.computed;\n  // @ts-expect-error todo(flow->ts) maybe use specific literal types\n  if (isLiteral(node.property) && typeof node.property.value === \"number\") {\n    computed = true;\n  }\n\n  if (computed) {\n    const exit = this.enterDelimited();\n    this.token(\"[\");\n    this.print(node.property);\n    this.token(\"]\");\n    exit();\n  } else {\n    this.token(\".\");\n    this.print(node.property);\n  }\n}\n\nexport function MetaProperty(this: Printer, node: t.MetaProperty) {\n  this.print(node.meta);\n  this.token(\".\");\n  this.print(node.property);\n}\n\nexport function PrivateName(this: Printer, node: t.PrivateName) {\n  this.token(\"#\");\n  this.print(node.id);\n}\n\nexport function V8IntrinsicIdentifier(\n  this: Printer,\n  node: t.V8IntrinsicIdentifier,\n) {\n  this.token(\"%\");\n  this.word(node.name);\n}\n\nexport function ModuleExpression(this: Printer, node: t.ModuleExpression) {\n  this.word(\"module\", true);\n  this.space();\n  this.token(\"{\");\n  this.indent();\n  const { body } = node;\n  if (body.body.length || body.directives.length) {\n    this.newline();\n  }\n  this.print(body);\n  this.dedent();\n  this.rightBrace(node);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,IAAAA,EAAA,GAAAC,OAAA;AAQA,IAAAC,MAAA,GAAAD,OAAA;AAAgD;EAP9CE,gBAAgB;EAChBC,SAAS;EACTC,kBAAkB;EAClBC,eAAe;EACfC;AAAS,IAAAP,EAAA;AAKJ,SAASQ,eAAeA,CAAgBC,IAAuB,EAAE;EACtE,MAAM;IAAEC;EAAS,CAAC,GAAGD,IAAI;EACzB,IACEC,QAAQ,KAAK,MAAM,IACnBA,QAAQ,KAAK,QAAQ,IACrBA,QAAQ,KAAK,QAAQ,IAErBA,QAAQ,KAAK,OAAO,EACpB;IACA,IAAI,CAACC,IAAI,CAACD,QAAQ,CAAC;IACnB,IAAI,CAACE,KAAK,CAAC,CAAC;EACd,CAAC,MAAM;IACL,IAAI,CAACC,KAAK,CAACH,QAAQ,CAAC;EACtB;EAEA,IAAI,CAACI,KAAK,CAACL,IAAI,CAACM,QAAQ,CAAC;AAC3B;AAEO,SAASC,YAAYA,CAAgBP,IAAoB,EAAE;EAChE,IAAIA,IAAI,CAACQ,KAAK,EAAE;IACd,IAAI,CAACN,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC;IACxB,IAAI,CAACC,KAAK,CAAC,CAAC;EACd;EACA,IAAI,CAACD,IAAI,CAAC,IAAI,CAAC;EACf,IAAI,CAACC,KAAK,CAAC,CAAC;EACZ,IAAI,CAACE,KAAK,CAACL,IAAI,CAACS,IAAI,CAAC;AACvB;AAEO,SAASC,uBAAuBA,CAErCV,IAA+B,EAC/B;EACA,IAAI,CAACI,SAAK,GAAI,CAAC;EACf,MAAMO,IAAI,GAAG,IAAI,CAACC,cAAc,CAAC,CAAC;EAClC,IAAI,CAACP,KAAK,CAACL,IAAI,CAACa,UAAU,CAAC;EAC3BF,IAAI,CAAC,CAAC;EACN,IAAI,CAACG,WAAW,CAACd,IAAI,CAAC;AACxB;AAEO,SAASe,gBAAgBA,CAAgBf,IAAwB,EAAE;EACxE,IAAIA,IAAI,CAACgB,MAAM,EAAE;IACf,IAAI,CAACZ,KAAK,CAACJ,IAAI,CAACC,QAAQ,CAAC;IACzB,IAAI,CAACI,KAAK,CAACL,IAAI,CAACM,QAAQ,CAAC;EAC3B,CAAC,MAAM;IACL,IAAI,CAACD,KAAK,CAACL,IAAI,CAACM,QAAQ,EAAE,IAAI,CAAC;IAC/B,IAAI,CAACF,KAAK,CAACJ,IAAI,CAACC,QAAQ,CAAC;EAC3B;AACF;AAEO,SAASgB,qBAAqBA,CAEnCjB,IAA6B,EAC7B;EACA,IAAI,CAACK,KAAK,CAACL,IAAI,CAACkB,IAAI,CAAC;EACrB,IAAI,CAACf,KAAK,CAAC,CAAC;EACZ,IAAI,CAACC,SAAK,GAAI,CAAC;EACf,IAAI,CAACD,KAAK,CAAC,CAAC;EACZ,IAAI,CAACE,KAAK,CAACL,IAAI,CAACmB,UAAU,CAAC;EAC3B,IAAI,CAAChB,KAAK,CAAC,CAAC;EACZ,IAAI,CAACC,SAAK,GAAI,CAAC;EACf,IAAI,CAACD,KAAK,CAAC,CAAC;EACZ,IAAI,CAACE,KAAK,CAACL,IAAI,CAACoB,SAAS,CAAC;AAC5B;AAEO,SAASC,aAAaA,CAE3BrB,IAAqB,EACrBsB,MAAc,EACd;EACA,IAAI,CAACpB,IAAI,CAAC,KAAK,CAAC;EAChB,IAAI,CAACC,KAAK,CAAC,CAAC;EACZ,IAAI,CAACE,KAAK,CAACL,IAAI,CAACuB,MAAM,CAAC;EACvB,IACE,IAAI,CAACC,MAAM,CAACC,QAAQ,IACpBzB,IAAI,CAAC0B,SAAS,CAACC,MAAM,KAAK,CAAC,IAE3B,CAAC3B,IAAI,CAAC4B,QAAQ,IACd,CAAClC,gBAAgB,CAAC4B,MAAM,EAAE;IAAEC,MAAM,EAAEvB;EAAK,CAAC,CAAC,IAC3C,CAACJ,kBAAkB,CAAC0B,MAAM,CAAC,IAC3B,CAACzB,eAAe,CAACyB,MAAM,CAAC,EACxB;IACA;EACF;EAEA,IAAI,CAACjB,KAAK,CAACL,IAAI,CAAC6B,aAAa,CAAC;EACK;IAEjC,IAAI,CAACxB,KAAK,CAACL,IAAI,CAAC8B,cAAc,CAAC;IAE/B,IAAI9B,IAAI,CAAC4B,QAAQ,EAAE;MACjB,IAAI,CAACxB,KAAK,CAAC,IAAI,CAAC;IAClB;EACF;EAEA,IACEJ,IAAI,CAAC0B,SAAS,CAACC,MAAM,KAAK,CAAC,IAC3B,IAAI,CAACI,QAAQ,IACb,CAAC,IAAI,CAACA,QAAQ,CAACC,UAAU,CAAChC,IAAI,EAAE,GAAG,CAAC,EACpC;IACA;EACF;EAEA,IAAI,CAACI,SAAK,GAAI,CAAC;EACf,MAAMO,IAAI,GAAG,IAAI,CAACC,cAAc,CAAC,CAAC;EAClC,IAAI,CAACqB,SAAS,CAACjC,IAAI,CAAC0B,SAAS,EAAE,IAAI,CAACQ,wBAAwB,CAAC,GAAG,CAAC,CAAC;EAClEvB,IAAI,CAAC,CAAC;EACN,IAAI,CAACG,WAAW,CAACd,IAAI,CAAC;AACxB;AAEO,SAASmC,kBAAkBA,CAAgBnC,IAA0B,EAAE;EAC5E,IAAI,CAACiC,SAAS,CAACjC,IAAI,CAACoC,WAAW,CAAC;AAClC;AAEO,SAASC,cAAcA,CAAA,EAAgB;EAC5C,IAAI,CAACnC,IAAI,CAAC,MAAM,CAAC;AACnB;AAEO,SAASoC,KAAKA,CAAA,EAAgB;EACnC,IAAI,CAACpC,IAAI,CAAC,OAAO,CAAC;AACpB;AAEO,SAASqC,kCAAkCA,CAEhDvC,IAA+D,EAC/D;EACA,IAAI,OAAO,IAAI,CAACwB,MAAM,CAACgB,sBAAsB,KAAK,SAAS,EAAE;IAC3D,OAAO,IAAI,CAAChB,MAAM,CAACgB,sBAAsB;EAC3C;EACA,OACE,OAAOxC,IAAI,CAACyC,KAAK,KAAK,QAAQ,IAAIzC,IAAI,CAACyC,KAAK,KAAKzC,IAAI,CAAC0C,WAAW,CAACD,KAAK;AAE3E;AAEO,SAASE,SAASA,CAAgB3C,IAAiB,EAAE;EAC1D,IAAI,CAACI,SAAK,GAAI,CAAC;EACf,IAAI,CAACC,KAAK,CAACL,IAAI,CAACa,UAAU,CAAC;EAC3B,IAAI,CAAC+B,OAAO,CAAC,CAAC;AAChB;AAEO,SAASC,wBAAwBA,CAEtC7C,IAAgC,EAChC;EACA,IAAI;IAAE8C;EAAS,CAAC,GAAG9C,IAAI;EACvB,MAAM;IAAE4B,QAAQ;IAAEmB;EAAS,CAAC,GAAG/C,IAAI;EAEnC,IAAI,CAACK,KAAK,CAACL,IAAI,CAACgD,MAAM,CAAC;EAEvB,IAAI,CAACF,QAAQ,IAAIlD,kBAAkB,CAACmD,QAAQ,CAAC,EAAE;IAC7C,MAAM,IAAIE,SAAS,CAAC,sDAAsD,CAAC;EAC7E;EAGA,IAAItD,SAAS,CAACoD,QAAQ,CAAC,IAAI,OAAOA,QAAQ,CAACG,KAAK,KAAK,QAAQ,EAAE;IAC7DJ,QAAQ,GAAG,IAAI;EACjB;EACA,IAAIlB,QAAQ,EAAE;IACZ,IAAI,CAACxB,KAAK,CAAC,IAAI,CAAC;EAClB;EAEA,IAAI0C,QAAQ,EAAE;IACZ,IAAI,CAAC1C,SAAK,GAAI,CAAC;IACf,IAAI,CAACC,KAAK,CAAC0C,QAAQ,CAAC;IACpB,IAAI,CAAC3C,SAAK,GAAI,CAAC;EACjB,CAAC,MAAM;IACL,IAAI,CAACwB,QAAQ,EAAE;MACb,IAAI,CAACxB,SAAK,GAAI,CAAC;IACjB;IACA,IAAI,CAACC,KAAK,CAAC0C,QAAQ,CAAC;EACtB;AACF;AAEO,SAASI,sBAAsBA,CAEpCnD,IAA8B,EAC9B;EACA,IAAI,CAACK,KAAK,CAACL,IAAI,CAACuB,MAAM,CAAC;EAEY;IAEjC,IAAI,CAAClB,KAAK,CAACL,IAAI,CAAC8B,cAAc,CAAC;EACjC;EAEA,IAAI9B,IAAI,CAAC4B,QAAQ,EAAE;IACjB,IAAI,CAACxB,KAAK,CAAC,IAAI,CAAC;EAClB;EAEA,IAAI,CAACC,KAAK,CAACL,IAAI,CAAC6B,aAAa,CAAC;EAE9B,IAAI,CAACzB,SAAK,GAAI,CAAC;EACf,MAAMO,IAAI,GAAG,IAAI,CAACC,cAAc,CAAC,CAAC;EAClC,IAAI,CAACqB,SAAS,CAACjC,IAAI,CAAC0B,SAAS,CAAC;EAC9Bf,IAAI,CAAC,CAAC;EACN,IAAI,CAACG,WAAW,CAACd,IAAI,CAAC;AACxB;AAEO,SAASoD,cAAcA,CAAgBpD,IAAsB,EAAE;EACpE,IAAI,CAACK,KAAK,CAACL,IAAI,CAACuB,MAAM,CAAC;EAEvB,IAAI,CAAClB,KAAK,CAACL,IAAI,CAAC6B,aAAa,CAAC;EACK;IAEjC,IAAI,CAACxB,KAAK,CAACL,IAAI,CAAC8B,cAAc,CAAC;EACjC;EACA,IAAI,CAAC1B,SAAK,GAAI,CAAC;EACf,MAAMO,IAAI,GAAG,IAAI,CAACC,cAAc,CAAC,CAAC;EAClC,IAAI,CAACqB,SAAS,CAACjC,IAAI,CAAC0B,SAAS,EAAE,IAAI,CAACQ,wBAAwB,CAAC,GAAG,CAAC,CAAC;EAClEvB,IAAI,CAAC,CAAC;EACN,IAAI,CAACG,WAAW,CAACd,IAAI,CAAC;AACxB;AAEO,SAASqD,MAAMA,CAAA,EAAgB;EACpC,IAAI,CAACnD,IAAI,CAAC,QAAQ,CAAC;AACrB;AAEO,SAASoD,eAAeA,CAAgBtD,IAAuB,EAAE;EACtE,IAAI,CAACE,IAAI,CAAC,OAAO,CAAC;EAClB,IAAI,CAACC,KAAK,CAAC,CAAC;EACZ,IAAI,CAACE,KAAK,CAACL,IAAI,CAACM,QAAQ,CAAC;AAC3B;AAEO,SAASiD,eAAeA,CAAgBvD,IAAuB,EAAE;EACtE,IAAIA,IAAI,CAACwD,QAAQ,EAAE;IACjB,IAAI,CAACtD,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC;IACxB,IAAI,CAACE,SAAK,GAAI,CAAC;IACf,IAAIJ,IAAI,CAACM,QAAQ,EAAE;MACjB,IAAI,CAACH,KAAK,CAAC,CAAC;MAEZ,IAAI,CAACE,KAAK,CAACL,IAAI,CAACM,QAAQ,CAAC;IAC3B;EACF,CAAC,MAAM,IAAIN,IAAI,CAACM,QAAQ,EAAE;IACxB,IAAI,CAACJ,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC;IACxB,IAAI,CAACC,KAAK,CAAC,CAAC;IACZ,IAAI,CAACE,KAAK,CAACL,IAAI,CAACM,QAAQ,CAAC;EAC3B,CAAC,MAAM;IACL,IAAI,CAACJ,IAAI,CAAC,OAAO,CAAC;EACpB;AACF;AAEO,SAASuD,cAAcA,CAAA,EAAgB;EAC5C,IAAI,CAACC,SAAS,CAAC,IAAgB,CAAC;AAClC;AAEO,SAASC,mBAAmBA,CAEjC3D,IAA2B,EAC3B;EACA,IAAI,CAAC4D,YAAY,IAAIC,mBAAY,CAACC,mBAAmB;EACrD,IAAI,CAACzD,KAAK,CAACL,IAAI,CAACa,UAAU,CAAC;EAC3B,IAAI,CAAC6C,SAAS,CAAC,CAAC;AAClB;AAEO,SAASK,iBAAiBA,CAAgB/D,IAAyB,EAAE;EAC1E,IAAI,CAACK,KAAK,CAACL,IAAI,CAACgE,IAAI,CAAC;EACrB,IAAIhE,IAAI,CAACgE,IAAI,CAACC,IAAI,KAAK,YAAY,IAAInE,SAAS,CAACE,IAAI,CAACgE,IAAI,CAAC,EAAE;IAC3D,IAAIhE,IAAI,CAACgE,IAAI,CAACpC,QAAQ,EAAE,IAAI,CAACxB,SAAK,GAAI,CAAC;IACvC,IAAI,CAACC,KAAK,CAACL,IAAI,CAACgE,IAAI,CAACE,cAAc,CAAC;EACtC;EACA,IAAI,CAAC/D,KAAK,CAAC,CAAC;EACZ,IAAI,CAACC,SAAK,GAAI,CAAC;EACf,IAAI,CAACD,KAAK,CAAC,CAAC;EACZ,IAAI,CAACE,KAAK,CAACL,IAAI,CAACmE,KAAK,CAAC;AACxB;AAEO,SAASC,oBAAoBA,CAElCpE,IAAuE,EACvE;EACA,IAAI,CAACK,KAAK,CAACL,IAAI,CAACgE,IAAI,CAAC;EAErB,IAAI,CAAC7D,KAAK,CAAC,CAAC;EACZ,IAAIH,IAAI,CAACC,QAAQ,KAAK,IAAI,IAAID,IAAI,CAACC,QAAQ,KAAK,YAAY,EAAE;IAC5D,IAAI,CAACC,IAAI,CAACF,IAAI,CAACC,QAAQ,CAAC;EAC1B,CAAC,MAAM;IACL,IAAI,CAACG,KAAK,CAACJ,IAAI,CAACC,QAAQ,CAAC;IACzB,IAAI,CAACoE,YAAY,GAAGrE,IAAI,CAACC,QAAQ,KAAK,GAAG;EAC3C;EACA,IAAI,CAACE,KAAK,CAAC,CAAC;EAEZ,IAAI,CAACE,KAAK,CAACL,IAAI,CAACmE,KAAK,CAAC;AACxB;AAEO,SAASG,cAAcA,CAAgBtE,IAAsB,EAAE;EACpE,IAAI,CAACK,KAAK,CAACL,IAAI,CAACgD,MAAM,CAAC;EACvB,IAAI,CAAC5C,KAAK,CAAC,IAAI,CAAC;EAChB,IAAI,CAACC,KAAK,CAACL,IAAI,CAACuB,MAAM,CAAC;AACzB;AAOO,SAASgD,gBAAgBA,CAAgBvE,IAAwB,EAAE;EACxE,IAAI,CAACK,KAAK,CAACL,IAAI,CAACgD,MAAM,CAAC;EAEvB,IAAI,CAAChD,IAAI,CAAC8C,QAAQ,IAAIlD,kBAAkB,CAACI,IAAI,CAAC+C,QAAQ,CAAC,EAAE;IACvD,MAAM,IAAIE,SAAS,CAAC,sDAAsD,CAAC;EAC7E;EAEA,IAAIH,QAAQ,GAAG9C,IAAI,CAAC8C,QAAQ;EAE5B,IAAInD,SAAS,CAACK,IAAI,CAAC+C,QAAQ,CAAC,IAAI,OAAO/C,IAAI,CAAC+C,QAAQ,CAACG,KAAK,KAAK,QAAQ,EAAE;IACvEJ,QAAQ,GAAG,IAAI;EACjB;EAEA,IAAIA,QAAQ,EAAE;IACZ,MAAMnC,IAAI,GAAG,IAAI,CAACC,cAAc,CAAC,CAAC;IAClC,IAAI,CAACR,SAAK,GAAI,CAAC;IACf,IAAI,CAACC,KAAK,CAACL,IAAI,CAAC+C,QAAQ,CAAC;IACzB,IAAI,CAAC3C,SAAK,GAAI,CAAC;IACfO,IAAI,CAAC,CAAC;EACR,CAAC,MAAM;IACL,IAAI,CAACP,SAAK,GAAI,CAAC;IACf,IAAI,CAACC,KAAK,CAACL,IAAI,CAAC+C,QAAQ,CAAC;EAC3B;AACF;AAEO,SAASyB,YAAYA,CAAgBxE,IAAoB,EAAE;EAChE,IAAI,CAACK,KAAK,CAACL,IAAI,CAACyE,IAAI,CAAC;EACrB,IAAI,CAACrE,SAAK,GAAI,CAAC;EACf,IAAI,CAACC,KAAK,CAACL,IAAI,CAAC+C,QAAQ,CAAC;AAC3B;AAEO,SAAS2B,WAAWA,CAAgB1E,IAAmB,EAAE;EAC9D,IAAI,CAACI,SAAK,GAAI,CAAC;EACf,IAAI,CAACC,KAAK,CAACL,IAAI,CAAC2E,EAAE,CAAC;AACrB;AAEO,SAASC,qBAAqBA,CAEnC5E,IAA6B,EAC7B;EACA,IAAI,CAACI,SAAK,GAAI,CAAC;EACf,IAAI,CAACF,IAAI,CAACF,IAAI,CAAC6E,IAAI,CAAC;AACtB;AAEO,SAASC,gBAAgBA,CAAgB9E,IAAwB,EAAE;EACxE,IAAI,CAACE,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC;EACzB,IAAI,CAACC,KAAK,CAAC,CAAC;EACZ,IAAI,CAACC,SAAK,IAAI,CAAC;EACf,IAAI,CAAC2E,MAAM,CAAC,CAAC;EACb,MAAM;IAAEtE;EAAK,CAAC,GAAGT,IAAI;EACrB,IAAIS,IAAI,CAACA,IAAI,CAACkB,MAAM,IAAIlB,IAAI,CAACuE,UAAU,CAACrD,MAAM,EAAE;IAC9C,IAAI,CAACiB,OAAO,CAAC,CAAC;EAChB;EACA,IAAI,CAACvC,KAAK,CAACI,IAAI,CAAC;EAChB,IAAI,CAACwE,MAAM,CAAC,CAAC;EACb,IAAI,CAACC,UAAU,CAAClF,IAAI,CAAC;AACvB","ignoreList":[]}
=======
{"version":3,"names":["isCallExpression","isLiteral","isMemberExpression","isNewExpression","UnaryExpression","node","operator","word","space","token","print","argument","DoExpression","async","body","ParenthesizedExpression","expression","UpdateExpression","prefix","printTerminatorless","ConditionalExpression","test","consequent","alternate","NewExpression","parent","callee","format","minified","arguments","length","optional","typeArguments","typeParameters","printList","SequenceExpression","expressions","ThisExpression","Super","isDecoratorMemberExpression","type","computed","property","object","shouldParenthesizeDecoratorExpression","_shouldPrintDecoratorsBeforeExport","decoratorsBeforeExport","start","declaration","Decorator","newline","OptionalMemberExpression","TypeError","value","OptionalCallExpression","CallExpression","Import","AwaitExpression","YieldExpression","delegate","EmptyStatement","semicolon","ExpressionStatement","AssignmentPattern","left","typeAnnotation","right","AssignmentExpression","parens","inForStatementInitCounter","n","needsParens","BindExpression","MemberExpression","MetaProperty","meta","PrivateName","id","V8IntrinsicIdentifier","name","ModuleExpression","indent","directives","dedent","sourceWithOffset","loc","rightBrace"],"sources":["../../src/generators/expressions.ts"],"sourcesContent":["import type Printer from \"../printer\";\nimport {\n  isCallExpression,\n  isLiteral,\n  isMemberExpression,\n  isNewExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport * as n from \"../node\";\n\nexport function UnaryExpression(this: Printer, node: t.UnaryExpression) {\n  if (\n    node.operator === \"void\" ||\n    node.operator === \"delete\" ||\n    node.operator === \"typeof\" ||\n    // throwExpressions\n    node.operator === \"throw\"\n  ) {\n    this.word(node.operator);\n    this.space();\n  } else {\n    this.token(node.operator);\n  }\n\n  this.print(node.argument, node);\n}\n\nexport function DoExpression(this: Printer, node: t.DoExpression) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n  this.word(\"do\");\n  this.space();\n  this.print(node.body, node);\n}\n\nexport function ParenthesizedExpression(\n  this: Printer,\n  node: t.ParenthesizedExpression,\n) {\n  this.token(\"(\");\n  this.print(node.expression, node);\n  this.token(\")\");\n}\n\nexport function UpdateExpression(this: Printer, node: t.UpdateExpression) {\n  if (node.prefix) {\n    this.token(node.operator);\n    this.print(node.argument, node);\n  } else {\n    this.printTerminatorless(node.argument, node, true);\n    this.token(node.operator);\n  }\n}\n\nexport function ConditionalExpression(\n  this: Printer,\n  node: t.ConditionalExpression,\n) {\n  this.print(node.test, node);\n  this.space();\n  this.token(\"?\");\n  this.space();\n  this.print(node.consequent, node);\n  this.space();\n  this.token(\":\");\n  this.space();\n  this.print(node.alternate, node);\n}\n\nexport function NewExpression(\n  this: Printer,\n  node: t.NewExpression,\n  parent: t.Node,\n) {\n  this.word(\"new\");\n  this.space();\n  this.print(node.callee, node);\n  if (\n    this.format.minified &&\n    node.arguments.length === 0 &&\n    !node.optional &&\n    !isCallExpression(parent, { callee: node }) &&\n    !isMemberExpression(parent) &&\n    !isNewExpression(parent)\n  ) {\n    return;\n  }\n\n  this.print(node.typeArguments, node); // Flow\n  this.print(node.typeParameters, node); // TS\n\n  if (node.optional) {\n    // TODO: This can never happen\n    this.token(\"?.\");\n  }\n  this.token(\"(\");\n  this.printList(node.arguments, node);\n  this.token(\")\");\n}\n\nexport function SequenceExpression(this: Printer, node: t.SequenceExpression) {\n  this.printList(node.expressions, node);\n}\n\nexport function ThisExpression(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function Super(this: Printer) {\n  this.word(\"super\");\n}\n\nfunction isDecoratorMemberExpression(\n  node: t.Expression | t.Super | t.V8IntrinsicIdentifier,\n): boolean {\n  switch (node.type) {\n    case \"Identifier\":\n      return true;\n    case \"MemberExpression\":\n      return (\n        !node.computed &&\n        node.property.type === \"Identifier\" &&\n        isDecoratorMemberExpression(node.object)\n      );\n    default:\n      return false;\n  }\n}\nfunction shouldParenthesizeDecoratorExpression(\n  node: t.Expression | t.Super | t.V8IntrinsicIdentifier,\n) {\n  if (node.type === \"ParenthesizedExpression\") {\n    // We didn't check extra?.parenthesized here because we don't track decorators in needsParen\n    return false;\n  }\n  return !isDecoratorMemberExpression(\n    node.type === \"CallExpression\" ? node.callee : node,\n  );\n}\n\nexport function _shouldPrintDecoratorsBeforeExport(\n  this: Printer,\n  node: t.ExportDeclaration & { declaration: t.ClassDeclaration },\n) {\n  if (typeof this.format.decoratorsBeforeExport === \"boolean\") {\n    return this.format.decoratorsBeforeExport;\n  }\n  return (\n    typeof node.start === \"number\" && node.start === node.declaration.start\n  );\n}\n\nexport function Decorator(this: Printer, node: t.Decorator) {\n  this.token(\"@\");\n  const { expression } = node;\n  if (shouldParenthesizeDecoratorExpression(expression)) {\n    this.token(\"(\");\n    this.print(expression, node);\n    this.token(\")\");\n  } else {\n    this.print(expression, node);\n  }\n  this.newline();\n}\n\nexport function OptionalMemberExpression(\n  this: Printer,\n  node: t.OptionalMemberExpression,\n) {\n  this.print(node.object, node);\n\n  if (!node.computed && isMemberExpression(node.property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  let computed = node.computed;\n  // @ts-expect-error todo(flow->ts) maybe instead of typeof check specific literal types?\n  if (isLiteral(node.property) && typeof node.property.value === \"number\") {\n    computed = true;\n  }\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  if (computed) {\n    this.token(\"[\");\n    this.print(node.property, node);\n    this.token(\"]\");\n  } else {\n    if (!node.optional) {\n      this.token(\".\");\n    }\n    this.print(node.property, node);\n  }\n}\n\nexport function OptionalCallExpression(\n  this: Printer,\n  node: t.OptionalCallExpression,\n) {\n  this.print(node.callee, node);\n\n  this.print(node.typeParameters, node); // TS\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  this.print(node.typeArguments, node); // Flow\n\n  this.token(\"(\");\n  this.printList(node.arguments, node);\n  this.token(\")\");\n}\n\nexport function CallExpression(this: Printer, node: t.CallExpression) {\n  this.print(node.callee, node);\n\n  this.print(node.typeArguments, node); // Flow\n  this.print(node.typeParameters, node); // TS\n  this.token(\"(\");\n  this.printList(node.arguments, node);\n  this.token(\")\");\n}\n\nexport function Import(this: Printer) {\n  this.word(\"import\");\n}\n\nexport function AwaitExpression(this: Printer, node: t.AwaitExpression) {\n  this.word(\"await\");\n\n  if (node.argument) {\n    this.space();\n    this.printTerminatorless(node.argument, node, false);\n  }\n}\n\nexport function YieldExpression(this: Printer, node: t.YieldExpression) {\n  this.word(\"yield\", true);\n\n  if (node.delegate) {\n    this.token(\"*\");\n    if (node.argument) {\n      this.space();\n      // line terminators are allowed after yield*\n      this.print(node.argument, node);\n    }\n  } else {\n    if (node.argument) {\n      this.space();\n      this.printTerminatorless(node.argument, node, false);\n    }\n  }\n}\n\nexport function EmptyStatement(this: Printer) {\n  this.semicolon(true /* force */);\n}\n\nexport function ExpressionStatement(\n  this: Printer,\n  node: t.ExpressionStatement,\n) {\n  this.print(node.expression, node);\n  this.semicolon();\n}\n\nexport function AssignmentPattern(this: Printer, node: t.AssignmentPattern) {\n  this.print(node.left, node);\n  // @ts-expect-error todo(flow->ts) property present on some of the types in union but not all\n  if (node.left.optional) this.token(\"?\");\n  // @ts-expect-error todo(flow->ts) property present on some of the types in union but not all\n  this.print(node.left.typeAnnotation, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right, node);\n}\n\nexport function AssignmentExpression(\n  this: Printer,\n  node: t.AssignmentExpression,\n  parent: t.Node,\n) {\n  // Somewhere inside a for statement `init` node but doesn't usually\n  // needs a paren except for `in` expressions: `for (a in b ? a : b;;)`\n  const parens =\n    this.inForStatementInitCounter &&\n    node.operator === \"in\" &&\n    !n.needsParens(node, parent);\n\n  if (parens) {\n    this.token(\"(\");\n  }\n\n  this.print(node.left, node);\n\n  this.space();\n  if (node.operator === \"in\" || node.operator === \"instanceof\") {\n    this.word(node.operator);\n  } else {\n    this.token(node.operator);\n  }\n  this.space();\n\n  this.print(node.right, node);\n\n  if (parens) {\n    this.token(\")\");\n  }\n}\n\nexport function BindExpression(this: Printer, node: t.BindExpression) {\n  this.print(node.object, node);\n  this.token(\"::\");\n  this.print(node.callee, node);\n}\n\nexport {\n  AssignmentExpression as BinaryExpression,\n  AssignmentExpression as LogicalExpression,\n};\n\nexport function MemberExpression(this: Printer, node: t.MemberExpression) {\n  this.print(node.object, node);\n\n  if (!node.computed && isMemberExpression(node.property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  let computed = node.computed;\n  // @ts-expect-error todo(flow->ts) maybe use specific literal types\n  if (isLiteral(node.property) && typeof node.property.value === \"number\") {\n    computed = true;\n  }\n\n  if (computed) {\n    this.token(\"[\");\n    this.print(node.property, node);\n    this.token(\"]\");\n  } else {\n    this.token(\".\");\n    this.print(node.property, node);\n  }\n}\n\nexport function MetaProperty(this: Printer, node: t.MetaProperty) {\n  this.print(node.meta, node);\n  this.token(\".\");\n  this.print(node.property, node);\n}\n\nexport function PrivateName(this: Printer, node: t.PrivateName) {\n  this.token(\"#\");\n  this.print(node.id, node);\n}\n\nexport function V8IntrinsicIdentifier(\n  this: Printer,\n  node: t.V8IntrinsicIdentifier,\n) {\n  this.token(\"%\");\n  this.word(node.name);\n}\n\nexport function ModuleExpression(this: Printer, node: t.ModuleExpression) {\n  this.word(\"module\", true);\n  this.space();\n  this.token(\"{\");\n  this.indent();\n  const { body } = node;\n  if (body.body.length || body.directives.length) {\n    this.newline();\n  }\n  this.print(body, node);\n  this.dedent();\n  this.sourceWithOffset(\"end\", node.loc, 0, -1);\n  this.rightBrace();\n}\n"],"mappings":"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"}
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
{"version":3,"names":["_t","require","n","isCallExpression","isLiteral","isMemberExpression","isNewExpression","UnaryExpression","node","operator","word","space","token","print","argument","DoExpression","async","body","ParenthesizedExpression","expression","rightParens","UpdateExpression","prefix","printTerminatorless","ConditionalExpression","test","consequent","alternate","NewExpression","parent","callee","format","minified","arguments","length","optional","typeArguments","typeParameters","printList","SequenceExpression","expressions","ThisExpression","Super","isDecoratorMemberExpression","type","computed","property","object","shouldParenthesizeDecoratorExpression","_shouldPrintDecoratorsBeforeExport","decoratorsBeforeExport","start","declaration","Decorator","newline","OptionalMemberExpression","TypeError","value","OptionalCallExpression","CallExpression","Import","AwaitExpression","YieldExpression","delegate","EmptyStatement","semicolon","ExpressionStatement","AssignmentPattern","left","typeAnnotation","right","AssignmentExpression","parens","inForStatementInitCounter","needsParens","BindExpression","MemberExpression","MetaProperty","meta","PrivateName","id","V8IntrinsicIdentifier","name","ModuleExpression","indent","directives","dedent","rightBrace"],"sources":["../../src/generators/expressions.ts"],"sourcesContent":["import type Printer from \"../printer.ts\";\nimport {\n  isCallExpression,\n  isLiteral,\n  isMemberExpression,\n  isNewExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport * as n from \"../node/index.ts\";\n\nexport function UnaryExpression(this: Printer, node: t.UnaryExpression) {\n  const { operator } = node;\n  if (\n    operator === \"void\" ||\n    operator === \"delete\" ||\n    operator === \"typeof\" ||\n    // throwExpressions\n    operator === \"throw\"\n  ) {\n    this.word(operator);\n    this.space();\n  } else {\n    this.token(operator);\n  }\n\n  this.print(node.argument, node);\n}\n\nexport function DoExpression(this: Printer, node: t.DoExpression) {\n  if (node.async) {\n    this.word(\"async\", true);\n    this.space();\n  }\n  this.word(\"do\");\n  this.space();\n  this.print(node.body, node);\n}\n\nexport function ParenthesizedExpression(\n  this: Printer,\n  node: t.ParenthesizedExpression,\n) {\n  this.token(\"(\");\n  this.print(node.expression, node);\n  this.rightParens(node);\n}\n\nexport function UpdateExpression(this: Printer, node: t.UpdateExpression) {\n  if (node.prefix) {\n    this.token(node.operator);\n    this.print(node.argument, node);\n  } else {\n    this.printTerminatorless(node.argument, node, true);\n    this.token(node.operator);\n  }\n}\n\nexport function ConditionalExpression(\n  this: Printer,\n  node: t.ConditionalExpression,\n) {\n  this.print(node.test, node);\n  this.space();\n  this.token(\"?\");\n  this.space();\n  this.print(node.consequent, node);\n  this.space();\n  this.token(\":\");\n  this.space();\n  this.print(node.alternate, node);\n}\n\nexport function NewExpression(\n  this: Printer,\n  node: t.NewExpression,\n  parent: t.Node,\n) {\n  this.word(\"new\");\n  this.space();\n  this.print(node.callee, node);\n  if (\n    this.format.minified &&\n    node.arguments.length === 0 &&\n    !node.optional &&\n    !isCallExpression(parent, { callee: node }) &&\n    !isMemberExpression(parent) &&\n    !isNewExpression(parent)\n  ) {\n    return;\n  }\n\n  this.print(node.typeArguments, node); // Flow\n  this.print(node.typeParameters, node); // TS\n\n  if (node.optional) {\n    // TODO: This can never happen\n    this.token(\"?.\");\n  }\n  this.token(\"(\");\n  this.printList(node.arguments, node);\n  this.rightParens(node);\n}\n\nexport function SequenceExpression(this: Printer, node: t.SequenceExpression) {\n  this.printList(node.expressions, node);\n}\n\nexport function ThisExpression(this: Printer) {\n  this.word(\"this\");\n}\n\nexport function Super(this: Printer) {\n  this.word(\"super\");\n}\n\nfunction isDecoratorMemberExpression(\n  node: t.Expression | t.Super | t.V8IntrinsicIdentifier,\n): boolean {\n  switch (node.type) {\n    case \"Identifier\":\n      return true;\n    case \"MemberExpression\":\n      return (\n        !node.computed &&\n        node.property.type === \"Identifier\" &&\n        isDecoratorMemberExpression(node.object)\n      );\n    default:\n      return false;\n  }\n}\nfunction shouldParenthesizeDecoratorExpression(\n  node: t.Expression | t.Super | t.V8IntrinsicIdentifier,\n) {\n  if (node.type === \"ParenthesizedExpression\") {\n    // We didn't check extra?.parenthesized here because we don't track decorators in needsParen\n    return false;\n  }\n  return !isDecoratorMemberExpression(\n    node.type === \"CallExpression\" ? node.callee : node,\n  );\n}\n\nexport function _shouldPrintDecoratorsBeforeExport(\n  this: Printer,\n  node: t.ExportDeclaration & { declaration: t.ClassDeclaration },\n) {\n  if (typeof this.format.decoratorsBeforeExport === \"boolean\") {\n    return this.format.decoratorsBeforeExport;\n  }\n  return (\n    typeof node.start === \"number\" && node.start === node.declaration.start\n  );\n}\n\nexport function Decorator(this: Printer, node: t.Decorator) {\n  this.token(\"@\");\n  const { expression } = node;\n  if (shouldParenthesizeDecoratorExpression(expression)) {\n    this.token(\"(\");\n    this.print(expression, node);\n    this.token(\")\");\n  } else {\n    this.print(expression, node);\n  }\n  this.newline();\n}\n\nexport function OptionalMemberExpression(\n  this: Printer,\n  node: t.OptionalMemberExpression,\n) {\n  let { computed } = node;\n  const { optional, property } = node;\n\n  this.print(node.object, node);\n\n  if (!computed && isMemberExpression(property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  // @ts-expect-error todo(flow->ts) maybe instead of typeof check specific literal types?\n  if (isLiteral(property) && typeof property.value === \"number\") {\n    computed = true;\n  }\n  if (optional) {\n    this.token(\"?.\");\n  }\n\n  if (computed) {\n    this.token(\"[\");\n    this.print(property, node);\n    this.token(\"]\");\n  } else {\n    if (!optional) {\n      this.token(\".\");\n    }\n    this.print(property, node);\n  }\n}\n\nexport function OptionalCallExpression(\n  this: Printer,\n  node: t.OptionalCallExpression,\n) {\n  this.print(node.callee, node);\n\n  this.print(node.typeParameters, node); // TS\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  this.print(node.typeArguments, node); // Flow\n\n  this.token(\"(\");\n  this.printList(node.arguments, node);\n  this.rightParens(node);\n}\n\nexport function CallExpression(this: Printer, node: t.CallExpression) {\n  this.print(node.callee, node);\n\n  this.print(node.typeArguments, node); // Flow\n  this.print(node.typeParameters, node); // TS\n  this.token(\"(\");\n  this.printList(node.arguments, node);\n  this.rightParens(node);\n}\n\nexport function Import(this: Printer) {\n  this.word(\"import\");\n}\n\nexport function AwaitExpression(this: Printer, node: t.AwaitExpression) {\n  this.word(\"await\");\n\n  if (node.argument) {\n    this.space();\n    this.printTerminatorless(node.argument, node, false);\n  }\n}\n\nexport function YieldExpression(this: Printer, node: t.YieldExpression) {\n  this.word(\"yield\", true);\n\n  if (node.delegate) {\n    this.token(\"*\");\n    if (node.argument) {\n      this.space();\n      // line terminators are allowed after yield*\n      this.print(node.argument, node);\n    }\n  } else {\n    if (node.argument) {\n      this.space();\n      this.printTerminatorless(node.argument, node, false);\n    }\n  }\n}\n\nexport function EmptyStatement(this: Printer) {\n  this.semicolon(true /* force */);\n}\n\nexport function ExpressionStatement(\n  this: Printer,\n  node: t.ExpressionStatement,\n) {\n  this.print(node.expression, node);\n  this.semicolon();\n}\n\nexport function AssignmentPattern(this: Printer, node: t.AssignmentPattern) {\n  this.print(node.left, node);\n  // @ts-expect-error todo(flow->ts) property present on some of the types in union but not all\n  if (node.left.optional) this.token(\"?\");\n  // @ts-expect-error todo(flow->ts) property present on some of the types in union but not all\n  this.print(node.left.typeAnnotation, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right, node);\n}\n\nexport function AssignmentExpression(\n  this: Printer,\n  node: t.AssignmentExpression,\n  parent: t.Node,\n) {\n  // Somewhere inside a for statement `init` node but doesn't usually\n  // needs a paren except for `in` expressions: `for (a in b ? a : b;;)`\n  const parens =\n    this.inForStatementInitCounter &&\n    node.operator === \"in\" &&\n    !n.needsParens(node, parent);\n\n  if (parens) {\n    this.token(\"(\");\n  }\n\n  this.print(node.left, node);\n\n  this.space();\n  if (node.operator === \"in\" || node.operator === \"instanceof\") {\n    this.word(node.operator);\n  } else {\n    this.token(node.operator);\n  }\n  this.space();\n\n  this.print(node.right, node);\n\n  if (parens) {\n    this.token(\")\");\n  }\n}\n\nexport function BindExpression(this: Printer, node: t.BindExpression) {\n  this.print(node.object, node);\n  this.token(\"::\");\n  this.print(node.callee, node);\n}\n\nexport {\n  AssignmentExpression as BinaryExpression,\n  AssignmentExpression as LogicalExpression,\n};\n\nexport function MemberExpression(this: Printer, node: t.MemberExpression) {\n  this.print(node.object, node);\n\n  if (!node.computed && isMemberExpression(node.property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  let computed = node.computed;\n  // @ts-expect-error todo(flow->ts) maybe use specific literal types\n  if (isLiteral(node.property) && typeof node.property.value === \"number\") {\n    computed = true;\n  }\n\n  if (computed) {\n    this.token(\"[\");\n    this.print(node.property, node);\n    this.token(\"]\");\n  } else {\n    this.token(\".\");\n    this.print(node.property, node);\n  }\n}\n\nexport function MetaProperty(this: Printer, node: t.MetaProperty) {\n  this.print(node.meta, node);\n  this.token(\".\");\n  this.print(node.property, node);\n}\n\nexport function PrivateName(this: Printer, node: t.PrivateName) {\n  this.token(\"#\");\n  this.print(node.id, node);\n}\n\nexport function V8IntrinsicIdentifier(\n  this: Printer,\n  node: t.V8IntrinsicIdentifier,\n) {\n  this.token(\"%\");\n  this.word(node.name);\n}\n\nexport function ModuleExpression(this: Printer, node: t.ModuleExpression) {\n  this.word(\"module\", true);\n  this.space();\n  this.token(\"{\");\n  this.indent();\n  const { body } = node;\n  if (body.body.length || body.directives.length) {\n    this.newline();\n  }\n  this.print(body, node);\n  this.dedent();\n  this.rightBrace(node);\n}\n"],"mappings":"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","ignoreList":[]}
>>>>>>> parent of 99ae58fb (IP)
