<<<<<<< HEAD
<<<<<<< HEAD
{"version":3,"names":["_template","require","_t","blockStatement","callExpression","functionExpression","isAssignmentPattern","isFunctionDeclaration","isRestElement","returnStatement","isCallExpression","memberExpression","identifier","thisExpression","isPattern","buildAnonymousExpressionWrapper","template","expression","buildNamedExpressionWrapper","buildDeclarationWrapper","statements","classOrObjectMethod","path","callId","ignoreFunctionLength","node","body","params","shouldForwardParams","some","p","param","push","scope","generateUidIdentifier","container","get","unwrapFunctionEnvironment","async","generator","plainFunction","inPath","noNewArrows","hadName","functionId","nodeParams","isArrowFunctionExpression","_path$arrowFunctionTo","arrowFunctionToExpression","isDeclaration","built","id","type","wrapperArgs","NAME","REF","name","FUNCTION","PARAMS","replaceWith","insertAfter","length","wrapFunction","isMethod","_path","_path$ensureFunctionN","ensureFunctionName","NodePath","prototype"],"sources":["../src/index.ts"],"sourcesContent":["import type { NodePath } from \"@babel/traverse\";\nimport template from \"@babel/template\";\nimport {\n  blockStatement,\n  callExpression,\n  functionExpression,\n  isAssignmentPattern,\n  isFunctionDeclaration,\n  isRestElement,\n  returnStatement,\n  isCallExpression,\n  memberExpression,\n  identifier,\n  thisExpression,\n  isPattern,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\ntype ExpressionWrapperBuilder<ExtraBody extends t.Node[]> = (\n  replacements?: Parameters<ReturnType<typeof template.expression>>[0],\n) => t.CallExpression & {\n  callee: t.FunctionExpression & {\n    body: {\n      body: [\n        t.VariableDeclaration & {\n          declarations: [\n            { init: t.FunctionExpression | t.ArrowFunctionExpression },\n          ];\n        },\n        ...ExtraBody,\n      ];\n    };\n  };\n};\n\nconst buildAnonymousExpressionWrapper = template.expression(`\n  (function () {\n    var REF = FUNCTION;\n    return function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    };\n  })()\n`) as ExpressionWrapperBuilder<\n  [t.ReturnStatement & { argument: t.FunctionExpression }]\n>;\n\nconst buildNamedExpressionWrapper = template.expression(`\n  (function () {\n    var REF = FUNCTION;\n    function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    }\n    return NAME;\n  })()\n`) as ExpressionWrapperBuilder<\n  [t.FunctionDeclaration, t.ReturnStatement & { argument: t.Identifier }]\n>;\n\nconst buildDeclarationWrapper = template.statements(`\n  function NAME(PARAMS) { return REF.apply(this, arguments); }\n  function REF() {\n    REF = FUNCTION;\n    return REF.apply(this, arguments);\n  }\n`);\n\nfunction classOrObjectMethod(\n  path: NodePath<t.ClassMethod | t.ClassPrivateMethod | t.ObjectMethod>,\n  callId: t.Expression,\n  ignoreFunctionLength: boolean,\n) {\n  const node = path.node;\n  const body = node.body;\n\n  let params: Array<t.Identifier | t.Pattern | t.RestElement> = [];\n\n  // Errors thrown during argument evaluation must reject the resulting promise\n  const shouldForwardParams = node.params.some(p => isPattern(p));\n\n  if (shouldForwardParams) {\n    params = node.params as typeof params;\n    node.params = [];\n    if (!ignoreFunctionLength) {\n      for (const param of params) {\n        if (isAssignmentPattern(param) || isRestElement(param)) {\n          break;\n        }\n        node.params.push(path.scope.generateUidIdentifier(\"x\"));\n      }\n    }\n  }\n\n  const container = functionExpression(\n    null,\n    params,\n    blockStatement(body.body),\n    true,\n  );\n\n  if (shouldForwardParams) {\n    // return asyncToGenerator(function*() { ... }).apply(this, arguments);\n    body.body = [\n      returnStatement(\n        callExpression(\n          memberExpression(\n            callExpression(callId, [container]),\n            identifier(\"apply\"),\n          ),\n          [thisExpression(), identifier(\"arguments\")],\n        ),\n      ),\n    ];\n\n    (\n      path.get(\"body.body.0.argument.callee.object.arguments.0\") as NodePath\n    ).unwrapFunctionEnvironment();\n  } else {\n    // return asyncToGenerator(function*() { ... })();\n    body.body = [\n      returnStatement(callExpression(callExpression(callId, [container]), [])),\n    ];\n\n    // Unwrap the wrapper IIFE's environment so super and this and such still work.\n    (\n      path.get(\"body.body.0.argument.callee.arguments.0\") as NodePath\n    ).unwrapFunctionEnvironment();\n  }\n\n  // Regardless of whether or not the wrapped function is a an async method\n  // or generator the outer function should not be\n  node.async = false;\n  node.generator = false;\n}\n\nfunction plainFunction(\n  inPath: NodePath<Exclude<t.Function, t.Method>>,\n  callId: t.Expression,\n  noNewArrows: boolean,\n  ignoreFunctionLength: boolean,\n  hadName: boolean,\n) {\n  let path: NodePath<\n    | t.FunctionDeclaration\n    | t.FunctionExpression\n    | t.CallExpression\n    | t.ArrowFunctionExpression\n  > = inPath;\n  let node;\n  let functionId = null;\n  const nodeParams = inPath.node.params;\n\n  if (path.isArrowFunctionExpression()) {\n    if (process.env.BABEL_8_BREAKING) {\n      path = path.arrowFunctionToExpression({ noNewArrows });\n    } else {\n      // arrowFunctionToExpression returns undefined in @babel/traverse < 7.18.10\n      path = path.arrowFunctionToExpression({ noNewArrows }) ?? path;\n    }\n    node = path.node as\n      | t.FunctionDeclaration\n      | t.FunctionExpression\n      | t.CallExpression;\n  } else {\n    node = path.node;\n  }\n\n  const isDeclaration = isFunctionDeclaration(node);\n\n  let built = node;\n  if (!isCallExpression(node)) {\n    functionId = node.id;\n    node.id = null;\n    node.type = \"FunctionExpression\";\n    built = callExpression(callId, [\n      node as Exclude<typeof node, t.FunctionDeclaration>,\n    ]);\n  }\n\n  const params: t.Identifier[] = [];\n  for (const param of nodeParams) {\n    if (isAssignmentPattern(param) || isRestElement(param)) {\n      break;\n    }\n    params.push(path.scope.generateUidIdentifier(\"x\"));\n  }\n\n  const wrapperArgs = {\n    NAME: functionId || null,\n    // TODO: Use `functionId` rather than `hadName` for the condition\n    REF: path.scope.generateUidIdentifier(hadName ? functionId.name : \"ref\"),\n    FUNCTION: built,\n    PARAMS: params,\n  };\n\n  if (isDeclaration) {\n    const container = buildDeclarationWrapper(wrapperArgs);\n    path.replaceWith(container[0]);\n    path.insertAfter(container[1]);\n  } else {\n    let container;\n\n    if (hadName) {\n      container = buildNamedExpressionWrapper(wrapperArgs);\n    } else {\n      container = buildAnonymousExpressionWrapper(wrapperArgs);\n    }\n\n    if (functionId || (!ignoreFunctionLength && params.length)) {\n      path.replaceWith(container);\n    } else {\n      // we can omit this wrapper as the conditions it protects for do not apply\n      path.replaceWith(built);\n    }\n  }\n}\n\nexport default function wrapFunction(\n  path: NodePath<t.Function>,\n  callId: t.Expression,\n  // TODO(Babel 8): Consider defaulting to false for spec compliance\n  noNewArrows: boolean = true,\n  ignoreFunctionLength: boolean = false,\n) {\n  if (path.isMethod()) {\n    classOrObjectMethod(path, callId, ignoreFunctionLength);\n  } else {\n    const hadName = \"id\" in path.node && !!path.node.id;\n    if (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n      // polyfill when being run by an older Babel version\n      path.ensureFunctionName ??=\n        // eslint-disable-next-line no-restricted-globals\n        require(\"@babel/traverse\").NodePath.prototype.ensureFunctionName;\n    }\n    // @ts-expect-error It is invalid to call this on an arrow expression,\n    // but we'll convert it to a function expression anyway.\n    path = path.ensureFunctionName(false);\n    plainFunction(\n      path as NodePath<Exclude<t.Function, t.Method>>,\n      callId,\n      noNewArrows,\n      ignoreFunctionLength,\n      hadName,\n    );\n  }\n}\n"],"mappings":"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","ignoreList":[]}
=======
{"version":3,"names":["blockStatement","callExpression","functionExpression","isAssignmentPattern","isFunctionDeclaration","isRestElement","returnStatement","isCallExpression","buildAnonymousExpressionWrapper","template","expression","buildNamedExpressionWrapper","buildDeclarationWrapper","statements","classOrObjectMethod","path","callId","node","body","container","async","generator","get","unwrapFunctionEnvironment","plainFunction","inPath","noNewArrows","ignoreFunctionLength","functionId","nodeParams","params","isArrowFunctionExpression","arrowFunctionToExpression","isDeclaration","built","id","type","param","push","scope","generateUidIdentifier","wrapperArgs","NAME","REF","name","FUNCTION","PARAMS","replaceWith","insertAfter","returnFn","callee","argument","nameFunction","parent","length","wrapFunction","isMethod"],"sources":["../src/index.ts"],"sourcesContent":["import type { NodePath } from \"@babel/traverse\";\nimport nameFunction from \"@babel/helper-function-name\";\nimport template from \"@babel/template\";\nimport {\n  blockStatement,\n  callExpression,\n  functionExpression,\n  isAssignmentPattern,\n  isFunctionDeclaration,\n  isRestElement,\n  returnStatement,\n  isCallExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\ntype ExpressionWrapperBuilder<ExtraBody extends t.Node[]> = (\n  replacements?: Parameters<ReturnType<typeof template.expression>>[0],\n) => t.CallExpression & {\n  callee: t.FunctionExpression & {\n    body: {\n      body: [\n        t.VariableDeclaration & {\n          declarations: [\n            { init: t.FunctionExpression | t.ArrowFunctionExpression },\n          ];\n        },\n        ...ExtraBody,\n      ];\n    };\n  };\n};\n\nconst buildAnonymousExpressionWrapper = template.expression(`\n  (function () {\n    var REF = FUNCTION;\n    return function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    };\n  })()\n`) as ExpressionWrapperBuilder<\n  [t.ReturnStatement & { argument: t.FunctionExpression }]\n>;\n\nconst buildNamedExpressionWrapper = template.expression(`\n  (function () {\n    var REF = FUNCTION;\n    function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    }\n    return NAME;\n  })()\n`) as ExpressionWrapperBuilder<\n  [t.FunctionDeclaration, t.ReturnStatement & { argument: t.Identifier }]\n>;\n\nconst buildDeclarationWrapper = template.statements(`\n  function NAME(PARAMS) { return REF.apply(this, arguments); }\n  function REF() {\n    REF = FUNCTION;\n    return REF.apply(this, arguments);\n  }\n`);\n\nfunction classOrObjectMethod(\n  path: NodePath<t.ClassMethod | t.ClassPrivateMethod | t.ObjectMethod>,\n  callId: t.Expression,\n) {\n  const node = path.node;\n  const body = node.body;\n\n  const container = functionExpression(\n    null,\n    [],\n    blockStatement(body.body),\n    true,\n  );\n  body.body = [\n    returnStatement(callExpression(callExpression(callId, [container]), [])),\n  ];\n\n  // Regardless of whether or not the wrapped function is a an async method\n  // or generator the outer function should not be\n  node.async = false;\n  node.generator = false;\n\n  // Unwrap the wrapper IIFE's environment so super and this and such still work.\n  (\n    path.get(\"body.body.0.argument.callee.arguments.0\") as NodePath\n  ).unwrapFunctionEnvironment();\n}\n\nfunction plainFunction(\n  inPath: NodePath<Exclude<t.Function, t.Method>>,\n  callId: t.Expression,\n  noNewArrows: boolean,\n  ignoreFunctionLength: boolean,\n) {\n  let path: NodePath<\n    | t.FunctionDeclaration\n    | t.FunctionExpression\n    | t.CallExpression\n    | t.ArrowFunctionExpression\n  > = inPath;\n  let node;\n  let functionId = null;\n  const nodeParams = inPath.node.params;\n\n  if (path.isArrowFunctionExpression()) {\n    if (process.env.BABEL_8_BREAKING) {\n      path = path.arrowFunctionToExpression({ noNewArrows });\n    } else {\n      // arrowFunctionToExpression returns undefined in @babel/traverse < 7.18.10\n      path = path.arrowFunctionToExpression({ noNewArrows }) ?? path;\n    }\n    node = path.node as\n      | t.FunctionDeclaration\n      | t.FunctionExpression\n      | t.CallExpression;\n  } else {\n    node = path.node as t.FunctionDeclaration | t.FunctionExpression;\n  }\n\n  const isDeclaration = isFunctionDeclaration(node);\n\n  let built = node;\n  if (!isCallExpression(node)) {\n    functionId = node.id;\n    node.id = null;\n    node.type = \"FunctionExpression\";\n    built = callExpression(callId, [\n      node as Exclude<typeof node, t.FunctionDeclaration>,\n    ]);\n  }\n\n  const params: t.Identifier[] = [];\n  for (const param of nodeParams) {\n    if (isAssignmentPattern(param) || isRestElement(param)) {\n      break;\n    }\n    params.push(path.scope.generateUidIdentifier(\"x\"));\n  }\n\n  const wrapperArgs = {\n    NAME: functionId || null,\n    REF: path.scope.generateUidIdentifier(functionId ? functionId.name : \"ref\"),\n    FUNCTION: built,\n    PARAMS: params,\n  };\n\n  if (isDeclaration) {\n    const container = buildDeclarationWrapper(wrapperArgs);\n    path.replaceWith(container[0]);\n    path.insertAfter(container[1]);\n  } else {\n    let container;\n\n    if (functionId) {\n      container = buildNamedExpressionWrapper(wrapperArgs);\n    } else {\n      container = buildAnonymousExpressionWrapper(wrapperArgs);\n\n      const returnFn = container.callee.body.body[1].argument;\n      nameFunction({\n        node: returnFn,\n        parent: (path as NodePath<t.FunctionExpression>).parent,\n        scope: path.scope,\n      });\n      functionId = returnFn.id;\n    }\n\n    if (functionId || (!ignoreFunctionLength && params.length)) {\n      path.replaceWith(container);\n    } else {\n      // we can omit this wrapper as the conditions it protects for do not apply\n      path.replaceWith(built);\n    }\n  }\n}\n\nexport default function wrapFunction(\n  path: NodePath<t.Function>,\n  callId: t.Expression,\n  // TODO(Babel 8): Consider defaulting to false for spec compliancy\n  noNewArrows: boolean = true,\n  ignoreFunctionLength: boolean = false,\n) {\n  if (path.isMethod()) {\n    classOrObjectMethod(path, callId);\n  } else {\n    plainFunction(\n      path as NodePath<Exclude<t.Function, t.Method>>,\n      callId,\n      noNewArrows,\n      ignoreFunctionLength,\n    );\n  }\n}\n"],"mappings":"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"}
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
{"version":3,"names":["_helperFunctionName","require","_template","_t","blockStatement","callExpression","functionExpression","isAssignmentPattern","isFunctionDeclaration","isRestElement","returnStatement","isCallExpression","buildAnonymousExpressionWrapper","template","expression","buildNamedExpressionWrapper","buildDeclarationWrapper","statements","classOrObjectMethod","path","callId","node","body","container","async","generator","get","unwrapFunctionEnvironment","plainFunction","inPath","noNewArrows","ignoreFunctionLength","functionId","nodeParams","params","isArrowFunctionExpression","_path$arrowFunctionTo","arrowFunctionToExpression","isDeclaration","built","id","type","param","push","scope","generateUidIdentifier","wrapperArgs","NAME","REF","name","FUNCTION","PARAMS","replaceWith","insertAfter","returnFn","callee","argument","nameFunction","parent","length","wrapFunction","isMethod"],"sources":["../src/index.ts"],"sourcesContent":["import type { NodePath } from \"@babel/traverse\";\nimport nameFunction from \"@babel/helper-function-name\";\nimport template from \"@babel/template\";\nimport {\n  blockStatement,\n  callExpression,\n  functionExpression,\n  isAssignmentPattern,\n  isFunctionDeclaration,\n  isRestElement,\n  returnStatement,\n  isCallExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\n\ntype ExpressionWrapperBuilder<ExtraBody extends t.Node[]> = (\n  replacements?: Parameters<ReturnType<typeof template.expression>>[0],\n) => t.CallExpression & {\n  callee: t.FunctionExpression & {\n    body: {\n      body: [\n        t.VariableDeclaration & {\n          declarations: [\n            { init: t.FunctionExpression | t.ArrowFunctionExpression },\n          ];\n        },\n        ...ExtraBody,\n      ];\n    };\n  };\n};\n\nconst buildAnonymousExpressionWrapper = template.expression(`\n  (function () {\n    var REF = FUNCTION;\n    return function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    };\n  })()\n`) as ExpressionWrapperBuilder<\n  [t.ReturnStatement & { argument: t.FunctionExpression }]\n>;\n\nconst buildNamedExpressionWrapper = template.expression(`\n  (function () {\n    var REF = FUNCTION;\n    function NAME(PARAMS) {\n      return REF.apply(this, arguments);\n    }\n    return NAME;\n  })()\n`) as ExpressionWrapperBuilder<\n  [t.FunctionDeclaration, t.ReturnStatement & { argument: t.Identifier }]\n>;\n\nconst buildDeclarationWrapper = template.statements(`\n  function NAME(PARAMS) { return REF.apply(this, arguments); }\n  function REF() {\n    REF = FUNCTION;\n    return REF.apply(this, arguments);\n  }\n`);\n\nfunction classOrObjectMethod(\n  path: NodePath<t.ClassMethod | t.ClassPrivateMethod | t.ObjectMethod>,\n  callId: t.Expression,\n) {\n  const node = path.node;\n  const body = node.body;\n\n  const container = functionExpression(\n    null,\n    [],\n    blockStatement(body.body),\n    true,\n  );\n  body.body = [\n    returnStatement(callExpression(callExpression(callId, [container]), [])),\n  ];\n\n  // Regardless of whether or not the wrapped function is a an async method\n  // or generator the outer function should not be\n  node.async = false;\n  node.generator = false;\n\n  // Unwrap the wrapper IIFE's environment so super and this and such still work.\n  (\n    path.get(\"body.body.0.argument.callee.arguments.0\") as NodePath\n  ).unwrapFunctionEnvironment();\n}\n\nfunction plainFunction(\n  inPath: NodePath<Exclude<t.Function, t.Method>>,\n  callId: t.Expression,\n  noNewArrows: boolean,\n  ignoreFunctionLength: boolean,\n) {\n  let path: NodePath<\n    | t.FunctionDeclaration\n    | t.FunctionExpression\n    | t.CallExpression\n    | t.ArrowFunctionExpression\n  > = inPath;\n  let node;\n  let functionId = null;\n  const nodeParams = inPath.node.params;\n\n  if (path.isArrowFunctionExpression()) {\n    if (process.env.BABEL_8_BREAKING) {\n      path = path.arrowFunctionToExpression({ noNewArrows });\n    } else {\n      // arrowFunctionToExpression returns undefined in @babel/traverse < 7.18.10\n      path = path.arrowFunctionToExpression({ noNewArrows }) ?? path;\n    }\n    node = path.node as\n      | t.FunctionDeclaration\n      | t.FunctionExpression\n      | t.CallExpression;\n  } else {\n    node = path.node as t.FunctionDeclaration | t.FunctionExpression;\n  }\n\n  const isDeclaration = isFunctionDeclaration(node);\n\n  let built = node;\n  if (!isCallExpression(node)) {\n    functionId = node.id;\n    node.id = null;\n    node.type = \"FunctionExpression\";\n    built = callExpression(callId, [\n      node as Exclude<typeof node, t.FunctionDeclaration>,\n    ]);\n  }\n\n  const params: t.Identifier[] = [];\n  for (const param of nodeParams) {\n    if (isAssignmentPattern(param) || isRestElement(param)) {\n      break;\n    }\n    params.push(path.scope.generateUidIdentifier(\"x\"));\n  }\n\n  const wrapperArgs = {\n    NAME: functionId || null,\n    REF: path.scope.generateUidIdentifier(functionId ? functionId.name : \"ref\"),\n    FUNCTION: built,\n    PARAMS: params,\n  };\n\n  if (isDeclaration) {\n    const container = buildDeclarationWrapper(wrapperArgs);\n    path.replaceWith(container[0]);\n    path.insertAfter(container[1]);\n  } else {\n    let container;\n\n    if (functionId) {\n      container = buildNamedExpressionWrapper(wrapperArgs);\n    } else {\n      container = buildAnonymousExpressionWrapper(wrapperArgs);\n\n      const returnFn = container.callee.body.body[1].argument;\n      nameFunction({\n        node: returnFn,\n        parent: (path as NodePath<t.FunctionExpression>).parent,\n        scope: path.scope,\n      });\n      functionId = returnFn.id;\n    }\n\n    if (functionId || (!ignoreFunctionLength && params.length)) {\n      path.replaceWith(container);\n    } else {\n      // we can omit this wrapper as the conditions it protects for do not apply\n      path.replaceWith(built);\n    }\n  }\n}\n\nexport default function wrapFunction(\n  path: NodePath<t.Function>,\n  callId: t.Expression,\n  // TODO(Babel 8): Consider defaulting to false for spec compliance\n  noNewArrows: boolean = true,\n  ignoreFunctionLength: boolean = false,\n) {\n  if (path.isMethod()) {\n    classOrObjectMethod(path, callId);\n  } else {\n    plainFunction(\n      path as NodePath<Exclude<t.Function, t.Method>>,\n      callId,\n      noNewArrows,\n      ignoreFunctionLength,\n    );\n  }\n}\n"],"mappings":"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"}
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)
