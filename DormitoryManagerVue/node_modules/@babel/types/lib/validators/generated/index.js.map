<<<<<<< HEAD
{"version":3,"names":["_shallowEqual","require","_deprecationWarning","isArrayExpression","node","opts","type","shallowEqual","isAssignmentExpression","isBinaryExpression","isInterpreterDirective","isDirective","isDirectiveLiteral","isBlockStatement","isBreakStatement","isCallExpression","isCatchClause","isConditionalExpression","isContinueStatement","isDebuggerStatement","isDoWhileStatement","isEmptyStatement","isExpressionStatement","isFile","isForInStatement","isForStatement","isFunctionDeclaration","isFunctionExpression","isIdentifier","isIfStatement","isLabeledStatement","isStringLiteral","isNumericLiteral","isNullLiteral","isBooleanLiteral","isRegExpLiteral","isLogicalExpression","isMemberExpression","isNewExpression","isProgram","isObjectExpression","isObjectMethod","isObjectProperty","isRestElement","isReturnStatement","isSequenceExpression","isParenthesizedExpression","isSwitchCase","isSwitchStatement","isThisExpression","isThrowStatement","isTryStatement","isUnaryExpression","isUpdateExpression","isVariableDeclaration","isVariableDeclarator","isWhileStatement","isWithStatement","isAssignmentPattern","isArrayPattern","isArrowFunctionExpression","isClassBody","isClassExpression","isClassDeclaration","isExportAllDeclaration","isExportDefaultDeclaration","isExportNamedDeclaration","isExportSpecifier","isForOfStatement","isImportDeclaration","isImportDefaultSpecifier","isImportNamespaceSpecifier","isImportSpecifier","isImportExpression","isMetaProperty","isClassMethod","isObjectPattern","isSpreadElement","isSuper","isTaggedTemplateExpression","isTemplateElement","isTemplateLiteral","isYieldExpression","isAwaitExpression","isImport","isBigIntLiteral","isExportNamespaceSpecifier","isOptionalMemberExpression","isOptionalCallExpression","isClassProperty","isClassAccessorProperty","isClassPrivateProperty","isClassPrivateMethod","isPrivateName","isStaticBlock","isImportAttribute","isAnyTypeAnnotation","isArrayTypeAnnotation","isBooleanTypeAnnotation","isBooleanLiteralTypeAnnotation","isNullLiteralTypeAnnotation","isClassImplements","isDeclareClass","isDeclareFunction","isDeclareInterface","isDeclareModule","isDeclareModuleExports","isDeclareTypeAlias","isDeclareOpaqueType","isDeclareVariable","isDeclareExportDeclaration","isDeclareExportAllDeclaration","isDeclaredPredicate","isExistsTypeAnnotation","isFunctionTypeAnnotation","isFunctionTypeParam","isGenericTypeAnnotation","isInferredPredicate","isInterfaceExtends","isInterfaceDeclaration","isInterfaceTypeAnnotation","isIntersectionTypeAnnotation","isMixedTypeAnnotation","isEmptyTypeAnnotation","isNullableTypeAnnotation","isNumberLiteralTypeAnnotation","isNumberTypeAnnotation","isObjectTypeAnnotation","isObjectTypeInternalSlot","isObjectTypeCallProperty","isObjectTypeIndexer","isObjectTypeProperty","isObjectTypeSpreadProperty","isOpaqueType","isQualifiedTypeIdentifier","isStringLiteralTypeAnnotation","isStringTypeAnnotation","isSymbolTypeAnnotation","isThisTypeAnnotation","isTupleTypeAnnotation","isTypeofTypeAnnotation","isTypeAlias","isTypeAnnotation","isTypeCastExpression","isTypeParameter","isTypeParameterDeclaration","isTypeParameterInstantiation","isUnionTypeAnnotation","isVariance","isVoidTypeAnnotation","isEnumDeclaration","isEnumBooleanBody","isEnumNumberBody","isEnumStringBody","isEnumSymbolBody","isEnumBooleanMember","isEnumNumberMember","isEnumStringMember","isEnumDefaultedMember","isIndexedAccessType","isOptionalIndexedAccessType","isJSXAttribute","isJSXClosingElement","isJSXElement","isJSXEmptyExpression","isJSXExpressionContainer","isJSXSpreadChild","isJSXIdentifier","isJSXMemberExpression","isJSXNamespacedName","isJSXOpeningElement","isJSXSpreadAttribute","isJSXText","isJSXFragment","isJSXOpeningFragment","isJSXClosingFragment","isNoop","isPlaceholder","isV8IntrinsicIdentifier","isArgumentPlaceholder","isBindExpression","isDecorator","isDoExpression","isExportDefaultSpecifier","isRecordExpression","isTupleExpression","isDecimalLiteral","isModuleExpression","isTopicReference","isPipelineTopicExpression","isPipelineBareFunction","isPipelinePrimaryTopicReference","isVoidPattern","isTSParameterProperty","isTSDeclareFunction","isTSDeclareMethod","isTSQualifiedName","isTSCallSignatureDeclaration","isTSConstructSignatureDeclaration","isTSPropertySignature","isTSMethodSignature","isTSIndexSignature","isTSAnyKeyword","isTSBooleanKeyword","isTSBigIntKeyword","isTSIntrinsicKeyword","isTSNeverKeyword","isTSNullKeyword","isTSNumberKeyword","isTSObjectKeyword","isTSStringKeyword","isTSSymbolKeyword","isTSUndefinedKeyword","isTSUnknownKeyword","isTSVoidKeyword","isTSThisType","isTSFunctionType","isTSConstructorType","isTSTypeReference","isTSTypePredicate","isTSTypeQuery","isTSTypeLiteral","isTSArrayType","isTSTupleType","isTSOptionalType","isTSRestType","isTSNamedTupleMember","isTSUnionType","isTSIntersectionType","isTSConditionalType","isTSInferType","isTSParenthesizedType","isTSTypeOperator","isTSIndexedAccessType","isTSMappedType","isTSTemplateLiteralType","isTSLiteralType","isTSExpressionWithTypeArguments","isTSInterfaceDeclaration","isTSInterfaceBody","isTSTypeAliasDeclaration","isTSInstantiationExpression","isTSAsExpression","isTSSatisfiesExpression","isTSTypeAssertion","isTSEnumBody","isTSEnumDeclaration","isTSEnumMember","isTSModuleDeclaration","isTSModuleBlock","isTSImportType","isTSImportEqualsDeclaration","isTSExternalModuleReference","isTSNonNullExpression","isTSExportAssignment","isTSNamespaceExportDeclaration","isTSTypeAnnotation","isTSTypeParameterInstantiation","isTSTypeParameterDeclaration","isTSTypeParameter","isStandardized","expectedNode","isExpression","isBinary","isScopable","isBlockParent","isBlock","isStatement","isTerminatorless","isCompletionStatement","isConditional","isLoop","isWhile","isExpressionWrapper","isFor","isForXStatement","isFunction","isFunctionParent","isPureish","isDeclaration","isFunctionParameter","isPatternLike","isLVal","isTSEntityName","isLiteral","isImmutable","isUserWhitespacable","isMethod","isObjectMember","isProperty","isUnaryLike","isPattern","isClass","isImportOrExportDeclaration","isExportDeclaration","isModuleSpecifier","isAccessor","isPrivate","isFlow","isFlowType","isFlowBaseAnnotation","isFlowDeclaration","isFlowPredicate","isEnumBody","isEnumMember","isJSX","isMiscellaneous","isTypeScript","isTSTypeElement","isTSType","isTSBaseType","isNumberLiteral","deprecationWarning","isRegexLiteral","isRestProperty","isSpreadProperty","isModuleDeclaration"],"sources":["../../../src/validators/generated/index.ts"],"sourcesContent":["/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\n\n/* eslint-disable no-fallthrough */\n\nimport shallowEqual from \"../../utils/shallowEqual.ts\";\nimport type * as t from \"../../index.ts\";\nimport deprecationWarning from \"../../utils/deprecationWarning.ts\";\n\ntype Options<Obj> = Partial<{\n  [Prop in Exclude<keyof Obj, \"type\">]: Obj[Prop] extends t.Node\n    ? t.Node\n    : Obj[Prop] extends t.Node[]\n      ? t.Node[]\n      : Obj[Prop];\n}>;\n\nexport function isArrayExpression(\n  node: t.Node | null | undefined,\n): node is t.ArrayExpression;\nexport function isArrayExpression<Opts extends Options<t.ArrayExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ArrayExpression & Opts;\nexport function isArrayExpression<Opts extends Options<t.ArrayExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ArrayExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isAssignmentExpression(\n  node: t.Node | null | undefined,\n): node is t.AssignmentExpression;\nexport function isAssignmentExpression<\n  Opts extends Options<t.AssignmentExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.AssignmentExpression & Opts;\nexport function isAssignmentExpression<\n  Opts extends Options<t.AssignmentExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"AssignmentExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBinaryExpression(\n  node: t.Node | null | undefined,\n): node is t.BinaryExpression;\nexport function isBinaryExpression<Opts extends Options<t.BinaryExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BinaryExpression & Opts;\nexport function isBinaryExpression<Opts extends Options<t.BinaryExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BinaryExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isInterpreterDirective(\n  node: t.Node | null | undefined,\n): node is t.InterpreterDirective;\nexport function isInterpreterDirective<\n  Opts extends Options<t.InterpreterDirective>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.InterpreterDirective & Opts;\nexport function isInterpreterDirective<\n  Opts extends Options<t.InterpreterDirective>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"InterpreterDirective\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDirective(\n  node: t.Node | null | undefined,\n): node is t.Directive;\nexport function isDirective<Opts extends Options<t.Directive>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Directive & Opts;\nexport function isDirective<Opts extends Options<t.Directive>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Directive\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDirectiveLiteral(\n  node: t.Node | null | undefined,\n): node is t.DirectiveLiteral;\nexport function isDirectiveLiteral<Opts extends Options<t.DirectiveLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DirectiveLiteral & Opts;\nexport function isDirectiveLiteral<Opts extends Options<t.DirectiveLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DirectiveLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBlockStatement(\n  node: t.Node | null | undefined,\n): node is t.BlockStatement;\nexport function isBlockStatement<Opts extends Options<t.BlockStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BlockStatement & Opts;\nexport function isBlockStatement<Opts extends Options<t.BlockStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BlockStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBreakStatement(\n  node: t.Node | null | undefined,\n): node is t.BreakStatement;\nexport function isBreakStatement<Opts extends Options<t.BreakStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BreakStatement & Opts;\nexport function isBreakStatement<Opts extends Options<t.BreakStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BreakStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isCallExpression(\n  node: t.Node | null | undefined,\n): node is t.CallExpression;\nexport function isCallExpression<Opts extends Options<t.CallExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.CallExpression & Opts;\nexport function isCallExpression<Opts extends Options<t.CallExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"CallExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isCatchClause(\n  node: t.Node | null | undefined,\n): node is t.CatchClause;\nexport function isCatchClause<Opts extends Options<t.CatchClause>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.CatchClause & Opts;\nexport function isCatchClause<Opts extends Options<t.CatchClause>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"CatchClause\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isConditionalExpression(\n  node: t.Node | null | undefined,\n): node is t.ConditionalExpression;\nexport function isConditionalExpression<\n  Opts extends Options<t.ConditionalExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ConditionalExpression & Opts;\nexport function isConditionalExpression<\n  Opts extends Options<t.ConditionalExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ConditionalExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isContinueStatement(\n  node: t.Node | null | undefined,\n): node is t.ContinueStatement;\nexport function isContinueStatement<Opts extends Options<t.ContinueStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ContinueStatement & Opts;\nexport function isContinueStatement<Opts extends Options<t.ContinueStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ContinueStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDebuggerStatement(\n  node: t.Node | null | undefined,\n): node is t.DebuggerStatement;\nexport function isDebuggerStatement<Opts extends Options<t.DebuggerStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DebuggerStatement & Opts;\nexport function isDebuggerStatement<Opts extends Options<t.DebuggerStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DebuggerStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDoWhileStatement(\n  node: t.Node | null | undefined,\n): node is t.DoWhileStatement;\nexport function isDoWhileStatement<Opts extends Options<t.DoWhileStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DoWhileStatement & Opts;\nexport function isDoWhileStatement<Opts extends Options<t.DoWhileStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DoWhileStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEmptyStatement(\n  node: t.Node | null | undefined,\n): node is t.EmptyStatement;\nexport function isEmptyStatement<Opts extends Options<t.EmptyStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EmptyStatement & Opts;\nexport function isEmptyStatement<Opts extends Options<t.EmptyStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EmptyStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExpressionStatement(\n  node: t.Node | null | undefined,\n): node is t.ExpressionStatement;\nexport function isExpressionStatement<\n  Opts extends Options<t.ExpressionStatement>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExpressionStatement & Opts;\nexport function isExpressionStatement<\n  Opts extends Options<t.ExpressionStatement>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExpressionStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFile(node: t.Node | null | undefined): node is t.File;\nexport function isFile<Opts extends Options<t.File>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.File & Opts;\nexport function isFile<Opts extends Options<t.File>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"File\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isForInStatement(\n  node: t.Node | null | undefined,\n): node is t.ForInStatement;\nexport function isForInStatement<Opts extends Options<t.ForInStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ForInStatement & Opts;\nexport function isForInStatement<Opts extends Options<t.ForInStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ForInStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isForStatement(\n  node: t.Node | null | undefined,\n): node is t.ForStatement;\nexport function isForStatement<Opts extends Options<t.ForStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ForStatement & Opts;\nexport function isForStatement<Opts extends Options<t.ForStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ForStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionDeclaration(\n  node: t.Node | null | undefined,\n): node is t.FunctionDeclaration;\nexport function isFunctionDeclaration<\n  Opts extends Options<t.FunctionDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FunctionDeclaration & Opts;\nexport function isFunctionDeclaration<\n  Opts extends Options<t.FunctionDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"FunctionDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionExpression(\n  node: t.Node | null | undefined,\n): node is t.FunctionExpression;\nexport function isFunctionExpression<\n  Opts extends Options<t.FunctionExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FunctionExpression & Opts;\nexport function isFunctionExpression<\n  Opts extends Options<t.FunctionExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"FunctionExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isIdentifier(\n  node: t.Node | null | undefined,\n): node is t.Identifier;\nexport function isIdentifier<Opts extends Options<t.Identifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Identifier & Opts;\nexport function isIdentifier<Opts extends Options<t.Identifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Identifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isIfStatement(\n  node: t.Node | null | undefined,\n): node is t.IfStatement;\nexport function isIfStatement<Opts extends Options<t.IfStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.IfStatement & Opts;\nexport function isIfStatement<Opts extends Options<t.IfStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"IfStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isLabeledStatement(\n  node: t.Node | null | undefined,\n): node is t.LabeledStatement;\nexport function isLabeledStatement<Opts extends Options<t.LabeledStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.LabeledStatement & Opts;\nexport function isLabeledStatement<Opts extends Options<t.LabeledStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"LabeledStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStringLiteral(\n  node: t.Node | null | undefined,\n): node is t.StringLiteral;\nexport function isStringLiteral<Opts extends Options<t.StringLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.StringLiteral & Opts;\nexport function isStringLiteral<Opts extends Options<t.StringLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"StringLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNumericLiteral(\n  node: t.Node | null | undefined,\n): node is t.NumericLiteral;\nexport function isNumericLiteral<Opts extends Options<t.NumericLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.NumericLiteral & Opts;\nexport function isNumericLiteral<Opts extends Options<t.NumericLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"NumericLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNullLiteral(\n  node: t.Node | null | undefined,\n): node is t.NullLiteral;\nexport function isNullLiteral<Opts extends Options<t.NullLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.NullLiteral & Opts;\nexport function isNullLiteral<Opts extends Options<t.NullLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"NullLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBooleanLiteral(\n  node: t.Node | null | undefined,\n): node is t.BooleanLiteral;\nexport function isBooleanLiteral<Opts extends Options<t.BooleanLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BooleanLiteral & Opts;\nexport function isBooleanLiteral<Opts extends Options<t.BooleanLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BooleanLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isRegExpLiteral(\n  node: t.Node | null | undefined,\n): node is t.RegExpLiteral;\nexport function isRegExpLiteral<Opts extends Options<t.RegExpLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.RegExpLiteral & Opts;\nexport function isRegExpLiteral<Opts extends Options<t.RegExpLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"RegExpLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isLogicalExpression(\n  node: t.Node | null | undefined,\n): node is t.LogicalExpression;\nexport function isLogicalExpression<Opts extends Options<t.LogicalExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.LogicalExpression & Opts;\nexport function isLogicalExpression<Opts extends Options<t.LogicalExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"LogicalExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isMemberExpression(\n  node: t.Node | null | undefined,\n): node is t.MemberExpression;\nexport function isMemberExpression<Opts extends Options<t.MemberExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.MemberExpression & Opts;\nexport function isMemberExpression<Opts extends Options<t.MemberExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"MemberExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNewExpression(\n  node: t.Node | null | undefined,\n): node is t.NewExpression;\nexport function isNewExpression<Opts extends Options<t.NewExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.NewExpression & Opts;\nexport function isNewExpression<Opts extends Options<t.NewExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"NewExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isProgram(node: t.Node | null | undefined): node is t.Program;\nexport function isProgram<Opts extends Options<t.Program>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Program & Opts;\nexport function isProgram<Opts extends Options<t.Program>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Program\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectExpression(\n  node: t.Node | null | undefined,\n): node is t.ObjectExpression;\nexport function isObjectExpression<Opts extends Options<t.ObjectExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectExpression & Opts;\nexport function isObjectExpression<Opts extends Options<t.ObjectExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectMethod(\n  node: t.Node | null | undefined,\n): node is t.ObjectMethod;\nexport function isObjectMethod<Opts extends Options<t.ObjectMethod>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectMethod & Opts;\nexport function isObjectMethod<Opts extends Options<t.ObjectMethod>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectMethod\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectProperty(\n  node: t.Node | null | undefined,\n): node is t.ObjectProperty;\nexport function isObjectProperty<Opts extends Options<t.ObjectProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectProperty & Opts;\nexport function isObjectProperty<Opts extends Options<t.ObjectProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isRestElement(\n  node: t.Node | null | undefined,\n): node is t.RestElement;\nexport function isRestElement<Opts extends Options<t.RestElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.RestElement & Opts;\nexport function isRestElement<Opts extends Options<t.RestElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"RestElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isReturnStatement(\n  node: t.Node | null | undefined,\n): node is t.ReturnStatement;\nexport function isReturnStatement<Opts extends Options<t.ReturnStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ReturnStatement & Opts;\nexport function isReturnStatement<Opts extends Options<t.ReturnStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ReturnStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSequenceExpression(\n  node: t.Node | null | undefined,\n): node is t.SequenceExpression;\nexport function isSequenceExpression<\n  Opts extends Options<t.SequenceExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.SequenceExpression & Opts;\nexport function isSequenceExpression<\n  Opts extends Options<t.SequenceExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"SequenceExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isParenthesizedExpression(\n  node: t.Node | null | undefined,\n): node is t.ParenthesizedExpression;\nexport function isParenthesizedExpression<\n  Opts extends Options<t.ParenthesizedExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ParenthesizedExpression & Opts;\nexport function isParenthesizedExpression<\n  Opts extends Options<t.ParenthesizedExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ParenthesizedExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSwitchCase(\n  node: t.Node | null | undefined,\n): node is t.SwitchCase;\nexport function isSwitchCase<Opts extends Options<t.SwitchCase>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.SwitchCase & Opts;\nexport function isSwitchCase<Opts extends Options<t.SwitchCase>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"SwitchCase\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSwitchStatement(\n  node: t.Node | null | undefined,\n): node is t.SwitchStatement;\nexport function isSwitchStatement<Opts extends Options<t.SwitchStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.SwitchStatement & Opts;\nexport function isSwitchStatement<Opts extends Options<t.SwitchStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"SwitchStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isThisExpression(\n  node: t.Node | null | undefined,\n): node is t.ThisExpression;\nexport function isThisExpression<Opts extends Options<t.ThisExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ThisExpression & Opts;\nexport function isThisExpression<Opts extends Options<t.ThisExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ThisExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isThrowStatement(\n  node: t.Node | null | undefined,\n): node is t.ThrowStatement;\nexport function isThrowStatement<Opts extends Options<t.ThrowStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ThrowStatement & Opts;\nexport function isThrowStatement<Opts extends Options<t.ThrowStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ThrowStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTryStatement(\n  node: t.Node | null | undefined,\n): node is t.TryStatement;\nexport function isTryStatement<Opts extends Options<t.TryStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TryStatement & Opts;\nexport function isTryStatement<Opts extends Options<t.TryStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TryStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isUnaryExpression(\n  node: t.Node | null | undefined,\n): node is t.UnaryExpression;\nexport function isUnaryExpression<Opts extends Options<t.UnaryExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.UnaryExpression & Opts;\nexport function isUnaryExpression<Opts extends Options<t.UnaryExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"UnaryExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isUpdateExpression(\n  node: t.Node | null | undefined,\n): node is t.UpdateExpression;\nexport function isUpdateExpression<Opts extends Options<t.UpdateExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.UpdateExpression & Opts;\nexport function isUpdateExpression<Opts extends Options<t.UpdateExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"UpdateExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isVariableDeclaration(\n  node: t.Node | null | undefined,\n): node is t.VariableDeclaration;\nexport function isVariableDeclaration<\n  Opts extends Options<t.VariableDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.VariableDeclaration & Opts;\nexport function isVariableDeclaration<\n  Opts extends Options<t.VariableDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"VariableDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isVariableDeclarator(\n  node: t.Node | null | undefined,\n): node is t.VariableDeclarator;\nexport function isVariableDeclarator<\n  Opts extends Options<t.VariableDeclarator>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.VariableDeclarator & Opts;\nexport function isVariableDeclarator<\n  Opts extends Options<t.VariableDeclarator>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"VariableDeclarator\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isWhileStatement(\n  node: t.Node | null | undefined,\n): node is t.WhileStatement;\nexport function isWhileStatement<Opts extends Options<t.WhileStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.WhileStatement & Opts;\nexport function isWhileStatement<Opts extends Options<t.WhileStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"WhileStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isWithStatement(\n  node: t.Node | null | undefined,\n): node is t.WithStatement;\nexport function isWithStatement<Opts extends Options<t.WithStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.WithStatement & Opts;\nexport function isWithStatement<Opts extends Options<t.WithStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"WithStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isAssignmentPattern(\n  node: t.Node | null | undefined,\n): node is t.AssignmentPattern;\nexport function isAssignmentPattern<Opts extends Options<t.AssignmentPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.AssignmentPattern & Opts;\nexport function isAssignmentPattern<Opts extends Options<t.AssignmentPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"AssignmentPattern\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isArrayPattern(\n  node: t.Node | null | undefined,\n): node is t.ArrayPattern;\nexport function isArrayPattern<Opts extends Options<t.ArrayPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ArrayPattern & Opts;\nexport function isArrayPattern<Opts extends Options<t.ArrayPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ArrayPattern\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isArrowFunctionExpression(\n  node: t.Node | null | undefined,\n): node is t.ArrowFunctionExpression;\nexport function isArrowFunctionExpression<\n  Opts extends Options<t.ArrowFunctionExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ArrowFunctionExpression & Opts;\nexport function isArrowFunctionExpression<\n  Opts extends Options<t.ArrowFunctionExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ArrowFunctionExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassBody(\n  node: t.Node | null | undefined,\n): node is t.ClassBody;\nexport function isClassBody<Opts extends Options<t.ClassBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassBody & Opts;\nexport function isClassBody<Opts extends Options<t.ClassBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassExpression(\n  node: t.Node | null | undefined,\n): node is t.ClassExpression;\nexport function isClassExpression<Opts extends Options<t.ClassExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassExpression & Opts;\nexport function isClassExpression<Opts extends Options<t.ClassExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ClassDeclaration;\nexport function isClassDeclaration<Opts extends Options<t.ClassDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassDeclaration & Opts;\nexport function isClassDeclaration<Opts extends Options<t.ClassDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportAllDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ExportAllDeclaration;\nexport function isExportAllDeclaration<\n  Opts extends Options<t.ExportAllDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExportAllDeclaration & Opts;\nexport function isExportAllDeclaration<\n  Opts extends Options<t.ExportAllDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExportAllDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportDefaultDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ExportDefaultDeclaration;\nexport function isExportDefaultDeclaration<\n  Opts extends Options<t.ExportDefaultDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExportDefaultDeclaration & Opts;\nexport function isExportDefaultDeclaration<\n  Opts extends Options<t.ExportDefaultDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExportDefaultDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportNamedDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ExportNamedDeclaration;\nexport function isExportNamedDeclaration<\n  Opts extends Options<t.ExportNamedDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExportNamedDeclaration & Opts;\nexport function isExportNamedDeclaration<\n  Opts extends Options<t.ExportNamedDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExportNamedDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ExportSpecifier;\nexport function isExportSpecifier<Opts extends Options<t.ExportSpecifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExportSpecifier & Opts;\nexport function isExportSpecifier<Opts extends Options<t.ExportSpecifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExportSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isForOfStatement(\n  node: t.Node | null | undefined,\n): node is t.ForOfStatement;\nexport function isForOfStatement<Opts extends Options<t.ForOfStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ForOfStatement & Opts;\nexport function isForOfStatement<Opts extends Options<t.ForOfStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ForOfStatement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ImportDeclaration;\nexport function isImportDeclaration<Opts extends Options<t.ImportDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportDeclaration & Opts;\nexport function isImportDeclaration<Opts extends Options<t.ImportDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ImportDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportDefaultSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ImportDefaultSpecifier;\nexport function isImportDefaultSpecifier<\n  Opts extends Options<t.ImportDefaultSpecifier>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportDefaultSpecifier & Opts;\nexport function isImportDefaultSpecifier<\n  Opts extends Options<t.ImportDefaultSpecifier>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ImportDefaultSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportNamespaceSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ImportNamespaceSpecifier;\nexport function isImportNamespaceSpecifier<\n  Opts extends Options<t.ImportNamespaceSpecifier>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportNamespaceSpecifier & Opts;\nexport function isImportNamespaceSpecifier<\n  Opts extends Options<t.ImportNamespaceSpecifier>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ImportNamespaceSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ImportSpecifier;\nexport function isImportSpecifier<Opts extends Options<t.ImportSpecifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportSpecifier & Opts;\nexport function isImportSpecifier<Opts extends Options<t.ImportSpecifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ImportSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportExpression(\n  node: t.Node | null | undefined,\n): node is t.ImportExpression;\nexport function isImportExpression<Opts extends Options<t.ImportExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportExpression & Opts;\nexport function isImportExpression<Opts extends Options<t.ImportExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ImportExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isMetaProperty(\n  node: t.Node | null | undefined,\n): node is t.MetaProperty;\nexport function isMetaProperty<Opts extends Options<t.MetaProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.MetaProperty & Opts;\nexport function isMetaProperty<Opts extends Options<t.MetaProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"MetaProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassMethod(\n  node: t.Node | null | undefined,\n): node is t.ClassMethod;\nexport function isClassMethod<Opts extends Options<t.ClassMethod>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassMethod & Opts;\nexport function isClassMethod<Opts extends Options<t.ClassMethod>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassMethod\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectPattern(\n  node: t.Node | null | undefined,\n): node is t.ObjectPattern;\nexport function isObjectPattern<Opts extends Options<t.ObjectPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectPattern & Opts;\nexport function isObjectPattern<Opts extends Options<t.ObjectPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectPattern\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSpreadElement(\n  node: t.Node | null | undefined,\n): node is t.SpreadElement;\nexport function isSpreadElement<Opts extends Options<t.SpreadElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.SpreadElement & Opts;\nexport function isSpreadElement<Opts extends Options<t.SpreadElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"SpreadElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSuper(node: t.Node | null | undefined): node is t.Super;\nexport function isSuper<Opts extends Options<t.Super>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Super & Opts;\nexport function isSuper<Opts extends Options<t.Super>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Super\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTaggedTemplateExpression(\n  node: t.Node | null | undefined,\n): node is t.TaggedTemplateExpression;\nexport function isTaggedTemplateExpression<\n  Opts extends Options<t.TaggedTemplateExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TaggedTemplateExpression & Opts;\nexport function isTaggedTemplateExpression<\n  Opts extends Options<t.TaggedTemplateExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TaggedTemplateExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTemplateElement(\n  node: t.Node | null | undefined,\n): node is t.TemplateElement;\nexport function isTemplateElement<Opts extends Options<t.TemplateElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TemplateElement & Opts;\nexport function isTemplateElement<Opts extends Options<t.TemplateElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TemplateElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTemplateLiteral(\n  node: t.Node | null | undefined,\n): node is t.TemplateLiteral;\nexport function isTemplateLiteral<Opts extends Options<t.TemplateLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TemplateLiteral & Opts;\nexport function isTemplateLiteral<Opts extends Options<t.TemplateLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TemplateLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isYieldExpression(\n  node: t.Node | null | undefined,\n): node is t.YieldExpression;\nexport function isYieldExpression<Opts extends Options<t.YieldExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.YieldExpression & Opts;\nexport function isYieldExpression<Opts extends Options<t.YieldExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"YieldExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isAwaitExpression(\n  node: t.Node | null | undefined,\n): node is t.AwaitExpression;\nexport function isAwaitExpression<Opts extends Options<t.AwaitExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.AwaitExpression & Opts;\nexport function isAwaitExpression<Opts extends Options<t.AwaitExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"AwaitExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImport(node: t.Node | null | undefined): node is t.Import;\nexport function isImport<Opts extends Options<t.Import>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Import & Opts;\nexport function isImport<Opts extends Options<t.Import>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Import\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBigIntLiteral(\n  node: t.Node | null | undefined,\n): node is t.BigIntLiteral;\nexport function isBigIntLiteral<Opts extends Options<t.BigIntLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BigIntLiteral & Opts;\nexport function isBigIntLiteral<Opts extends Options<t.BigIntLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BigIntLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportNamespaceSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ExportNamespaceSpecifier;\nexport function isExportNamespaceSpecifier<\n  Opts extends Options<t.ExportNamespaceSpecifier>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExportNamespaceSpecifier & Opts;\nexport function isExportNamespaceSpecifier<\n  Opts extends Options<t.ExportNamespaceSpecifier>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExportNamespaceSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isOptionalMemberExpression(\n  node: t.Node | null | undefined,\n): node is t.OptionalMemberExpression;\nexport function isOptionalMemberExpression<\n  Opts extends Options<t.OptionalMemberExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.OptionalMemberExpression & Opts;\nexport function isOptionalMemberExpression<\n  Opts extends Options<t.OptionalMemberExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"OptionalMemberExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isOptionalCallExpression(\n  node: t.Node | null | undefined,\n): node is t.OptionalCallExpression;\nexport function isOptionalCallExpression<\n  Opts extends Options<t.OptionalCallExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.OptionalCallExpression & Opts;\nexport function isOptionalCallExpression<\n  Opts extends Options<t.OptionalCallExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"OptionalCallExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassProperty(\n  node: t.Node | null | undefined,\n): node is t.ClassProperty;\nexport function isClassProperty<Opts extends Options<t.ClassProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassProperty & Opts;\nexport function isClassProperty<Opts extends Options<t.ClassProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassAccessorProperty(\n  node: t.Node | null | undefined,\n): node is t.ClassAccessorProperty;\nexport function isClassAccessorProperty<\n  Opts extends Options<t.ClassAccessorProperty>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassAccessorProperty & Opts;\nexport function isClassAccessorProperty<\n  Opts extends Options<t.ClassAccessorProperty>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassAccessorProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassPrivateProperty(\n  node: t.Node | null | undefined,\n): node is t.ClassPrivateProperty;\nexport function isClassPrivateProperty<\n  Opts extends Options<t.ClassPrivateProperty>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassPrivateProperty & Opts;\nexport function isClassPrivateProperty<\n  Opts extends Options<t.ClassPrivateProperty>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassPrivateProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassPrivateMethod(\n  node: t.Node | null | undefined,\n): node is t.ClassPrivateMethod;\nexport function isClassPrivateMethod<\n  Opts extends Options<t.ClassPrivateMethod>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassPrivateMethod & Opts;\nexport function isClassPrivateMethod<\n  Opts extends Options<t.ClassPrivateMethod>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassPrivateMethod\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPrivateName(\n  node: t.Node | null | undefined,\n): node is t.PrivateName;\nexport function isPrivateName<Opts extends Options<t.PrivateName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.PrivateName & Opts;\nexport function isPrivateName<Opts extends Options<t.PrivateName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"PrivateName\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStaticBlock(\n  node: t.Node | null | undefined,\n): node is t.StaticBlock;\nexport function isStaticBlock<Opts extends Options<t.StaticBlock>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.StaticBlock & Opts;\nexport function isStaticBlock<Opts extends Options<t.StaticBlock>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"StaticBlock\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportAttribute(\n  node: t.Node | null | undefined,\n): node is t.ImportAttribute;\nexport function isImportAttribute<Opts extends Options<t.ImportAttribute>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportAttribute & Opts;\nexport function isImportAttribute<Opts extends Options<t.ImportAttribute>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ImportAttribute\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isAnyTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.AnyTypeAnnotation;\nexport function isAnyTypeAnnotation<Opts extends Options<t.AnyTypeAnnotation>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.AnyTypeAnnotation & Opts;\nexport function isAnyTypeAnnotation<Opts extends Options<t.AnyTypeAnnotation>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"AnyTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isArrayTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.ArrayTypeAnnotation;\nexport function isArrayTypeAnnotation<\n  Opts extends Options<t.ArrayTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ArrayTypeAnnotation & Opts;\nexport function isArrayTypeAnnotation<\n  Opts extends Options<t.ArrayTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ArrayTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBooleanTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.BooleanTypeAnnotation;\nexport function isBooleanTypeAnnotation<\n  Opts extends Options<t.BooleanTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BooleanTypeAnnotation & Opts;\nexport function isBooleanTypeAnnotation<\n  Opts extends Options<t.BooleanTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BooleanTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBooleanLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.BooleanLiteralTypeAnnotation;\nexport function isBooleanLiteralTypeAnnotation<\n  Opts extends Options<t.BooleanLiteralTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BooleanLiteralTypeAnnotation & Opts;\nexport function isBooleanLiteralTypeAnnotation<\n  Opts extends Options<t.BooleanLiteralTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BooleanLiteralTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNullLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.NullLiteralTypeAnnotation;\nexport function isNullLiteralTypeAnnotation<\n  Opts extends Options<t.NullLiteralTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.NullLiteralTypeAnnotation & Opts;\nexport function isNullLiteralTypeAnnotation<\n  Opts extends Options<t.NullLiteralTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"NullLiteralTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClassImplements(\n  node: t.Node | null | undefined,\n): node is t.ClassImplements;\nexport function isClassImplements<Opts extends Options<t.ClassImplements>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ClassImplements & Opts;\nexport function isClassImplements<Opts extends Options<t.ClassImplements>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ClassImplements\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareClass(\n  node: t.Node | null | undefined,\n): node is t.DeclareClass;\nexport function isDeclareClass<Opts extends Options<t.DeclareClass>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareClass & Opts;\nexport function isDeclareClass<Opts extends Options<t.DeclareClass>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareClass\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareFunction(\n  node: t.Node | null | undefined,\n): node is t.DeclareFunction;\nexport function isDeclareFunction<Opts extends Options<t.DeclareFunction>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareFunction & Opts;\nexport function isDeclareFunction<Opts extends Options<t.DeclareFunction>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareFunction\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareInterface(\n  node: t.Node | null | undefined,\n): node is t.DeclareInterface;\nexport function isDeclareInterface<Opts extends Options<t.DeclareInterface>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareInterface & Opts;\nexport function isDeclareInterface<Opts extends Options<t.DeclareInterface>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareInterface\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareModule(\n  node: t.Node | null | undefined,\n): node is t.DeclareModule;\nexport function isDeclareModule<Opts extends Options<t.DeclareModule>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareModule & Opts;\nexport function isDeclareModule<Opts extends Options<t.DeclareModule>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareModule\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareModuleExports(\n  node: t.Node | null | undefined,\n): node is t.DeclareModuleExports;\nexport function isDeclareModuleExports<\n  Opts extends Options<t.DeclareModuleExports>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareModuleExports & Opts;\nexport function isDeclareModuleExports<\n  Opts extends Options<t.DeclareModuleExports>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareModuleExports\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareTypeAlias(\n  node: t.Node | null | undefined,\n): node is t.DeclareTypeAlias;\nexport function isDeclareTypeAlias<Opts extends Options<t.DeclareTypeAlias>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareTypeAlias & Opts;\nexport function isDeclareTypeAlias<Opts extends Options<t.DeclareTypeAlias>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareTypeAlias\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareOpaqueType(\n  node: t.Node | null | undefined,\n): node is t.DeclareOpaqueType;\nexport function isDeclareOpaqueType<Opts extends Options<t.DeclareOpaqueType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareOpaqueType & Opts;\nexport function isDeclareOpaqueType<Opts extends Options<t.DeclareOpaqueType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareOpaqueType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareVariable(\n  node: t.Node | null | undefined,\n): node is t.DeclareVariable;\nexport function isDeclareVariable<Opts extends Options<t.DeclareVariable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareVariable & Opts;\nexport function isDeclareVariable<Opts extends Options<t.DeclareVariable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareVariable\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareExportDeclaration(\n  node: t.Node | null | undefined,\n): node is t.DeclareExportDeclaration;\nexport function isDeclareExportDeclaration<\n  Opts extends Options<t.DeclareExportDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareExportDeclaration & Opts;\nexport function isDeclareExportDeclaration<\n  Opts extends Options<t.DeclareExportDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareExportDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclareExportAllDeclaration(\n  node: t.Node | null | undefined,\n): node is t.DeclareExportAllDeclaration;\nexport function isDeclareExportAllDeclaration<\n  Opts extends Options<t.DeclareExportAllDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclareExportAllDeclaration & Opts;\nexport function isDeclareExportAllDeclaration<\n  Opts extends Options<t.DeclareExportAllDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclareExportAllDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclaredPredicate(\n  node: t.Node | null | undefined,\n): node is t.DeclaredPredicate;\nexport function isDeclaredPredicate<Opts extends Options<t.DeclaredPredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DeclaredPredicate & Opts;\nexport function isDeclaredPredicate<Opts extends Options<t.DeclaredPredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DeclaredPredicate\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExistsTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.ExistsTypeAnnotation;\nexport function isExistsTypeAnnotation<\n  Opts extends Options<t.ExistsTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExistsTypeAnnotation & Opts;\nexport function isExistsTypeAnnotation<\n  Opts extends Options<t.ExistsTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExistsTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.FunctionTypeAnnotation;\nexport function isFunctionTypeAnnotation<\n  Opts extends Options<t.FunctionTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FunctionTypeAnnotation & Opts;\nexport function isFunctionTypeAnnotation<\n  Opts extends Options<t.FunctionTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"FunctionTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionTypeParam(\n  node: t.Node | null | undefined,\n): node is t.FunctionTypeParam;\nexport function isFunctionTypeParam<Opts extends Options<t.FunctionTypeParam>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FunctionTypeParam & Opts;\nexport function isFunctionTypeParam<Opts extends Options<t.FunctionTypeParam>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"FunctionTypeParam\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isGenericTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.GenericTypeAnnotation;\nexport function isGenericTypeAnnotation<\n  Opts extends Options<t.GenericTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.GenericTypeAnnotation & Opts;\nexport function isGenericTypeAnnotation<\n  Opts extends Options<t.GenericTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"GenericTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isInferredPredicate(\n  node: t.Node | null | undefined,\n): node is t.InferredPredicate;\nexport function isInferredPredicate<Opts extends Options<t.InferredPredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.InferredPredicate & Opts;\nexport function isInferredPredicate<Opts extends Options<t.InferredPredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"InferredPredicate\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isInterfaceExtends(\n  node: t.Node | null | undefined,\n): node is t.InterfaceExtends;\nexport function isInterfaceExtends<Opts extends Options<t.InterfaceExtends>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.InterfaceExtends & Opts;\nexport function isInterfaceExtends<Opts extends Options<t.InterfaceExtends>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"InterfaceExtends\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isInterfaceDeclaration(\n  node: t.Node | null | undefined,\n): node is t.InterfaceDeclaration;\nexport function isInterfaceDeclaration<\n  Opts extends Options<t.InterfaceDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.InterfaceDeclaration & Opts;\nexport function isInterfaceDeclaration<\n  Opts extends Options<t.InterfaceDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"InterfaceDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isInterfaceTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.InterfaceTypeAnnotation;\nexport function isInterfaceTypeAnnotation<\n  Opts extends Options<t.InterfaceTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.InterfaceTypeAnnotation & Opts;\nexport function isInterfaceTypeAnnotation<\n  Opts extends Options<t.InterfaceTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"InterfaceTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isIntersectionTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.IntersectionTypeAnnotation;\nexport function isIntersectionTypeAnnotation<\n  Opts extends Options<t.IntersectionTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.IntersectionTypeAnnotation & Opts;\nexport function isIntersectionTypeAnnotation<\n  Opts extends Options<t.IntersectionTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"IntersectionTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isMixedTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.MixedTypeAnnotation;\nexport function isMixedTypeAnnotation<\n  Opts extends Options<t.MixedTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.MixedTypeAnnotation & Opts;\nexport function isMixedTypeAnnotation<\n  Opts extends Options<t.MixedTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"MixedTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEmptyTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.EmptyTypeAnnotation;\nexport function isEmptyTypeAnnotation<\n  Opts extends Options<t.EmptyTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EmptyTypeAnnotation & Opts;\nexport function isEmptyTypeAnnotation<\n  Opts extends Options<t.EmptyTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EmptyTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNullableTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.NullableTypeAnnotation;\nexport function isNullableTypeAnnotation<\n  Opts extends Options<t.NullableTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.NullableTypeAnnotation & Opts;\nexport function isNullableTypeAnnotation<\n  Opts extends Options<t.NullableTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"NullableTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNumberLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.NumberLiteralTypeAnnotation;\nexport function isNumberLiteralTypeAnnotation<\n  Opts extends Options<t.NumberLiteralTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.NumberLiteralTypeAnnotation & Opts;\nexport function isNumberLiteralTypeAnnotation<\n  Opts extends Options<t.NumberLiteralTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"NumberLiteralTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNumberTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.NumberTypeAnnotation;\nexport function isNumberTypeAnnotation<\n  Opts extends Options<t.NumberTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.NumberTypeAnnotation & Opts;\nexport function isNumberTypeAnnotation<\n  Opts extends Options<t.NumberTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"NumberTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeAnnotation;\nexport function isObjectTypeAnnotation<\n  Opts extends Options<t.ObjectTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectTypeAnnotation & Opts;\nexport function isObjectTypeAnnotation<\n  Opts extends Options<t.ObjectTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeInternalSlot(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeInternalSlot;\nexport function isObjectTypeInternalSlot<\n  Opts extends Options<t.ObjectTypeInternalSlot>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectTypeInternalSlot & Opts;\nexport function isObjectTypeInternalSlot<\n  Opts extends Options<t.ObjectTypeInternalSlot>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeInternalSlot\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeCallProperty(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeCallProperty;\nexport function isObjectTypeCallProperty<\n  Opts extends Options<t.ObjectTypeCallProperty>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectTypeCallProperty & Opts;\nexport function isObjectTypeCallProperty<\n  Opts extends Options<t.ObjectTypeCallProperty>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeCallProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeIndexer(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeIndexer;\nexport function isObjectTypeIndexer<Opts extends Options<t.ObjectTypeIndexer>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectTypeIndexer & Opts;\nexport function isObjectTypeIndexer<Opts extends Options<t.ObjectTypeIndexer>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeIndexer\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeProperty(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeProperty;\nexport function isObjectTypeProperty<\n  Opts extends Options<t.ObjectTypeProperty>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectTypeProperty & Opts;\nexport function isObjectTypeProperty<\n  Opts extends Options<t.ObjectTypeProperty>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectTypeSpreadProperty(\n  node: t.Node | null | undefined,\n): node is t.ObjectTypeSpreadProperty;\nexport function isObjectTypeSpreadProperty<\n  Opts extends Options<t.ObjectTypeSpreadProperty>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectTypeSpreadProperty & Opts;\nexport function isObjectTypeSpreadProperty<\n  Opts extends Options<t.ObjectTypeSpreadProperty>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ObjectTypeSpreadProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isOpaqueType(\n  node: t.Node | null | undefined,\n): node is t.OpaqueType;\nexport function isOpaqueType<Opts extends Options<t.OpaqueType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.OpaqueType & Opts;\nexport function isOpaqueType<Opts extends Options<t.OpaqueType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"OpaqueType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isQualifiedTypeIdentifier(\n  node: t.Node | null | undefined,\n): node is t.QualifiedTypeIdentifier;\nexport function isQualifiedTypeIdentifier<\n  Opts extends Options<t.QualifiedTypeIdentifier>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.QualifiedTypeIdentifier & Opts;\nexport function isQualifiedTypeIdentifier<\n  Opts extends Options<t.QualifiedTypeIdentifier>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"QualifiedTypeIdentifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStringLiteralTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.StringLiteralTypeAnnotation;\nexport function isStringLiteralTypeAnnotation<\n  Opts extends Options<t.StringLiteralTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.StringLiteralTypeAnnotation & Opts;\nexport function isStringLiteralTypeAnnotation<\n  Opts extends Options<t.StringLiteralTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"StringLiteralTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStringTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.StringTypeAnnotation;\nexport function isStringTypeAnnotation<\n  Opts extends Options<t.StringTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.StringTypeAnnotation & Opts;\nexport function isStringTypeAnnotation<\n  Opts extends Options<t.StringTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"StringTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isSymbolTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.SymbolTypeAnnotation;\nexport function isSymbolTypeAnnotation<\n  Opts extends Options<t.SymbolTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.SymbolTypeAnnotation & Opts;\nexport function isSymbolTypeAnnotation<\n  Opts extends Options<t.SymbolTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"SymbolTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isThisTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.ThisTypeAnnotation;\nexport function isThisTypeAnnotation<\n  Opts extends Options<t.ThisTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ThisTypeAnnotation & Opts;\nexport function isThisTypeAnnotation<\n  Opts extends Options<t.ThisTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ThisTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTupleTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.TupleTypeAnnotation;\nexport function isTupleTypeAnnotation<\n  Opts extends Options<t.TupleTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TupleTypeAnnotation & Opts;\nexport function isTupleTypeAnnotation<\n  Opts extends Options<t.TupleTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TupleTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeofTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.TypeofTypeAnnotation;\nexport function isTypeofTypeAnnotation<\n  Opts extends Options<t.TypeofTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeofTypeAnnotation & Opts;\nexport function isTypeofTypeAnnotation<\n  Opts extends Options<t.TypeofTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TypeofTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeAlias(\n  node: t.Node | null | undefined,\n): node is t.TypeAlias;\nexport function isTypeAlias<Opts extends Options<t.TypeAlias>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeAlias & Opts;\nexport function isTypeAlias<Opts extends Options<t.TypeAlias>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TypeAlias\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.TypeAnnotation;\nexport function isTypeAnnotation<Opts extends Options<t.TypeAnnotation>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeAnnotation & Opts;\nexport function isTypeAnnotation<Opts extends Options<t.TypeAnnotation>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeCastExpression(\n  node: t.Node | null | undefined,\n): node is t.TypeCastExpression;\nexport function isTypeCastExpression<\n  Opts extends Options<t.TypeCastExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeCastExpression & Opts;\nexport function isTypeCastExpression<\n  Opts extends Options<t.TypeCastExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TypeCastExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeParameter(\n  node: t.Node | null | undefined,\n): node is t.TypeParameter;\nexport function isTypeParameter<Opts extends Options<t.TypeParameter>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeParameter & Opts;\nexport function isTypeParameter<Opts extends Options<t.TypeParameter>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TypeParameter\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeParameterDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TypeParameterDeclaration;\nexport function isTypeParameterDeclaration<\n  Opts extends Options<t.TypeParameterDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeParameterDeclaration & Opts;\nexport function isTypeParameterDeclaration<\n  Opts extends Options<t.TypeParameterDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TypeParameterDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeParameterInstantiation(\n  node: t.Node | null | undefined,\n): node is t.TypeParameterInstantiation;\nexport function isTypeParameterInstantiation<\n  Opts extends Options<t.TypeParameterInstantiation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeParameterInstantiation & Opts;\nexport function isTypeParameterInstantiation<\n  Opts extends Options<t.TypeParameterInstantiation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TypeParameterInstantiation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isUnionTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.UnionTypeAnnotation;\nexport function isUnionTypeAnnotation<\n  Opts extends Options<t.UnionTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.UnionTypeAnnotation & Opts;\nexport function isUnionTypeAnnotation<\n  Opts extends Options<t.UnionTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"UnionTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isVariance(node: t.Node | null | undefined): node is t.Variance;\nexport function isVariance<Opts extends Options<t.Variance>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Variance & Opts;\nexport function isVariance<Opts extends Options<t.Variance>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Variance\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isVoidTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.VoidTypeAnnotation;\nexport function isVoidTypeAnnotation<\n  Opts extends Options<t.VoidTypeAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.VoidTypeAnnotation & Opts;\nexport function isVoidTypeAnnotation<\n  Opts extends Options<t.VoidTypeAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"VoidTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumDeclaration(\n  node: t.Node | null | undefined,\n): node is t.EnumDeclaration;\nexport function isEnumDeclaration<Opts extends Options<t.EnumDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumDeclaration & Opts;\nexport function isEnumDeclaration<Opts extends Options<t.EnumDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumBooleanBody(\n  node: t.Node | null | undefined,\n): node is t.EnumBooleanBody;\nexport function isEnumBooleanBody<Opts extends Options<t.EnumBooleanBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumBooleanBody & Opts;\nexport function isEnumBooleanBody<Opts extends Options<t.EnumBooleanBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumBooleanBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumNumberBody(\n  node: t.Node | null | undefined,\n): node is t.EnumNumberBody;\nexport function isEnumNumberBody<Opts extends Options<t.EnumNumberBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumNumberBody & Opts;\nexport function isEnumNumberBody<Opts extends Options<t.EnumNumberBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumNumberBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumStringBody(\n  node: t.Node | null | undefined,\n): node is t.EnumStringBody;\nexport function isEnumStringBody<Opts extends Options<t.EnumStringBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumStringBody & Opts;\nexport function isEnumStringBody<Opts extends Options<t.EnumStringBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumStringBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumSymbolBody(\n  node: t.Node | null | undefined,\n): node is t.EnumSymbolBody;\nexport function isEnumSymbolBody<Opts extends Options<t.EnumSymbolBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumSymbolBody & Opts;\nexport function isEnumSymbolBody<Opts extends Options<t.EnumSymbolBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumSymbolBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumBooleanMember(\n  node: t.Node | null | undefined,\n): node is t.EnumBooleanMember;\nexport function isEnumBooleanMember<Opts extends Options<t.EnumBooleanMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumBooleanMember & Opts;\nexport function isEnumBooleanMember<Opts extends Options<t.EnumBooleanMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumBooleanMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumNumberMember(\n  node: t.Node | null | undefined,\n): node is t.EnumNumberMember;\nexport function isEnumNumberMember<Opts extends Options<t.EnumNumberMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumNumberMember & Opts;\nexport function isEnumNumberMember<Opts extends Options<t.EnumNumberMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumNumberMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumStringMember(\n  node: t.Node | null | undefined,\n): node is t.EnumStringMember;\nexport function isEnumStringMember<Opts extends Options<t.EnumStringMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumStringMember & Opts;\nexport function isEnumStringMember<Opts extends Options<t.EnumStringMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumStringMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumDefaultedMember(\n  node: t.Node | null | undefined,\n): node is t.EnumDefaultedMember;\nexport function isEnumDefaultedMember<\n  Opts extends Options<t.EnumDefaultedMember>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumDefaultedMember & Opts;\nexport function isEnumDefaultedMember<\n  Opts extends Options<t.EnumDefaultedMember>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"EnumDefaultedMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isIndexedAccessType(\n  node: t.Node | null | undefined,\n): node is t.IndexedAccessType;\nexport function isIndexedAccessType<Opts extends Options<t.IndexedAccessType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.IndexedAccessType & Opts;\nexport function isIndexedAccessType<Opts extends Options<t.IndexedAccessType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"IndexedAccessType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isOptionalIndexedAccessType(\n  node: t.Node | null | undefined,\n): node is t.OptionalIndexedAccessType;\nexport function isOptionalIndexedAccessType<\n  Opts extends Options<t.OptionalIndexedAccessType>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.OptionalIndexedAccessType & Opts;\nexport function isOptionalIndexedAccessType<\n  Opts extends Options<t.OptionalIndexedAccessType>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"OptionalIndexedAccessType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXAttribute(\n  node: t.Node | null | undefined,\n): node is t.JSXAttribute;\nexport function isJSXAttribute<Opts extends Options<t.JSXAttribute>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXAttribute & Opts;\nexport function isJSXAttribute<Opts extends Options<t.JSXAttribute>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXAttribute\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXClosingElement(\n  node: t.Node | null | undefined,\n): node is t.JSXClosingElement;\nexport function isJSXClosingElement<Opts extends Options<t.JSXClosingElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXClosingElement & Opts;\nexport function isJSXClosingElement<Opts extends Options<t.JSXClosingElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXClosingElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXElement(\n  node: t.Node | null | undefined,\n): node is t.JSXElement;\nexport function isJSXElement<Opts extends Options<t.JSXElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXElement & Opts;\nexport function isJSXElement<Opts extends Options<t.JSXElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXEmptyExpression(\n  node: t.Node | null | undefined,\n): node is t.JSXEmptyExpression;\nexport function isJSXEmptyExpression<\n  Opts extends Options<t.JSXEmptyExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXEmptyExpression & Opts;\nexport function isJSXEmptyExpression<\n  Opts extends Options<t.JSXEmptyExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXEmptyExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXExpressionContainer(\n  node: t.Node | null | undefined,\n): node is t.JSXExpressionContainer;\nexport function isJSXExpressionContainer<\n  Opts extends Options<t.JSXExpressionContainer>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXExpressionContainer & Opts;\nexport function isJSXExpressionContainer<\n  Opts extends Options<t.JSXExpressionContainer>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXExpressionContainer\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXSpreadChild(\n  node: t.Node | null | undefined,\n): node is t.JSXSpreadChild;\nexport function isJSXSpreadChild<Opts extends Options<t.JSXSpreadChild>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXSpreadChild & Opts;\nexport function isJSXSpreadChild<Opts extends Options<t.JSXSpreadChild>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXSpreadChild\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXIdentifier(\n  node: t.Node | null | undefined,\n): node is t.JSXIdentifier;\nexport function isJSXIdentifier<Opts extends Options<t.JSXIdentifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXIdentifier & Opts;\nexport function isJSXIdentifier<Opts extends Options<t.JSXIdentifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXIdentifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXMemberExpression(\n  node: t.Node | null | undefined,\n): node is t.JSXMemberExpression;\nexport function isJSXMemberExpression<\n  Opts extends Options<t.JSXMemberExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXMemberExpression & Opts;\nexport function isJSXMemberExpression<\n  Opts extends Options<t.JSXMemberExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXMemberExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXNamespacedName(\n  node: t.Node | null | undefined,\n): node is t.JSXNamespacedName;\nexport function isJSXNamespacedName<Opts extends Options<t.JSXNamespacedName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXNamespacedName & Opts;\nexport function isJSXNamespacedName<Opts extends Options<t.JSXNamespacedName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXNamespacedName\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXOpeningElement(\n  node: t.Node | null | undefined,\n): node is t.JSXOpeningElement;\nexport function isJSXOpeningElement<Opts extends Options<t.JSXOpeningElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXOpeningElement & Opts;\nexport function isJSXOpeningElement<Opts extends Options<t.JSXOpeningElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXOpeningElement\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXSpreadAttribute(\n  node: t.Node | null | undefined,\n): node is t.JSXSpreadAttribute;\nexport function isJSXSpreadAttribute<\n  Opts extends Options<t.JSXSpreadAttribute>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXSpreadAttribute & Opts;\nexport function isJSXSpreadAttribute<\n  Opts extends Options<t.JSXSpreadAttribute>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXSpreadAttribute\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXText(node: t.Node | null | undefined): node is t.JSXText;\nexport function isJSXText<Opts extends Options<t.JSXText>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXText & Opts;\nexport function isJSXText<Opts extends Options<t.JSXText>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXText\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXFragment(\n  node: t.Node | null | undefined,\n): node is t.JSXFragment;\nexport function isJSXFragment<Opts extends Options<t.JSXFragment>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXFragment & Opts;\nexport function isJSXFragment<Opts extends Options<t.JSXFragment>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXFragment\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXOpeningFragment(\n  node: t.Node | null | undefined,\n): node is t.JSXOpeningFragment;\nexport function isJSXOpeningFragment<\n  Opts extends Options<t.JSXOpeningFragment>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXOpeningFragment & Opts;\nexport function isJSXOpeningFragment<\n  Opts extends Options<t.JSXOpeningFragment>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXOpeningFragment\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSXClosingFragment(\n  node: t.Node | null | undefined,\n): node is t.JSXClosingFragment;\nexport function isJSXClosingFragment<\n  Opts extends Options<t.JSXClosingFragment>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSXClosingFragment & Opts;\nexport function isJSXClosingFragment<\n  Opts extends Options<t.JSXClosingFragment>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"JSXClosingFragment\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isNoop(node: t.Node | null | undefined): node is t.Noop;\nexport function isNoop<Opts extends Options<t.Noop>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Noop & Opts;\nexport function isNoop<Opts extends Options<t.Noop>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Noop\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPlaceholder(\n  node: t.Node | null | undefined,\n): node is t.Placeholder;\nexport function isPlaceholder<Opts extends Options<t.Placeholder>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Placeholder & Opts;\nexport function isPlaceholder<Opts extends Options<t.Placeholder>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Placeholder\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isV8IntrinsicIdentifier(\n  node: t.Node | null | undefined,\n): node is t.V8IntrinsicIdentifier;\nexport function isV8IntrinsicIdentifier<\n  Opts extends Options<t.V8IntrinsicIdentifier>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.V8IntrinsicIdentifier & Opts;\nexport function isV8IntrinsicIdentifier<\n  Opts extends Options<t.V8IntrinsicIdentifier>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"V8IntrinsicIdentifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isArgumentPlaceholder(\n  node: t.Node | null | undefined,\n): node is t.ArgumentPlaceholder;\nexport function isArgumentPlaceholder<\n  Opts extends Options<t.ArgumentPlaceholder>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ArgumentPlaceholder & Opts;\nexport function isArgumentPlaceholder<\n  Opts extends Options<t.ArgumentPlaceholder>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ArgumentPlaceholder\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBindExpression(\n  node: t.Node | null | undefined,\n): node is t.BindExpression;\nexport function isBindExpression<Opts extends Options<t.BindExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BindExpression & Opts;\nexport function isBindExpression<Opts extends Options<t.BindExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"BindExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDecorator(\n  node: t.Node | null | undefined,\n): node is t.Decorator;\nexport function isDecorator<Opts extends Options<t.Decorator>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Decorator & Opts;\nexport function isDecorator<Opts extends Options<t.Decorator>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"Decorator\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDoExpression(\n  node: t.Node | null | undefined,\n): node is t.DoExpression;\nexport function isDoExpression<Opts extends Options<t.DoExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DoExpression & Opts;\nexport function isDoExpression<Opts extends Options<t.DoExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DoExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportDefaultSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ExportDefaultSpecifier;\nexport function isExportDefaultSpecifier<\n  Opts extends Options<t.ExportDefaultSpecifier>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExportDefaultSpecifier & Opts;\nexport function isExportDefaultSpecifier<\n  Opts extends Options<t.ExportDefaultSpecifier>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ExportDefaultSpecifier\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isRecordExpression(\n  node: t.Node | null | undefined,\n): node is t.RecordExpression;\nexport function isRecordExpression<Opts extends Options<t.RecordExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.RecordExpression & Opts;\nexport function isRecordExpression<Opts extends Options<t.RecordExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"RecordExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTupleExpression(\n  node: t.Node | null | undefined,\n): node is t.TupleExpression;\nexport function isTupleExpression<Opts extends Options<t.TupleExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TupleExpression & Opts;\nexport function isTupleExpression<Opts extends Options<t.TupleExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TupleExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDecimalLiteral(\n  node: t.Node | null | undefined,\n): node is t.DecimalLiteral;\nexport function isDecimalLiteral<Opts extends Options<t.DecimalLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.DecimalLiteral & Opts;\nexport function isDecimalLiteral<Opts extends Options<t.DecimalLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"DecimalLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isModuleExpression(\n  node: t.Node | null | undefined,\n): node is t.ModuleExpression;\nexport function isModuleExpression<Opts extends Options<t.ModuleExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ModuleExpression & Opts;\nexport function isModuleExpression<Opts extends Options<t.ModuleExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"ModuleExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTopicReference(\n  node: t.Node | null | undefined,\n): node is t.TopicReference;\nexport function isTopicReference<Opts extends Options<t.TopicReference>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TopicReference & Opts;\nexport function isTopicReference<Opts extends Options<t.TopicReference>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TopicReference\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPipelineTopicExpression(\n  node: t.Node | null | undefined,\n): node is t.PipelineTopicExpression;\nexport function isPipelineTopicExpression<\n  Opts extends Options<t.PipelineTopicExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.PipelineTopicExpression & Opts;\nexport function isPipelineTopicExpression<\n  Opts extends Options<t.PipelineTopicExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"PipelineTopicExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPipelineBareFunction(\n  node: t.Node | null | undefined,\n): node is t.PipelineBareFunction;\nexport function isPipelineBareFunction<\n  Opts extends Options<t.PipelineBareFunction>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.PipelineBareFunction & Opts;\nexport function isPipelineBareFunction<\n  Opts extends Options<t.PipelineBareFunction>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"PipelineBareFunction\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPipelinePrimaryTopicReference(\n  node: t.Node | null | undefined,\n): node is t.PipelinePrimaryTopicReference;\nexport function isPipelinePrimaryTopicReference<\n  Opts extends Options<t.PipelinePrimaryTopicReference>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.PipelinePrimaryTopicReference & Opts;\nexport function isPipelinePrimaryTopicReference<\n  Opts extends Options<t.PipelinePrimaryTopicReference>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"PipelinePrimaryTopicReference\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isVoidPattern(\n  node: t.Node | null | undefined,\n): node is t.VoidPattern;\nexport function isVoidPattern<Opts extends Options<t.VoidPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.VoidPattern & Opts;\nexport function isVoidPattern<Opts extends Options<t.VoidPattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"VoidPattern\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSParameterProperty(\n  node: t.Node | null | undefined,\n): node is t.TSParameterProperty;\nexport function isTSParameterProperty<\n  Opts extends Options<t.TSParameterProperty>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSParameterProperty & Opts;\nexport function isTSParameterProperty<\n  Opts extends Options<t.TSParameterProperty>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSParameterProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSDeclareFunction(\n  node: t.Node | null | undefined,\n): node is t.TSDeclareFunction;\nexport function isTSDeclareFunction<Opts extends Options<t.TSDeclareFunction>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSDeclareFunction & Opts;\nexport function isTSDeclareFunction<Opts extends Options<t.TSDeclareFunction>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSDeclareFunction\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSDeclareMethod(\n  node: t.Node | null | undefined,\n): node is t.TSDeclareMethod;\nexport function isTSDeclareMethod<Opts extends Options<t.TSDeclareMethod>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSDeclareMethod & Opts;\nexport function isTSDeclareMethod<Opts extends Options<t.TSDeclareMethod>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSDeclareMethod\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSQualifiedName(\n  node: t.Node | null | undefined,\n): node is t.TSQualifiedName;\nexport function isTSQualifiedName<Opts extends Options<t.TSQualifiedName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSQualifiedName & Opts;\nexport function isTSQualifiedName<Opts extends Options<t.TSQualifiedName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSQualifiedName\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSCallSignatureDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSCallSignatureDeclaration;\nexport function isTSCallSignatureDeclaration<\n  Opts extends Options<t.TSCallSignatureDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSCallSignatureDeclaration & Opts;\nexport function isTSCallSignatureDeclaration<\n  Opts extends Options<t.TSCallSignatureDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSCallSignatureDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSConstructSignatureDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSConstructSignatureDeclaration;\nexport function isTSConstructSignatureDeclaration<\n  Opts extends Options<t.TSConstructSignatureDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSConstructSignatureDeclaration & Opts;\nexport function isTSConstructSignatureDeclaration<\n  Opts extends Options<t.TSConstructSignatureDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSConstructSignatureDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSPropertySignature(\n  node: t.Node | null | undefined,\n): node is t.TSPropertySignature;\nexport function isTSPropertySignature<\n  Opts extends Options<t.TSPropertySignature>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSPropertySignature & Opts;\nexport function isTSPropertySignature<\n  Opts extends Options<t.TSPropertySignature>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSPropertySignature\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSMethodSignature(\n  node: t.Node | null | undefined,\n): node is t.TSMethodSignature;\nexport function isTSMethodSignature<Opts extends Options<t.TSMethodSignature>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSMethodSignature & Opts;\nexport function isTSMethodSignature<Opts extends Options<t.TSMethodSignature>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSMethodSignature\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSIndexSignature(\n  node: t.Node | null | undefined,\n): node is t.TSIndexSignature;\nexport function isTSIndexSignature<Opts extends Options<t.TSIndexSignature>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSIndexSignature & Opts;\nexport function isTSIndexSignature<Opts extends Options<t.TSIndexSignature>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSIndexSignature\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSAnyKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSAnyKeyword;\nexport function isTSAnyKeyword<Opts extends Options<t.TSAnyKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSAnyKeyword & Opts;\nexport function isTSAnyKeyword<Opts extends Options<t.TSAnyKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSAnyKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSBooleanKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSBooleanKeyword;\nexport function isTSBooleanKeyword<Opts extends Options<t.TSBooleanKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSBooleanKeyword & Opts;\nexport function isTSBooleanKeyword<Opts extends Options<t.TSBooleanKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSBooleanKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSBigIntKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSBigIntKeyword;\nexport function isTSBigIntKeyword<Opts extends Options<t.TSBigIntKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSBigIntKeyword & Opts;\nexport function isTSBigIntKeyword<Opts extends Options<t.TSBigIntKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSBigIntKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSIntrinsicKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSIntrinsicKeyword;\nexport function isTSIntrinsicKeyword<\n  Opts extends Options<t.TSIntrinsicKeyword>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSIntrinsicKeyword & Opts;\nexport function isTSIntrinsicKeyword<\n  Opts extends Options<t.TSIntrinsicKeyword>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSIntrinsicKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNeverKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSNeverKeyword;\nexport function isTSNeverKeyword<Opts extends Options<t.TSNeverKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSNeverKeyword & Opts;\nexport function isTSNeverKeyword<Opts extends Options<t.TSNeverKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSNeverKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNullKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSNullKeyword;\nexport function isTSNullKeyword<Opts extends Options<t.TSNullKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSNullKeyword & Opts;\nexport function isTSNullKeyword<Opts extends Options<t.TSNullKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSNullKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNumberKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSNumberKeyword;\nexport function isTSNumberKeyword<Opts extends Options<t.TSNumberKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSNumberKeyword & Opts;\nexport function isTSNumberKeyword<Opts extends Options<t.TSNumberKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSNumberKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSObjectKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSObjectKeyword;\nexport function isTSObjectKeyword<Opts extends Options<t.TSObjectKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSObjectKeyword & Opts;\nexport function isTSObjectKeyword<Opts extends Options<t.TSObjectKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSObjectKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSStringKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSStringKeyword;\nexport function isTSStringKeyword<Opts extends Options<t.TSStringKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSStringKeyword & Opts;\nexport function isTSStringKeyword<Opts extends Options<t.TSStringKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSStringKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSSymbolKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSSymbolKeyword;\nexport function isTSSymbolKeyword<Opts extends Options<t.TSSymbolKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSSymbolKeyword & Opts;\nexport function isTSSymbolKeyword<Opts extends Options<t.TSSymbolKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSSymbolKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSUndefinedKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSUndefinedKeyword;\nexport function isTSUndefinedKeyword<\n  Opts extends Options<t.TSUndefinedKeyword>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSUndefinedKeyword & Opts;\nexport function isTSUndefinedKeyword<\n  Opts extends Options<t.TSUndefinedKeyword>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSUndefinedKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSUnknownKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSUnknownKeyword;\nexport function isTSUnknownKeyword<Opts extends Options<t.TSUnknownKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSUnknownKeyword & Opts;\nexport function isTSUnknownKeyword<Opts extends Options<t.TSUnknownKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSUnknownKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSVoidKeyword(\n  node: t.Node | null | undefined,\n): node is t.TSVoidKeyword;\nexport function isTSVoidKeyword<Opts extends Options<t.TSVoidKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSVoidKeyword & Opts;\nexport function isTSVoidKeyword<Opts extends Options<t.TSVoidKeyword>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSVoidKeyword\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSThisType(\n  node: t.Node | null | undefined,\n): node is t.TSThisType;\nexport function isTSThisType<Opts extends Options<t.TSThisType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSThisType & Opts;\nexport function isTSThisType<Opts extends Options<t.TSThisType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSThisType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSFunctionType(\n  node: t.Node | null | undefined,\n): node is t.TSFunctionType;\nexport function isTSFunctionType<Opts extends Options<t.TSFunctionType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSFunctionType & Opts;\nexport function isTSFunctionType<Opts extends Options<t.TSFunctionType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSFunctionType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSConstructorType(\n  node: t.Node | null | undefined,\n): node is t.TSConstructorType;\nexport function isTSConstructorType<Opts extends Options<t.TSConstructorType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSConstructorType & Opts;\nexport function isTSConstructorType<Opts extends Options<t.TSConstructorType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSConstructorType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeReference(\n  node: t.Node | null | undefined,\n): node is t.TSTypeReference;\nexport function isTSTypeReference<Opts extends Options<t.TSTypeReference>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeReference & Opts;\nexport function isTSTypeReference<Opts extends Options<t.TSTypeReference>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeReference\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypePredicate(\n  node: t.Node | null | undefined,\n): node is t.TSTypePredicate;\nexport function isTSTypePredicate<Opts extends Options<t.TSTypePredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypePredicate & Opts;\nexport function isTSTypePredicate<Opts extends Options<t.TSTypePredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypePredicate\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeQuery(\n  node: t.Node | null | undefined,\n): node is t.TSTypeQuery;\nexport function isTSTypeQuery<Opts extends Options<t.TSTypeQuery>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeQuery & Opts;\nexport function isTSTypeQuery<Opts extends Options<t.TSTypeQuery>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeQuery\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeLiteral(\n  node: t.Node | null | undefined,\n): node is t.TSTypeLiteral;\nexport function isTSTypeLiteral<Opts extends Options<t.TSTypeLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeLiteral & Opts;\nexport function isTSTypeLiteral<Opts extends Options<t.TSTypeLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSArrayType(\n  node: t.Node | null | undefined,\n): node is t.TSArrayType;\nexport function isTSArrayType<Opts extends Options<t.TSArrayType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSArrayType & Opts;\nexport function isTSArrayType<Opts extends Options<t.TSArrayType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSArrayType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTupleType(\n  node: t.Node | null | undefined,\n): node is t.TSTupleType;\nexport function isTSTupleType<Opts extends Options<t.TSTupleType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTupleType & Opts;\nexport function isTSTupleType<Opts extends Options<t.TSTupleType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTupleType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSOptionalType(\n  node: t.Node | null | undefined,\n): node is t.TSOptionalType;\nexport function isTSOptionalType<Opts extends Options<t.TSOptionalType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSOptionalType & Opts;\nexport function isTSOptionalType<Opts extends Options<t.TSOptionalType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSOptionalType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSRestType(\n  node: t.Node | null | undefined,\n): node is t.TSRestType;\nexport function isTSRestType<Opts extends Options<t.TSRestType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSRestType & Opts;\nexport function isTSRestType<Opts extends Options<t.TSRestType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSRestType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNamedTupleMember(\n  node: t.Node | null | undefined,\n): node is t.TSNamedTupleMember;\nexport function isTSNamedTupleMember<\n  Opts extends Options<t.TSNamedTupleMember>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSNamedTupleMember & Opts;\nexport function isTSNamedTupleMember<\n  Opts extends Options<t.TSNamedTupleMember>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSNamedTupleMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSUnionType(\n  node: t.Node | null | undefined,\n): node is t.TSUnionType;\nexport function isTSUnionType<Opts extends Options<t.TSUnionType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSUnionType & Opts;\nexport function isTSUnionType<Opts extends Options<t.TSUnionType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSUnionType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSIntersectionType(\n  node: t.Node | null | undefined,\n): node is t.TSIntersectionType;\nexport function isTSIntersectionType<\n  Opts extends Options<t.TSIntersectionType>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSIntersectionType & Opts;\nexport function isTSIntersectionType<\n  Opts extends Options<t.TSIntersectionType>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSIntersectionType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSConditionalType(\n  node: t.Node | null | undefined,\n): node is t.TSConditionalType;\nexport function isTSConditionalType<Opts extends Options<t.TSConditionalType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSConditionalType & Opts;\nexport function isTSConditionalType<Opts extends Options<t.TSConditionalType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSConditionalType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSInferType(\n  node: t.Node | null | undefined,\n): node is t.TSInferType;\nexport function isTSInferType<Opts extends Options<t.TSInferType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSInferType & Opts;\nexport function isTSInferType<Opts extends Options<t.TSInferType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSInferType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSParenthesizedType(\n  node: t.Node | null | undefined,\n): node is t.TSParenthesizedType;\nexport function isTSParenthesizedType<\n  Opts extends Options<t.TSParenthesizedType>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSParenthesizedType & Opts;\nexport function isTSParenthesizedType<\n  Opts extends Options<t.TSParenthesizedType>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSParenthesizedType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeOperator(\n  node: t.Node | null | undefined,\n): node is t.TSTypeOperator;\nexport function isTSTypeOperator<Opts extends Options<t.TSTypeOperator>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeOperator & Opts;\nexport function isTSTypeOperator<Opts extends Options<t.TSTypeOperator>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeOperator\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSIndexedAccessType(\n  node: t.Node | null | undefined,\n): node is t.TSIndexedAccessType;\nexport function isTSIndexedAccessType<\n  Opts extends Options<t.TSIndexedAccessType>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSIndexedAccessType & Opts;\nexport function isTSIndexedAccessType<\n  Opts extends Options<t.TSIndexedAccessType>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSIndexedAccessType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSMappedType(\n  node: t.Node | null | undefined,\n): node is t.TSMappedType;\nexport function isTSMappedType<Opts extends Options<t.TSMappedType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSMappedType & Opts;\nexport function isTSMappedType<Opts extends Options<t.TSMappedType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSMappedType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTemplateLiteralType(\n  node: t.Node | null | undefined,\n): node is t.TSTemplateLiteralType;\nexport function isTSTemplateLiteralType<\n  Opts extends Options<t.TSTemplateLiteralType>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTemplateLiteralType & Opts;\nexport function isTSTemplateLiteralType<\n  Opts extends Options<t.TSTemplateLiteralType>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTemplateLiteralType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSLiteralType(\n  node: t.Node | null | undefined,\n): node is t.TSLiteralType;\nexport function isTSLiteralType<Opts extends Options<t.TSLiteralType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSLiteralType & Opts;\nexport function isTSLiteralType<Opts extends Options<t.TSLiteralType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSLiteralType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSExpressionWithTypeArguments(\n  node: t.Node | null | undefined,\n): node is t.TSExpressionWithTypeArguments;\nexport function isTSExpressionWithTypeArguments<\n  Opts extends Options<t.TSExpressionWithTypeArguments>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSExpressionWithTypeArguments & Opts;\nexport function isTSExpressionWithTypeArguments<\n  Opts extends Options<t.TSExpressionWithTypeArguments>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSExpressionWithTypeArguments\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSInterfaceDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSInterfaceDeclaration;\nexport function isTSInterfaceDeclaration<\n  Opts extends Options<t.TSInterfaceDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSInterfaceDeclaration & Opts;\nexport function isTSInterfaceDeclaration<\n  Opts extends Options<t.TSInterfaceDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSInterfaceDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSInterfaceBody(\n  node: t.Node | null | undefined,\n): node is t.TSInterfaceBody;\nexport function isTSInterfaceBody<Opts extends Options<t.TSInterfaceBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSInterfaceBody & Opts;\nexport function isTSInterfaceBody<Opts extends Options<t.TSInterfaceBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSInterfaceBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeAliasDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSTypeAliasDeclaration;\nexport function isTSTypeAliasDeclaration<\n  Opts extends Options<t.TSTypeAliasDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeAliasDeclaration & Opts;\nexport function isTSTypeAliasDeclaration<\n  Opts extends Options<t.TSTypeAliasDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeAliasDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSInstantiationExpression(\n  node: t.Node | null | undefined,\n): node is t.TSInstantiationExpression;\nexport function isTSInstantiationExpression<\n  Opts extends Options<t.TSInstantiationExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSInstantiationExpression & Opts;\nexport function isTSInstantiationExpression<\n  Opts extends Options<t.TSInstantiationExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSInstantiationExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSAsExpression(\n  node: t.Node | null | undefined,\n): node is t.TSAsExpression;\nexport function isTSAsExpression<Opts extends Options<t.TSAsExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSAsExpression & Opts;\nexport function isTSAsExpression<Opts extends Options<t.TSAsExpression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSAsExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSSatisfiesExpression(\n  node: t.Node | null | undefined,\n): node is t.TSSatisfiesExpression;\nexport function isTSSatisfiesExpression<\n  Opts extends Options<t.TSSatisfiesExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSSatisfiesExpression & Opts;\nexport function isTSSatisfiesExpression<\n  Opts extends Options<t.TSSatisfiesExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSSatisfiesExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeAssertion(\n  node: t.Node | null | undefined,\n): node is t.TSTypeAssertion;\nexport function isTSTypeAssertion<Opts extends Options<t.TSTypeAssertion>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeAssertion & Opts;\nexport function isTSTypeAssertion<Opts extends Options<t.TSTypeAssertion>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeAssertion\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSEnumBody(\n  node: t.Node | null | undefined,\n): node is t.TSEnumBody;\nexport function isTSEnumBody<Opts extends Options<t.TSEnumBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSEnumBody & Opts;\nexport function isTSEnumBody<Opts extends Options<t.TSEnumBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSEnumBody\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSEnumDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSEnumDeclaration;\nexport function isTSEnumDeclaration<Opts extends Options<t.TSEnumDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSEnumDeclaration & Opts;\nexport function isTSEnumDeclaration<Opts extends Options<t.TSEnumDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSEnumDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSEnumMember(\n  node: t.Node | null | undefined,\n): node is t.TSEnumMember;\nexport function isTSEnumMember<Opts extends Options<t.TSEnumMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSEnumMember & Opts;\nexport function isTSEnumMember<Opts extends Options<t.TSEnumMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSEnumMember\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSModuleDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSModuleDeclaration;\nexport function isTSModuleDeclaration<\n  Opts extends Options<t.TSModuleDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSModuleDeclaration & Opts;\nexport function isTSModuleDeclaration<\n  Opts extends Options<t.TSModuleDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSModuleDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSModuleBlock(\n  node: t.Node | null | undefined,\n): node is t.TSModuleBlock;\nexport function isTSModuleBlock<Opts extends Options<t.TSModuleBlock>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSModuleBlock & Opts;\nexport function isTSModuleBlock<Opts extends Options<t.TSModuleBlock>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSModuleBlock\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSImportType(\n  node: t.Node | null | undefined,\n): node is t.TSImportType;\nexport function isTSImportType<Opts extends Options<t.TSImportType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSImportType & Opts;\nexport function isTSImportType<Opts extends Options<t.TSImportType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSImportType\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSImportEqualsDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSImportEqualsDeclaration;\nexport function isTSImportEqualsDeclaration<\n  Opts extends Options<t.TSImportEqualsDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSImportEqualsDeclaration & Opts;\nexport function isTSImportEqualsDeclaration<\n  Opts extends Options<t.TSImportEqualsDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSImportEqualsDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSExternalModuleReference(\n  node: t.Node | null | undefined,\n): node is t.TSExternalModuleReference;\nexport function isTSExternalModuleReference<\n  Opts extends Options<t.TSExternalModuleReference>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSExternalModuleReference & Opts;\nexport function isTSExternalModuleReference<\n  Opts extends Options<t.TSExternalModuleReference>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSExternalModuleReference\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNonNullExpression(\n  node: t.Node | null | undefined,\n): node is t.TSNonNullExpression;\nexport function isTSNonNullExpression<\n  Opts extends Options<t.TSNonNullExpression>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSNonNullExpression & Opts;\nexport function isTSNonNullExpression<\n  Opts extends Options<t.TSNonNullExpression>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSNonNullExpression\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSExportAssignment(\n  node: t.Node | null | undefined,\n): node is t.TSExportAssignment;\nexport function isTSExportAssignment<\n  Opts extends Options<t.TSExportAssignment>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSExportAssignment & Opts;\nexport function isTSExportAssignment<\n  Opts extends Options<t.TSExportAssignment>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSExportAssignment\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSNamespaceExportDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSNamespaceExportDeclaration;\nexport function isTSNamespaceExportDeclaration<\n  Opts extends Options<t.TSNamespaceExportDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSNamespaceExportDeclaration & Opts;\nexport function isTSNamespaceExportDeclaration<\n  Opts extends Options<t.TSNamespaceExportDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSNamespaceExportDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeAnnotation(\n  node: t.Node | null | undefined,\n): node is t.TSTypeAnnotation;\nexport function isTSTypeAnnotation<Opts extends Options<t.TSTypeAnnotation>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeAnnotation & Opts;\nexport function isTSTypeAnnotation<Opts extends Options<t.TSTypeAnnotation>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeAnnotation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeParameterInstantiation(\n  node: t.Node | null | undefined,\n): node is t.TSTypeParameterInstantiation;\nexport function isTSTypeParameterInstantiation<\n  Opts extends Options<t.TSTypeParameterInstantiation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeParameterInstantiation & Opts;\nexport function isTSTypeParameterInstantiation<\n  Opts extends Options<t.TSTypeParameterInstantiation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeParameterInstantiation\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeParameterDeclaration(\n  node: t.Node | null | undefined,\n): node is t.TSTypeParameterDeclaration;\nexport function isTSTypeParameterDeclaration<\n  Opts extends Options<t.TSTypeParameterDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeParameterDeclaration & Opts;\nexport function isTSTypeParameterDeclaration<\n  Opts extends Options<t.TSTypeParameterDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeParameterDeclaration\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeParameter(\n  node: t.Node | null | undefined,\n): node is t.TSTypeParameter;\nexport function isTSTypeParameter<Opts extends Options<t.TSTypeParameter>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeParameter & Opts;\nexport function isTSTypeParameter<Opts extends Options<t.TSTypeParameter>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  if (node.type !== \"TSTypeParameter\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStandardized(\n  node: t.Node | null | undefined,\n): node is t.Standardized;\nexport function isStandardized<Opts extends Options<t.Standardized>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Standardized & Opts;\nexport function isStandardized<Opts extends Options<t.Standardized>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ArrayExpression\":\n    case \"AssignmentExpression\":\n    case \"BinaryExpression\":\n    case \"InterpreterDirective\":\n    case \"Directive\":\n    case \"DirectiveLiteral\":\n    case \"BlockStatement\":\n    case \"BreakStatement\":\n    case \"CallExpression\":\n    case \"CatchClause\":\n    case \"ConditionalExpression\":\n    case \"ContinueStatement\":\n    case \"DebuggerStatement\":\n    case \"DoWhileStatement\":\n    case \"EmptyStatement\":\n    case \"ExpressionStatement\":\n    case \"File\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"Identifier\":\n    case \"IfStatement\":\n    case \"LabeledStatement\":\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"LogicalExpression\":\n    case \"MemberExpression\":\n    case \"NewExpression\":\n    case \"Program\":\n    case \"ObjectExpression\":\n    case \"ObjectMethod\":\n    case \"ObjectProperty\":\n    case \"RestElement\":\n    case \"ReturnStatement\":\n    case \"SequenceExpression\":\n    case \"ParenthesizedExpression\":\n    case \"SwitchCase\":\n    case \"SwitchStatement\":\n    case \"ThisExpression\":\n    case \"ThrowStatement\":\n    case \"TryStatement\":\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n    case \"VariableDeclaration\":\n    case \"VariableDeclarator\":\n    case \"WhileStatement\":\n    case \"WithStatement\":\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassBody\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ExportSpecifier\":\n    case \"ForOfStatement\":\n    case \"ImportDeclaration\":\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n    case \"ImportExpression\":\n    case \"MetaProperty\":\n    case \"ClassMethod\":\n    case \"ObjectPattern\":\n    case \"SpreadElement\":\n    case \"Super\":\n    case \"TaggedTemplateExpression\":\n    case \"TemplateElement\":\n    case \"TemplateLiteral\":\n    case \"YieldExpression\":\n    case \"AwaitExpression\":\n    case \"Import\":\n    case \"BigIntLiteral\":\n    case \"ExportNamespaceSpecifier\":\n    case \"OptionalMemberExpression\":\n    case \"OptionalCallExpression\":\n    case \"ClassProperty\":\n    case \"ClassAccessorProperty\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n    case \"PrivateName\":\n    case \"StaticBlock\":\n    case \"ImportAttribute\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Identifier\":\n        case \"StringLiteral\":\n        case \"BlockStatement\":\n        case \"ClassBody\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExpression(\n  node: t.Node | null | undefined,\n): node is t.Expression;\nexport function isExpression<Opts extends Options<t.Expression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Expression & Opts;\nexport function isExpression<Opts extends Options<t.Expression>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ArrayExpression\":\n    case \"AssignmentExpression\":\n    case \"BinaryExpression\":\n    case \"CallExpression\":\n    case \"ConditionalExpression\":\n    case \"FunctionExpression\":\n    case \"Identifier\":\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"LogicalExpression\":\n    case \"MemberExpression\":\n    case \"NewExpression\":\n    case \"ObjectExpression\":\n    case \"SequenceExpression\":\n    case \"ParenthesizedExpression\":\n    case \"ThisExpression\":\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassExpression\":\n    case \"ImportExpression\":\n    case \"MetaProperty\":\n    case \"Super\":\n    case \"TaggedTemplateExpression\":\n    case \"TemplateLiteral\":\n    case \"YieldExpression\":\n    case \"AwaitExpression\":\n    case \"Import\":\n    case \"BigIntLiteral\":\n    case \"OptionalMemberExpression\":\n    case \"OptionalCallExpression\":\n    case \"TypeCastExpression\":\n    case \"JSXElement\":\n    case \"JSXFragment\":\n    case \"BindExpression\":\n    case \"DoExpression\":\n    case \"RecordExpression\":\n    case \"TupleExpression\":\n    case \"DecimalLiteral\":\n    case \"ModuleExpression\":\n    case \"TopicReference\":\n    case \"PipelineTopicExpression\":\n    case \"PipelineBareFunction\":\n    case \"PipelinePrimaryTopicReference\":\n    case \"TSInstantiationExpression\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSNonNullExpression\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Expression\":\n        case \"Identifier\":\n        case \"StringLiteral\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBinary(node: t.Node | null | undefined): node is t.Binary;\nexport function isBinary<Opts extends Options<t.Binary>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Binary & Opts;\nexport function isBinary<Opts extends Options<t.Binary>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BinaryExpression\":\n    case \"LogicalExpression\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isScopable(node: t.Node | null | undefined): node is t.Scopable;\nexport function isScopable<Opts extends Options<t.Scopable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Scopable & Opts;\nexport function isScopable<Opts extends Options<t.Scopable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"CatchClause\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"Program\":\n    case \"ObjectMethod\":\n    case \"SwitchStatement\":\n    case \"WhileStatement\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n    case \"ForOfStatement\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"StaticBlock\":\n    case \"TSModuleBlock\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"BlockStatement\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBlockParent(\n  node: t.Node | null | undefined,\n): node is t.BlockParent;\nexport function isBlockParent<Opts extends Options<t.BlockParent>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.BlockParent & Opts;\nexport function isBlockParent<Opts extends Options<t.BlockParent>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"CatchClause\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"Program\":\n    case \"ObjectMethod\":\n    case \"SwitchStatement\":\n    case \"WhileStatement\":\n    case \"ArrowFunctionExpression\":\n    case \"ForOfStatement\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"StaticBlock\":\n    case \"TSModuleBlock\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"BlockStatement\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isBlock(node: t.Node | null | undefined): node is t.Block;\nexport function isBlock<Opts extends Options<t.Block>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Block & Opts;\nexport function isBlock<Opts extends Options<t.Block>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"Program\":\n    case \"TSModuleBlock\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"BlockStatement\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isStatement(\n  node: t.Node | null | undefined,\n): node is t.Statement;\nexport function isStatement<Opts extends Options<t.Statement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Statement & Opts;\nexport function isStatement<Opts extends Options<t.Statement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BlockStatement\":\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"DebuggerStatement\":\n    case \"DoWhileStatement\":\n    case \"EmptyStatement\":\n    case \"ExpressionStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"FunctionDeclaration\":\n    case \"IfStatement\":\n    case \"LabeledStatement\":\n    case \"ReturnStatement\":\n    case \"SwitchStatement\":\n    case \"ThrowStatement\":\n    case \"TryStatement\":\n    case \"VariableDeclaration\":\n    case \"WhileStatement\":\n    case \"WithStatement\":\n    case \"ClassDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ForOfStatement\":\n    case \"ImportDeclaration\":\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"InterfaceDeclaration\":\n    case \"OpaqueType\":\n    case \"TypeAlias\":\n    case \"EnumDeclaration\":\n    case \"TSDeclareFunction\":\n    case \"TSInterfaceDeclaration\":\n    case \"TSTypeAliasDeclaration\":\n    case \"TSEnumDeclaration\":\n    case \"TSModuleDeclaration\":\n    case \"TSImportEqualsDeclaration\":\n    case \"TSExportAssignment\":\n    case \"TSNamespaceExportDeclaration\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Statement\":\n        case \"Declaration\":\n        case \"BlockStatement\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTerminatorless(\n  node: t.Node | null | undefined,\n): node is t.Terminatorless;\nexport function isTerminatorless<Opts extends Options<t.Terminatorless>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Terminatorless & Opts;\nexport function isTerminatorless<Opts extends Options<t.Terminatorless>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"ReturnStatement\":\n    case \"ThrowStatement\":\n    case \"YieldExpression\":\n    case \"AwaitExpression\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isCompletionStatement(\n  node: t.Node | null | undefined,\n): node is t.CompletionStatement;\nexport function isCompletionStatement<\n  Opts extends Options<t.CompletionStatement>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.CompletionStatement & Opts;\nexport function isCompletionStatement<\n  Opts extends Options<t.CompletionStatement>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"BreakStatement\":\n    case \"ContinueStatement\":\n    case \"ReturnStatement\":\n    case \"ThrowStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isConditional(\n  node: t.Node | null | undefined,\n): node is t.Conditional;\nexport function isConditional<Opts extends Options<t.Conditional>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Conditional & Opts;\nexport function isConditional<Opts extends Options<t.Conditional>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isLoop(node: t.Node | null | undefined): node is t.Loop;\nexport function isLoop<Opts extends Options<t.Loop>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Loop & Opts;\nexport function isLoop<Opts extends Options<t.Loop>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"WhileStatement\":\n    case \"ForOfStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isWhile(node: t.Node | null | undefined): node is t.While;\nexport function isWhile<Opts extends Options<t.While>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.While & Opts;\nexport function isWhile<Opts extends Options<t.While>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"DoWhileStatement\":\n    case \"WhileStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExpressionWrapper(\n  node: t.Node | null | undefined,\n): node is t.ExpressionWrapper;\nexport function isExpressionWrapper<Opts extends Options<t.ExpressionWrapper>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExpressionWrapper & Opts;\nexport function isExpressionWrapper<Opts extends Options<t.ExpressionWrapper>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ExpressionStatement\":\n    case \"ParenthesizedExpression\":\n    case \"TypeCastExpression\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFor(node: t.Node | null | undefined): node is t.For;\nexport function isFor<Opts extends Options<t.For>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.For & Opts;\nexport function isFor<Opts extends Options<t.For>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ForInStatement\":\n    case \"ForStatement\":\n    case \"ForOfStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isForXStatement(\n  node: t.Node | null | undefined,\n): node is t.ForXStatement;\nexport function isForXStatement<Opts extends Options<t.ForXStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ForXStatement & Opts;\nexport function isForXStatement<Opts extends Options<t.ForXStatement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunction(node: t.Node | null | undefined): node is t.Function;\nexport function isFunction<Opts extends Options<t.Function>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Function & Opts;\nexport function isFunction<Opts extends Options<t.Function>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ObjectMethod\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionParent(\n  node: t.Node | null | undefined,\n): node is t.FunctionParent;\nexport function isFunctionParent<Opts extends Options<t.FunctionParent>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FunctionParent & Opts;\nexport function isFunctionParent<Opts extends Options<t.FunctionParent>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"ObjectMethod\":\n    case \"ArrowFunctionExpression\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n    case \"StaticBlock\":\n    case \"TSModuleBlock\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPureish(node: t.Node | null | undefined): node is t.Pureish;\nexport function isPureish<Opts extends Options<t.Pureish>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Pureish & Opts;\nexport function isPureish<Opts extends Options<t.Pureish>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"ArrowFunctionExpression\":\n    case \"BigIntLiteral\":\n    case \"DecimalLiteral\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"StringLiteral\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isDeclaration(\n  node: t.Node | null | undefined,\n): node is t.Declaration;\nexport function isDeclaration<Opts extends Options<t.Declaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Declaration & Opts;\nexport function isDeclaration<Opts extends Options<t.Declaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"FunctionDeclaration\":\n    case \"VariableDeclaration\":\n    case \"ClassDeclaration\":\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ImportDeclaration\":\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"InterfaceDeclaration\":\n    case \"OpaqueType\":\n    case \"TypeAlias\":\n    case \"EnumDeclaration\":\n    case \"TSDeclareFunction\":\n    case \"TSInterfaceDeclaration\":\n    case \"TSTypeAliasDeclaration\":\n    case \"TSEnumDeclaration\":\n    case \"TSModuleDeclaration\":\n    case \"TSImportEqualsDeclaration\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Declaration\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFunctionParameter(\n  node: t.Node | null | undefined,\n): node is t.FunctionParameter;\nexport function isFunctionParameter<Opts extends Options<t.FunctionParameter>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FunctionParameter & Opts;\nexport function isFunctionParameter<Opts extends Options<t.FunctionParameter>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"Identifier\":\n    case \"RestElement\":\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"VoidPattern\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Identifier\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPatternLike(\n  node: t.Node | null | undefined,\n): node is t.PatternLike;\nexport function isPatternLike<Opts extends Options<t.PatternLike>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.PatternLike & Opts;\nexport function isPatternLike<Opts extends Options<t.PatternLike>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\":\n    case \"RestElement\":\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"VoidPattern\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSNonNullExpression\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Pattern\":\n        case \"Identifier\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isLVal(node: t.Node | null | undefined): node is t.LVal;\nexport function isLVal<Opts extends Options<t.LVal>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.LVal & Opts;\nexport function isLVal<Opts extends Options<t.LVal>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"Identifier\":\n    case \"MemberExpression\":\n    case \"RestElement\":\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"TSParameterProperty\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSNonNullExpression\":\n      break;\n    case \"Placeholder\":\n      switch (node.expectedNode) {\n        case \"Pattern\":\n        case \"Identifier\":\n          break;\n        default:\n          return false;\n      }\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSEntityName(\n  node: t.Node | null | undefined,\n): node is t.TSEntityName;\nexport function isTSEntityName<Opts extends Options<t.TSEntityName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSEntityName & Opts;\nexport function isTSEntityName<Opts extends Options<t.TSEntityName>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"Identifier\":\n    case \"TSQualifiedName\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Identifier\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isLiteral(node: t.Node | null | undefined): node is t.Literal;\nexport function isLiteral<Opts extends Options<t.Literal>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Literal & Opts;\nexport function isLiteral<Opts extends Options<t.Literal>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"RegExpLiteral\":\n    case \"TemplateLiteral\":\n    case \"BigIntLiteral\":\n    case \"DecimalLiteral\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"StringLiteral\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImmutable(\n  node: t.Node | null | undefined,\n): node is t.Immutable;\nexport function isImmutable<Opts extends Options<t.Immutable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Immutable & Opts;\nexport function isImmutable<Opts extends Options<t.Immutable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"StringLiteral\":\n    case \"NumericLiteral\":\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"BigIntLiteral\":\n    case \"JSXAttribute\":\n    case \"JSXClosingElement\":\n    case \"JSXElement\":\n    case \"JSXExpressionContainer\":\n    case \"JSXSpreadChild\":\n    case \"JSXOpeningElement\":\n    case \"JSXText\":\n    case \"JSXFragment\":\n    case \"JSXOpeningFragment\":\n    case \"JSXClosingFragment\":\n    case \"DecimalLiteral\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"StringLiteral\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isUserWhitespacable(\n  node: t.Node | null | undefined,\n): node is t.UserWhitespacable;\nexport function isUserWhitespacable<Opts extends Options<t.UserWhitespacable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.UserWhitespacable & Opts;\nexport function isUserWhitespacable<Opts extends Options<t.UserWhitespacable>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ObjectMethod\":\n    case \"ObjectProperty\":\n    case \"ObjectTypeInternalSlot\":\n    case \"ObjectTypeCallProperty\":\n    case \"ObjectTypeIndexer\":\n    case \"ObjectTypeProperty\":\n    case \"ObjectTypeSpreadProperty\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isMethod(node: t.Node | null | undefined): node is t.Method;\nexport function isMethod<Opts extends Options<t.Method>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Method & Opts;\nexport function isMethod<Opts extends Options<t.Method>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ObjectMethod\":\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isObjectMember(\n  node: t.Node | null | undefined,\n): node is t.ObjectMember;\nexport function isObjectMember<Opts extends Options<t.ObjectMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ObjectMember & Opts;\nexport function isObjectMember<Opts extends Options<t.ObjectMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ObjectMethod\":\n    case \"ObjectProperty\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isProperty(node: t.Node | null | undefined): node is t.Property;\nexport function isProperty<Opts extends Options<t.Property>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Property & Opts;\nexport function isProperty<Opts extends Options<t.Property>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ObjectProperty\":\n    case \"ClassProperty\":\n    case \"ClassAccessorProperty\":\n    case \"ClassPrivateProperty\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isUnaryLike(\n  node: t.Node | null | undefined,\n): node is t.UnaryLike;\nexport function isUnaryLike<Opts extends Options<t.UnaryLike>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.UnaryLike & Opts;\nexport function isUnaryLike<Opts extends Options<t.UnaryLike>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"UnaryExpression\":\n    case \"SpreadElement\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPattern(node: t.Node | null | undefined): node is t.Pattern;\nexport function isPattern<Opts extends Options<t.Pattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Pattern & Opts;\nexport function isPattern<Opts extends Options<t.Pattern>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"AssignmentPattern\":\n    case \"ArrayPattern\":\n    case \"ObjectPattern\":\n    case \"VoidPattern\":\n      break;\n    case \"Placeholder\":\n      if (node.expectedNode === \"Pattern\") break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isClass(node: t.Node | null | undefined): node is t.Class;\nexport function isClass<Opts extends Options<t.Class>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Class & Opts;\nexport function isClass<Opts extends Options<t.Class>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isImportOrExportDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ImportOrExportDeclaration;\nexport function isImportOrExportDeclaration<\n  Opts extends Options<t.ImportOrExportDeclaration>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportOrExportDeclaration & Opts;\nexport function isImportOrExportDeclaration<\n  Opts extends Options<t.ImportOrExportDeclaration>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n    case \"ImportDeclaration\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isExportDeclaration(\n  node: t.Node | null | undefined,\n): node is t.ExportDeclaration;\nexport function isExportDeclaration<Opts extends Options<t.ExportDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ExportDeclaration & Opts;\nexport function isExportDeclaration<Opts extends Options<t.ExportDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ExportAllDeclaration\":\n    case \"ExportDefaultDeclaration\":\n    case \"ExportNamedDeclaration\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isModuleSpecifier(\n  node: t.Node | null | undefined,\n): node is t.ModuleSpecifier;\nexport function isModuleSpecifier<Opts extends Options<t.ModuleSpecifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ModuleSpecifier & Opts;\nexport function isModuleSpecifier<Opts extends Options<t.ModuleSpecifier>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ExportSpecifier\":\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n    case \"ExportNamespaceSpecifier\":\n    case \"ExportDefaultSpecifier\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isAccessor(node: t.Node | null | undefined): node is t.Accessor;\nexport function isAccessor<Opts extends Options<t.Accessor>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Accessor & Opts;\nexport function isAccessor<Opts extends Options<t.Accessor>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ClassAccessorProperty\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isPrivate(node: t.Node | null | undefined): node is t.Private;\nexport function isPrivate<Opts extends Options<t.Private>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Private & Opts;\nexport function isPrivate<Opts extends Options<t.Private>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n    case \"PrivateName\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFlow(node: t.Node | null | undefined): node is t.Flow;\nexport function isFlow<Opts extends Options<t.Flow>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Flow & Opts;\nexport function isFlow<Opts extends Options<t.Flow>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"AnyTypeAnnotation\":\n    case \"ArrayTypeAnnotation\":\n    case \"BooleanTypeAnnotation\":\n    case \"BooleanLiteralTypeAnnotation\":\n    case \"NullLiteralTypeAnnotation\":\n    case \"ClassImplements\":\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"DeclaredPredicate\":\n    case \"ExistsTypeAnnotation\":\n    case \"FunctionTypeAnnotation\":\n    case \"FunctionTypeParam\":\n    case \"GenericTypeAnnotation\":\n    case \"InferredPredicate\":\n    case \"InterfaceExtends\":\n    case \"InterfaceDeclaration\":\n    case \"InterfaceTypeAnnotation\":\n    case \"IntersectionTypeAnnotation\":\n    case \"MixedTypeAnnotation\":\n    case \"EmptyTypeAnnotation\":\n    case \"NullableTypeAnnotation\":\n    case \"NumberLiteralTypeAnnotation\":\n    case \"NumberTypeAnnotation\":\n    case \"ObjectTypeAnnotation\":\n    case \"ObjectTypeInternalSlot\":\n    case \"ObjectTypeCallProperty\":\n    case \"ObjectTypeIndexer\":\n    case \"ObjectTypeProperty\":\n    case \"ObjectTypeSpreadProperty\":\n    case \"OpaqueType\":\n    case \"QualifiedTypeIdentifier\":\n    case \"StringLiteralTypeAnnotation\":\n    case \"StringTypeAnnotation\":\n    case \"SymbolTypeAnnotation\":\n    case \"ThisTypeAnnotation\":\n    case \"TupleTypeAnnotation\":\n    case \"TypeofTypeAnnotation\":\n    case \"TypeAlias\":\n    case \"TypeAnnotation\":\n    case \"TypeCastExpression\":\n    case \"TypeParameter\":\n    case \"TypeParameterDeclaration\":\n    case \"TypeParameterInstantiation\":\n    case \"UnionTypeAnnotation\":\n    case \"Variance\":\n    case \"VoidTypeAnnotation\":\n    case \"EnumDeclaration\":\n    case \"EnumBooleanBody\":\n    case \"EnumNumberBody\":\n    case \"EnumStringBody\":\n    case \"EnumSymbolBody\":\n    case \"EnumBooleanMember\":\n    case \"EnumNumberMember\":\n    case \"EnumStringMember\":\n    case \"EnumDefaultedMember\":\n    case \"IndexedAccessType\":\n    case \"OptionalIndexedAccessType\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFlowType(node: t.Node | null | undefined): node is t.FlowType;\nexport function isFlowType<Opts extends Options<t.FlowType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FlowType & Opts;\nexport function isFlowType<Opts extends Options<t.FlowType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"AnyTypeAnnotation\":\n    case \"ArrayTypeAnnotation\":\n    case \"BooleanTypeAnnotation\":\n    case \"BooleanLiteralTypeAnnotation\":\n    case \"NullLiteralTypeAnnotation\":\n    case \"ExistsTypeAnnotation\":\n    case \"FunctionTypeAnnotation\":\n    case \"GenericTypeAnnotation\":\n    case \"InterfaceTypeAnnotation\":\n    case \"IntersectionTypeAnnotation\":\n    case \"MixedTypeAnnotation\":\n    case \"EmptyTypeAnnotation\":\n    case \"NullableTypeAnnotation\":\n    case \"NumberLiteralTypeAnnotation\":\n    case \"NumberTypeAnnotation\":\n    case \"ObjectTypeAnnotation\":\n    case \"StringLiteralTypeAnnotation\":\n    case \"StringTypeAnnotation\":\n    case \"SymbolTypeAnnotation\":\n    case \"ThisTypeAnnotation\":\n    case \"TupleTypeAnnotation\":\n    case \"TypeofTypeAnnotation\":\n    case \"UnionTypeAnnotation\":\n    case \"VoidTypeAnnotation\":\n    case \"IndexedAccessType\":\n    case \"OptionalIndexedAccessType\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFlowBaseAnnotation(\n  node: t.Node | null | undefined,\n): node is t.FlowBaseAnnotation;\nexport function isFlowBaseAnnotation<\n  Opts extends Options<t.FlowBaseAnnotation>,\n>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FlowBaseAnnotation & Opts;\nexport function isFlowBaseAnnotation<\n  Opts extends Options<t.FlowBaseAnnotation>,\n>(node: t.Node | null | undefined, opts?: Opts | null): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"AnyTypeAnnotation\":\n    case \"BooleanTypeAnnotation\":\n    case \"NullLiteralTypeAnnotation\":\n    case \"MixedTypeAnnotation\":\n    case \"EmptyTypeAnnotation\":\n    case \"NumberTypeAnnotation\":\n    case \"StringTypeAnnotation\":\n    case \"SymbolTypeAnnotation\":\n    case \"ThisTypeAnnotation\":\n    case \"VoidTypeAnnotation\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFlowDeclaration(\n  node: t.Node | null | undefined,\n): node is t.FlowDeclaration;\nexport function isFlowDeclaration<Opts extends Options<t.FlowDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FlowDeclaration & Opts;\nexport function isFlowDeclaration<Opts extends Options<t.FlowDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"DeclareClass\":\n    case \"DeclareFunction\":\n    case \"DeclareInterface\":\n    case \"DeclareModule\":\n    case \"DeclareModuleExports\":\n    case \"DeclareTypeAlias\":\n    case \"DeclareOpaqueType\":\n    case \"DeclareVariable\":\n    case \"DeclareExportDeclaration\":\n    case \"DeclareExportAllDeclaration\":\n    case \"InterfaceDeclaration\":\n    case \"OpaqueType\":\n    case \"TypeAlias\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isFlowPredicate(\n  node: t.Node | null | undefined,\n): node is t.FlowPredicate;\nexport function isFlowPredicate<Opts extends Options<t.FlowPredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.FlowPredicate & Opts;\nexport function isFlowPredicate<Opts extends Options<t.FlowPredicate>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"DeclaredPredicate\":\n    case \"InferredPredicate\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumBody(node: t.Node | null | undefined): node is t.EnumBody;\nexport function isEnumBody<Opts extends Options<t.EnumBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumBody & Opts;\nexport function isEnumBody<Opts extends Options<t.EnumBody>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"EnumBooleanBody\":\n    case \"EnumNumberBody\":\n    case \"EnumStringBody\":\n    case \"EnumSymbolBody\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isEnumMember(\n  node: t.Node | null | undefined,\n): node is t.EnumMember;\nexport function isEnumMember<Opts extends Options<t.EnumMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.EnumMember & Opts;\nexport function isEnumMember<Opts extends Options<t.EnumMember>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"EnumBooleanMember\":\n    case \"EnumNumberMember\":\n    case \"EnumStringMember\":\n    case \"EnumDefaultedMember\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isJSX(node: t.Node | null | undefined): node is t.JSX;\nexport function isJSX<Opts extends Options<t.JSX>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.JSX & Opts;\nexport function isJSX<Opts extends Options<t.JSX>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"JSXAttribute\":\n    case \"JSXClosingElement\":\n    case \"JSXElement\":\n    case \"JSXEmptyExpression\":\n    case \"JSXExpressionContainer\":\n    case \"JSXSpreadChild\":\n    case \"JSXIdentifier\":\n    case \"JSXMemberExpression\":\n    case \"JSXNamespacedName\":\n    case \"JSXOpeningElement\":\n    case \"JSXSpreadAttribute\":\n    case \"JSXText\":\n    case \"JSXFragment\":\n    case \"JSXOpeningFragment\":\n    case \"JSXClosingFragment\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isMiscellaneous(\n  node: t.Node | null | undefined,\n): node is t.Miscellaneous;\nexport function isMiscellaneous<Opts extends Options<t.Miscellaneous>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.Miscellaneous & Opts;\nexport function isMiscellaneous<Opts extends Options<t.Miscellaneous>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"Noop\":\n    case \"Placeholder\":\n    case \"V8IntrinsicIdentifier\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTypeScript(\n  node: t.Node | null | undefined,\n): node is t.TypeScript;\nexport function isTypeScript<Opts extends Options<t.TypeScript>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TypeScript & Opts;\nexport function isTypeScript<Opts extends Options<t.TypeScript>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"TSParameterProperty\":\n    case \"TSDeclareFunction\":\n    case \"TSDeclareMethod\":\n    case \"TSQualifiedName\":\n    case \"TSCallSignatureDeclaration\":\n    case \"TSConstructSignatureDeclaration\":\n    case \"TSPropertySignature\":\n    case \"TSMethodSignature\":\n    case \"TSIndexSignature\":\n    case \"TSAnyKeyword\":\n    case \"TSBooleanKeyword\":\n    case \"TSBigIntKeyword\":\n    case \"TSIntrinsicKeyword\":\n    case \"TSNeverKeyword\":\n    case \"TSNullKeyword\":\n    case \"TSNumberKeyword\":\n    case \"TSObjectKeyword\":\n    case \"TSStringKeyword\":\n    case \"TSSymbolKeyword\":\n    case \"TSUndefinedKeyword\":\n    case \"TSUnknownKeyword\":\n    case \"TSVoidKeyword\":\n    case \"TSThisType\":\n    case \"TSFunctionType\":\n    case \"TSConstructorType\":\n    case \"TSTypeReference\":\n    case \"TSTypePredicate\":\n    case \"TSTypeQuery\":\n    case \"TSTypeLiteral\":\n    case \"TSArrayType\":\n    case \"TSTupleType\":\n    case \"TSOptionalType\":\n    case \"TSRestType\":\n    case \"TSNamedTupleMember\":\n    case \"TSUnionType\":\n    case \"TSIntersectionType\":\n    case \"TSConditionalType\":\n    case \"TSInferType\":\n    case \"TSParenthesizedType\":\n    case \"TSTypeOperator\":\n    case \"TSIndexedAccessType\":\n    case \"TSMappedType\":\n    case \"TSTemplateLiteralType\":\n    case \"TSLiteralType\":\n    case \"TSExpressionWithTypeArguments\":\n    case \"TSInterfaceDeclaration\":\n    case \"TSInterfaceBody\":\n    case \"TSTypeAliasDeclaration\":\n    case \"TSInstantiationExpression\":\n    case \"TSAsExpression\":\n    case \"TSSatisfiesExpression\":\n    case \"TSTypeAssertion\":\n    case \"TSEnumBody\":\n    case \"TSEnumDeclaration\":\n    case \"TSEnumMember\":\n    case \"TSModuleDeclaration\":\n    case \"TSModuleBlock\":\n    case \"TSImportType\":\n    case \"TSImportEqualsDeclaration\":\n    case \"TSExternalModuleReference\":\n    case \"TSNonNullExpression\":\n    case \"TSExportAssignment\":\n    case \"TSNamespaceExportDeclaration\":\n    case \"TSTypeAnnotation\":\n    case \"TSTypeParameterInstantiation\":\n    case \"TSTypeParameterDeclaration\":\n    case \"TSTypeParameter\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSTypeElement(\n  node: t.Node | null | undefined,\n): node is t.TSTypeElement;\nexport function isTSTypeElement<Opts extends Options<t.TSTypeElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSTypeElement & Opts;\nexport function isTSTypeElement<Opts extends Options<t.TSTypeElement>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"TSCallSignatureDeclaration\":\n    case \"TSConstructSignatureDeclaration\":\n    case \"TSPropertySignature\":\n    case \"TSMethodSignature\":\n    case \"TSIndexSignature\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSType(node: t.Node | null | undefined): node is t.TSType;\nexport function isTSType<Opts extends Options<t.TSType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSType & Opts;\nexport function isTSType<Opts extends Options<t.TSType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"TSAnyKeyword\":\n    case \"TSBooleanKeyword\":\n    case \"TSBigIntKeyword\":\n    case \"TSIntrinsicKeyword\":\n    case \"TSNeverKeyword\":\n    case \"TSNullKeyword\":\n    case \"TSNumberKeyword\":\n    case \"TSObjectKeyword\":\n    case \"TSStringKeyword\":\n    case \"TSSymbolKeyword\":\n    case \"TSUndefinedKeyword\":\n    case \"TSUnknownKeyword\":\n    case \"TSVoidKeyword\":\n    case \"TSThisType\":\n    case \"TSFunctionType\":\n    case \"TSConstructorType\":\n    case \"TSTypeReference\":\n    case \"TSTypePredicate\":\n    case \"TSTypeQuery\":\n    case \"TSTypeLiteral\":\n    case \"TSArrayType\":\n    case \"TSTupleType\":\n    case \"TSOptionalType\":\n    case \"TSRestType\":\n    case \"TSUnionType\":\n    case \"TSIntersectionType\":\n    case \"TSConditionalType\":\n    case \"TSInferType\":\n    case \"TSParenthesizedType\":\n    case \"TSTypeOperator\":\n    case \"TSIndexedAccessType\":\n    case \"TSMappedType\":\n    case \"TSTemplateLiteralType\":\n    case \"TSLiteralType\":\n    case \"TSExpressionWithTypeArguments\":\n    case \"TSImportType\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\nexport function isTSBaseType(\n  node: t.Node | null | undefined,\n): node is t.TSBaseType;\nexport function isTSBaseType<Opts extends Options<t.TSBaseType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.TSBaseType & Opts;\nexport function isTSBaseType<Opts extends Options<t.TSBaseType>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  if (!node) return false;\n\n  switch (node.type) {\n    case \"TSAnyKeyword\":\n    case \"TSBooleanKeyword\":\n    case \"TSBigIntKeyword\":\n    case \"TSIntrinsicKeyword\":\n    case \"TSNeverKeyword\":\n    case \"TSNullKeyword\":\n    case \"TSNumberKeyword\":\n    case \"TSObjectKeyword\":\n    case \"TSStringKeyword\":\n    case \"TSSymbolKeyword\":\n    case \"TSUndefinedKeyword\":\n    case \"TSUnknownKeyword\":\n    case \"TSVoidKeyword\":\n    case \"TSThisType\":\n    case \"TSTemplateLiteralType\":\n    case \"TSLiteralType\":\n      break;\n    default:\n      return false;\n  }\n\n  return opts == null || shallowEqual(node, opts);\n}\n/**\n * @deprecated Use `isNumericLiteral`\n */\nexport function isNumberLiteral(node: t.Node | null | undefined): boolean;\nexport function isNumberLiteral<Opts extends Options<t.NumberLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean;\nexport function isNumberLiteral<Opts extends Options<t.NumberLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  deprecationWarning(\"isNumberLiteral\", \"isNumericLiteral\");\n  if (!node) return false;\n\n  if (node.type !== \"NumberLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\n/**\n * @deprecated Use `isRegExpLiteral`\n */\nexport function isRegexLiteral(node: t.Node | null | undefined): boolean;\nexport function isRegexLiteral<Opts extends Options<t.RegexLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean;\nexport function isRegexLiteral<Opts extends Options<t.RegexLiteral>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  deprecationWarning(\"isRegexLiteral\", \"isRegExpLiteral\");\n  if (!node) return false;\n\n  if (node.type !== \"RegexLiteral\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\n/**\n * @deprecated Use `isRestElement`\n */\nexport function isRestProperty(node: t.Node | null | undefined): boolean;\nexport function isRestProperty<Opts extends Options<t.RestProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean;\nexport function isRestProperty<Opts extends Options<t.RestProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  deprecationWarning(\"isRestProperty\", \"isRestElement\");\n  if (!node) return false;\n\n  if (node.type !== \"RestProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\n/**\n * @deprecated Use `isSpreadElement`\n */\nexport function isSpreadProperty(node: t.Node | null | undefined): boolean;\nexport function isSpreadProperty<Opts extends Options<t.SpreadProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean;\nexport function isSpreadProperty<Opts extends Options<t.SpreadProperty>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): boolean {\n  deprecationWarning(\"isSpreadProperty\", \"isSpreadElement\");\n  if (!node) return false;\n\n  if (node.type !== \"SpreadProperty\") return false;\n\n  return opts == null || shallowEqual(node, opts);\n}\n/**\n * @deprecated Use `isImportOrExportDeclaration`\n */\nexport function isModuleDeclaration<Opts extends Options<t.ModuleDeclaration>>(\n  node: t.Node | null | undefined,\n  opts?: Opts | null,\n): node is t.ImportOrExportDeclaration & Opts {\n  deprecationWarning(\"isModuleDeclaration\", \"isImportOrExportDeclaration\");\n  return isImportOrExportDeclaration(node, opts);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA,IAAAA,aAAA,GAAAC,OAAA;AAEA,IAAAC,mBAAA,GAAAD,OAAA;AAiBO,SAASE,iBAAiBA,CAC/BC,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASG,sBAAsBA,CAEpCJ,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,sBAAsB,EAAE,OAAO,KAAK;EAEtD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASI,kBAAkBA,CAChCL,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EAElD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASK,sBAAsBA,CAEpCN,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,sBAAsB,EAAE,OAAO,KAAK;EAEtD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASM,WAAWA,CACzBP,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,WAAW,EAAE,OAAO,KAAK;EAE3C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASO,kBAAkBA,CAChCR,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EAElD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASQ,gBAAgBA,CAC9BT,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASS,gBAAgBA,CAC9BV,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASU,gBAAgBA,CAC9BX,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASW,aAAaA,CAC3BZ,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,aAAa,EAAE,OAAO,KAAK;EAE7C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASY,uBAAuBA,CAErCb,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,uBAAuB,EAAE,OAAO,KAAK;EAEvD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASa,mBAAmBA,CACjCd,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,mBAAmB,EAAE,OAAO,KAAK;EAEnD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASc,mBAAmBA,CACjCf,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,mBAAmB,EAAE,OAAO,KAAK;EAEnD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASe,kBAAkBA,CAChChB,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EAElD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASgB,gBAAgBA,CAC9BjB,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASiB,qBAAqBA,CAEnClB,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,qBAAqB,EAAE,OAAO,KAAK;EAErD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAASkB,MAAMA,CACpBnB,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,MAAM,EAAE,OAAO,KAAK;EAEtC,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASmB,gBAAgBA,CAC9BpB,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASoB,cAAcA,CAC5BrB,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,cAAc,EAAE,OAAO,KAAK;EAE9C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASqB,qBAAqBA,CAEnCtB,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,qBAAqB,EAAE,OAAO,KAAK;EAErD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASsB,oBAAoBA,CAElCvB,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,oBAAoB,EAAE,OAAO,KAAK;EAEpD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASuB,YAAYA,CAC1BxB,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,YAAY,EAAE,OAAO,KAAK;EAE5C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASwB,aAAaA,CAC3BzB,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,aAAa,EAAE,OAAO,KAAK;EAE7C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASyB,kBAAkBA,CAChC1B,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EAElD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS0B,eAAeA,CAC7B3B,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,eAAe,EAAE,OAAO,KAAK;EAE/C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS2B,gBAAgBA,CAC9B5B,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS4B,aAAaA,CAC3B7B,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,aAAa,EAAE,OAAO,KAAK;EAE7C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS6B,gBAAgBA,CAC9B9B,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS8B,eAAeA,CAC7B/B,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,eAAe,EAAE,OAAO,KAAK;EAE/C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS+B,mBAAmBA,CACjChC,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,mBAAmB,EAAE,OAAO,KAAK;EAEnD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASgC,kBAAkBA,CAChCjC,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EAElD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASiC,eAAeA,CAC7BlC,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,eAAe,EAAE,OAAO,KAAK;EAE/C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAASkC,SAASA,CACvBnC,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,SAAS,EAAE,OAAO,KAAK;EAEzC,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASmC,kBAAkBA,CAChCpC,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EAElD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASoC,cAAcA,CAC5BrC,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,cAAc,EAAE,OAAO,KAAK;EAE9C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASqC,gBAAgBA,CAC9BtC,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASsC,aAAaA,CAC3BvC,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,aAAa,EAAE,OAAO,KAAK;EAE7C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASuC,iBAAiBA,CAC/BxC,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASwC,oBAAoBA,CAElCzC,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,oBAAoB,EAAE,OAAO,KAAK;EAEpD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASyC,yBAAyBA,CAEvC1C,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,yBAAyB,EAAE,OAAO,KAAK;EAEzD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS0C,YAAYA,CAC1B3C,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,YAAY,EAAE,OAAO,KAAK;EAE5C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS2C,iBAAiBA,CAC/B5C,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS4C,gBAAgBA,CAC9B7C,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS6C,gBAAgBA,CAC9B9C,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS8C,cAAcA,CAC5B/C,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,cAAc,EAAE,OAAO,KAAK;EAE9C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS+C,iBAAiBA,CAC/BhD,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASgD,kBAAkBA,CAChCjD,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EAElD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASiD,qBAAqBA,CAEnClD,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,qBAAqB,EAAE,OAAO,KAAK;EAErD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASkD,oBAAoBA,CAElCnD,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,oBAAoB,EAAE,OAAO,KAAK;EAEpD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASmD,gBAAgBA,CAC9BpD,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASoD,eAAeA,CAC7BrD,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,eAAe,EAAE,OAAO,KAAK;EAE/C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASqD,mBAAmBA,CACjCtD,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,mBAAmB,EAAE,OAAO,KAAK;EAEnD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASsD,cAAcA,CAC5BvD,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,cAAc,EAAE,OAAO,KAAK;EAE9C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASuD,yBAAyBA,CAEvCxD,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,yBAAyB,EAAE,OAAO,KAAK;EAEzD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASwD,WAAWA,CACzBzD,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,WAAW,EAAE,OAAO,KAAK;EAE3C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASyD,iBAAiBA,CAC/B1D,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS0D,kBAAkBA,CAChC3D,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EAElD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS2D,sBAAsBA,CAEpC5D,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,sBAAsB,EAAE,OAAO,KAAK;EAEtD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS4D,0BAA0BA,CAExC7D,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,0BAA0B,EAAE,OAAO,KAAK;EAE1D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS6D,wBAAwBA,CAEtC9D,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,wBAAwB,EAAE,OAAO,KAAK;EAExD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS8D,iBAAiBA,CAC/B/D,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS+D,gBAAgBA,CAC9BhE,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASgE,mBAAmBA,CACjCjE,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,mBAAmB,EAAE,OAAO,KAAK;EAEnD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASiE,wBAAwBA,CAEtClE,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,wBAAwB,EAAE,OAAO,KAAK;EAExD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASkE,0BAA0BA,CAExCnE,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,0BAA0B,EAAE,OAAO,KAAK;EAE1D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASmE,iBAAiBA,CAC/BpE,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASoE,kBAAkBA,CAChCrE,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EAElD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASqE,cAAcA,CAC5BtE,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,cAAc,EAAE,OAAO,KAAK;EAE9C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASsE,aAAaA,CAC3BvE,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,aAAa,EAAE,OAAO,KAAK;EAE7C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASuE,eAAeA,CAC7BxE,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,eAAe,EAAE,OAAO,KAAK;EAE/C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASwE,eAAeA,CAC7BzE,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,eAAe,EAAE,OAAO,KAAK;EAE/C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAASyE,OAAOA,CACrB1E,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,OAAO,EAAE,OAAO,KAAK;EAEvC,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS0E,0BAA0BA,CAExC3E,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,0BAA0B,EAAE,OAAO,KAAK;EAE1D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS2E,iBAAiBA,CAC/B5E,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS4E,iBAAiBA,CAC/B7E,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS6E,iBAAiBA,CAC/B9E,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS8E,iBAAiBA,CAC/B/E,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAAS+E,QAAQA,CACtBhF,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,QAAQ,EAAE,OAAO,KAAK;EAExC,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASgF,eAAeA,CAC7BjF,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,eAAe,EAAE,OAAO,KAAK;EAE/C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASiF,0BAA0BA,CAExClF,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,0BAA0B,EAAE,OAAO,KAAK;EAE1D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASkF,0BAA0BA,CAExCnF,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,0BAA0B,EAAE,OAAO,KAAK;EAE1D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASmF,wBAAwBA,CAEtCpF,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,wBAAwB,EAAE,OAAO,KAAK;EAExD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASoF,eAAeA,CAC7BrF,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,eAAe,EAAE,OAAO,KAAK;EAE/C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASqF,uBAAuBA,CAErCtF,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,uBAAuB,EAAE,OAAO,KAAK;EAEvD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASsF,sBAAsBA,CAEpCvF,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,sBAAsB,EAAE,OAAO,KAAK;EAEtD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASuF,oBAAoBA,CAElCxF,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,oBAAoB,EAAE,OAAO,KAAK;EAEpD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASwF,aAAaA,CAC3BzF,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,aAAa,EAAE,OAAO,KAAK;EAE7C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASyF,aAAaA,CAC3B1F,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,aAAa,EAAE,OAAO,KAAK;EAE7C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS0F,iBAAiBA,CAC/B3F,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS2F,mBAAmBA,CACjC5F,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,mBAAmB,EAAE,OAAO,KAAK;EAEnD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS4F,qBAAqBA,CAEnC7F,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,qBAAqB,EAAE,OAAO,KAAK;EAErD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS6F,uBAAuBA,CAErC9F,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,uBAAuB,EAAE,OAAO,KAAK;EAEvD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS8F,8BAA8BA,CAE5C/F,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,8BAA8B,EAAE,OAAO,KAAK;EAE9D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS+F,2BAA2BA,CAEzChG,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,2BAA2B,EAAE,OAAO,KAAK;EAE3D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASgG,iBAAiBA,CAC/BjG,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASiG,cAAcA,CAC5BlG,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,cAAc,EAAE,OAAO,KAAK;EAE9C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASkG,iBAAiBA,CAC/BnG,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASmG,kBAAkBA,CAChCpG,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EAElD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASoG,eAAeA,CAC7BrG,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,eAAe,EAAE,OAAO,KAAK;EAE/C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASqG,sBAAsBA,CAEpCtG,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,sBAAsB,EAAE,OAAO,KAAK;EAEtD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASsG,kBAAkBA,CAChCvG,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EAElD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASuG,mBAAmBA,CACjCxG,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,mBAAmB,EAAE,OAAO,KAAK;EAEnD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASwG,iBAAiBA,CAC/BzG,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASyG,0BAA0BA,CAExC1G,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,0BAA0B,EAAE,OAAO,KAAK;EAE1D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS0G,6BAA6BA,CAE3C3G,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,6BAA6B,EAAE,OAAO,KAAK;EAE7D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS2G,mBAAmBA,CACjC5G,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,mBAAmB,EAAE,OAAO,KAAK;EAEnD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS4G,sBAAsBA,CAEpC7G,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,sBAAsB,EAAE,OAAO,KAAK;EAEtD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS6G,wBAAwBA,CAEtC9G,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,wBAAwB,EAAE,OAAO,KAAK;EAExD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS8G,mBAAmBA,CACjC/G,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,mBAAmB,EAAE,OAAO,KAAK;EAEnD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS+G,uBAAuBA,CAErChH,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,uBAAuB,EAAE,OAAO,KAAK;EAEvD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASgH,mBAAmBA,CACjCjH,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,mBAAmB,EAAE,OAAO,KAAK;EAEnD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASiH,kBAAkBA,CAChClH,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EAElD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASkH,sBAAsBA,CAEpCnH,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,sBAAsB,EAAE,OAAO,KAAK;EAEtD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASmH,yBAAyBA,CAEvCpH,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,yBAAyB,EAAE,OAAO,KAAK;EAEzD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASoH,4BAA4BA,CAE1CrH,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,4BAA4B,EAAE,OAAO,KAAK;EAE5D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASqH,qBAAqBA,CAEnCtH,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,qBAAqB,EAAE,OAAO,KAAK;EAErD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASsH,qBAAqBA,CAEnCvH,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,qBAAqB,EAAE,OAAO,KAAK;EAErD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASuH,wBAAwBA,CAEtCxH,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,wBAAwB,EAAE,OAAO,KAAK;EAExD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASwH,6BAA6BA,CAE3CzH,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,6BAA6B,EAAE,OAAO,KAAK;EAE7D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASyH,sBAAsBA,CAEpC1H,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,sBAAsB,EAAE,OAAO,KAAK;EAEtD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS0H,sBAAsBA,CAEpC3H,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,sBAAsB,EAAE,OAAO,KAAK;EAEtD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS2H,wBAAwBA,CAEtC5H,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,wBAAwB,EAAE,OAAO,KAAK;EAExD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS4H,wBAAwBA,CAEtC7H,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,wBAAwB,EAAE,OAAO,KAAK;EAExD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS6H,mBAAmBA,CACjC9H,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,mBAAmB,EAAE,OAAO,KAAK;EAEnD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS8H,oBAAoBA,CAElC/H,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,oBAAoB,EAAE,OAAO,KAAK;EAEpD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS+H,0BAA0BA,CAExChI,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,0BAA0B,EAAE,OAAO,KAAK;EAE1D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASgI,YAAYA,CAC1BjI,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,YAAY,EAAE,OAAO,KAAK;EAE5C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASiI,yBAAyBA,CAEvClI,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,yBAAyB,EAAE,OAAO,KAAK;EAEzD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASkI,6BAA6BA,CAE3CnI,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,6BAA6B,EAAE,OAAO,KAAK;EAE7D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASmI,sBAAsBA,CAEpCpI,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,sBAAsB,EAAE,OAAO,KAAK;EAEtD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASoI,sBAAsBA,CAEpCrI,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,sBAAsB,EAAE,OAAO,KAAK;EAEtD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASqI,oBAAoBA,CAElCtI,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,oBAAoB,EAAE,OAAO,KAAK;EAEpD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASsI,qBAAqBA,CAEnCvI,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,qBAAqB,EAAE,OAAO,KAAK;EAErD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASuI,sBAAsBA,CAEpCxI,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,sBAAsB,EAAE,OAAO,KAAK;EAEtD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASwI,WAAWA,CACzBzI,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,WAAW,EAAE,OAAO,KAAK;EAE3C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASyI,gBAAgBA,CAC9B1I,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS0I,oBAAoBA,CAElC3I,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,oBAAoB,EAAE,OAAO,KAAK;EAEpD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS2I,eAAeA,CAC7B5I,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,eAAe,EAAE,OAAO,KAAK;EAE/C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS4I,0BAA0BA,CAExC7I,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,0BAA0B,EAAE,OAAO,KAAK;EAE1D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS6I,4BAA4BA,CAE1C9I,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,4BAA4B,EAAE,OAAO,KAAK;EAE5D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS8I,qBAAqBA,CAEnC/I,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,qBAAqB,EAAE,OAAO,KAAK;EAErD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAAS+I,UAAUA,CACxBhJ,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,UAAU,EAAE,OAAO,KAAK;EAE1C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASgJ,oBAAoBA,CAElCjJ,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,oBAAoB,EAAE,OAAO,KAAK;EAEpD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASiJ,iBAAiBA,CAC/BlJ,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASkJ,iBAAiBA,CAC/BnJ,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASmJ,gBAAgBA,CAC9BpJ,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASoJ,gBAAgBA,CAC9BrJ,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASqJ,gBAAgBA,CAC9BtJ,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASsJ,mBAAmBA,CACjCvJ,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,mBAAmB,EAAE,OAAO,KAAK;EAEnD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASuJ,kBAAkBA,CAChCxJ,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EAElD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASwJ,kBAAkBA,CAChCzJ,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EAElD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASyJ,qBAAqBA,CAEnC1J,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,qBAAqB,EAAE,OAAO,KAAK;EAErD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS0J,mBAAmBA,CACjC3J,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,mBAAmB,EAAE,OAAO,KAAK;EAEnD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS2J,2BAA2BA,CAEzC5J,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,2BAA2B,EAAE,OAAO,KAAK;EAE3D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS4J,cAAcA,CAC5B7J,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,cAAc,EAAE,OAAO,KAAK;EAE9C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS6J,mBAAmBA,CACjC9J,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,mBAAmB,EAAE,OAAO,KAAK;EAEnD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS8J,YAAYA,CAC1B/J,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,YAAY,EAAE,OAAO,KAAK;EAE5C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS+J,oBAAoBA,CAElChK,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,oBAAoB,EAAE,OAAO,KAAK;EAEpD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASgK,wBAAwBA,CAEtCjK,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,wBAAwB,EAAE,OAAO,KAAK;EAExD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASiK,gBAAgBA,CAC9BlK,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASkK,eAAeA,CAC7BnK,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,eAAe,EAAE,OAAO,KAAK;EAE/C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASmK,qBAAqBA,CAEnCpK,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,qBAAqB,EAAE,OAAO,KAAK;EAErD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASoK,mBAAmBA,CACjCrK,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,mBAAmB,EAAE,OAAO,KAAK;EAEnD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASqK,mBAAmBA,CACjCtK,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,mBAAmB,EAAE,OAAO,KAAK;EAEnD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASsK,oBAAoBA,CAElCvK,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,oBAAoB,EAAE,OAAO,KAAK;EAEpD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAASuK,SAASA,CACvBxK,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,SAAS,EAAE,OAAO,KAAK;EAEzC,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASwK,aAAaA,CAC3BzK,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,aAAa,EAAE,OAAO,KAAK;EAE7C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASyK,oBAAoBA,CAElC1K,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,oBAAoB,EAAE,OAAO,KAAK;EAEpD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS0K,oBAAoBA,CAElC3K,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,oBAAoB,EAAE,OAAO,KAAK;EAEpD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAAS2K,MAAMA,CACpB5K,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,MAAM,EAAE,OAAO,KAAK;EAEtC,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS4K,aAAaA,CAC3B7K,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,aAAa,EAAE,OAAO,KAAK;EAE7C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS6K,uBAAuBA,CAErC9K,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,uBAAuB,EAAE,OAAO,KAAK;EAEvD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS8K,qBAAqBA,CAEnC/K,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,qBAAqB,EAAE,OAAO,KAAK;EAErD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS+K,gBAAgBA,CAC9BhL,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASgL,WAAWA,CACzBjL,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,WAAW,EAAE,OAAO,KAAK;EAE3C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASiL,cAAcA,CAC5BlL,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,cAAc,EAAE,OAAO,KAAK;EAE9C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASkL,wBAAwBA,CAEtCnL,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,wBAAwB,EAAE,OAAO,KAAK;EAExD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASmL,kBAAkBA,CAChCpL,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EAElD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASoL,iBAAiBA,CAC/BrL,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASqL,gBAAgBA,CAC9BtL,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASsL,kBAAkBA,CAChCvL,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EAElD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASuL,gBAAgBA,CAC9BxL,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASwL,yBAAyBA,CAEvCzL,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,yBAAyB,EAAE,OAAO,KAAK;EAEzD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASyL,sBAAsBA,CAEpC1L,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,sBAAsB,EAAE,OAAO,KAAK;EAEtD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS0L,+BAA+BA,CAE7C3L,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,+BAA+B,EAAE,OAAO,KAAK;EAE/D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS2L,aAAaA,CAC3B5L,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,aAAa,EAAE,OAAO,KAAK;EAE7C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS4L,qBAAqBA,CAEnC7L,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,qBAAqB,EAAE,OAAO,KAAK;EAErD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS6L,mBAAmBA,CACjC9L,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,mBAAmB,EAAE,OAAO,KAAK;EAEnD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS8L,iBAAiBA,CAC/B/L,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS+L,iBAAiBA,CAC/BhM,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASgM,4BAA4BA,CAE1CjM,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,4BAA4B,EAAE,OAAO,KAAK;EAE5D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASiM,iCAAiCA,CAE/ClM,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iCAAiC,EAAE,OAAO,KAAK;EAEjE,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASkM,qBAAqBA,CAEnCnM,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,qBAAqB,EAAE,OAAO,KAAK;EAErD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASmM,mBAAmBA,CACjCpM,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,mBAAmB,EAAE,OAAO,KAAK;EAEnD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASoM,kBAAkBA,CAChCrM,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EAElD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASqM,cAAcA,CAC5BtM,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,cAAc,EAAE,OAAO,KAAK;EAE9C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASsM,kBAAkBA,CAChCvM,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EAElD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASuM,iBAAiBA,CAC/BxM,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASwM,oBAAoBA,CAElCzM,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,oBAAoB,EAAE,OAAO,KAAK;EAEpD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASyM,gBAAgBA,CAC9B1M,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS0M,eAAeA,CAC7B3M,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,eAAe,EAAE,OAAO,KAAK;EAE/C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS2M,iBAAiBA,CAC/B5M,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS4M,iBAAiBA,CAC/B7M,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS6M,iBAAiBA,CAC/B9M,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS8M,iBAAiBA,CAC/B/M,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS+M,oBAAoBA,CAElChN,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,oBAAoB,EAAE,OAAO,KAAK;EAEpD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASgN,kBAAkBA,CAChCjN,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EAElD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASiN,eAAeA,CAC7BlN,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,eAAe,EAAE,OAAO,KAAK;EAE/C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASkN,YAAYA,CAC1BnN,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,YAAY,EAAE,OAAO,KAAK;EAE5C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASmN,gBAAgBA,CAC9BpN,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASoN,mBAAmBA,CACjCrN,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,mBAAmB,EAAE,OAAO,KAAK;EAEnD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASqN,iBAAiBA,CAC/BtN,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASsN,iBAAiBA,CAC/BvN,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASuN,aAAaA,CAC3BxN,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,aAAa,EAAE,OAAO,KAAK;EAE7C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASwN,eAAeA,CAC7BzN,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,eAAe,EAAE,OAAO,KAAK;EAE/C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASyN,aAAaA,CAC3B1N,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,aAAa,EAAE,OAAO,KAAK;EAE7C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS0N,aAAaA,CAC3B3N,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,aAAa,EAAE,OAAO,KAAK;EAE7C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS2N,gBAAgBA,CAC9B5N,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS4N,YAAYA,CAC1B7N,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,YAAY,EAAE,OAAO,KAAK;EAE5C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS6N,oBAAoBA,CAElC9N,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,oBAAoB,EAAE,OAAO,KAAK;EAEpD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS8N,aAAaA,CAC3B/N,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,aAAa,EAAE,OAAO,KAAK;EAE7C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS+N,oBAAoBA,CAElChO,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,oBAAoB,EAAE,OAAO,KAAK;EAEpD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASgO,mBAAmBA,CACjCjO,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,mBAAmB,EAAE,OAAO,KAAK;EAEnD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASiO,aAAaA,CAC3BlO,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,aAAa,EAAE,OAAO,KAAK;EAE7C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASkO,qBAAqBA,CAEnCnO,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,qBAAqB,EAAE,OAAO,KAAK;EAErD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASmO,gBAAgBA,CAC9BpO,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASoO,qBAAqBA,CAEnCrO,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,qBAAqB,EAAE,OAAO,KAAK;EAErD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASqO,cAAcA,CAC5BtO,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,cAAc,EAAE,OAAO,KAAK;EAE9C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASsO,uBAAuBA,CAErCvO,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,uBAAuB,EAAE,OAAO,KAAK;EAEvD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASuO,eAAeA,CAC7BxO,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,eAAe,EAAE,OAAO,KAAK;EAE/C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASwO,+BAA+BA,CAE7CzO,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,+BAA+B,EAAE,OAAO,KAAK;EAE/D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASyO,wBAAwBA,CAEtC1O,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,wBAAwB,EAAE,OAAO,KAAK;EAExD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS0O,iBAAiBA,CAC/B3O,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS2O,wBAAwBA,CAEtC5O,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,wBAAwB,EAAE,OAAO,KAAK;EAExD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS4O,2BAA2BA,CAEzC7O,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,2BAA2B,EAAE,OAAO,KAAK;EAE3D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS6O,gBAAgBA,CAC9B9O,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS8O,uBAAuBA,CAErC/O,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,uBAAuB,EAAE,OAAO,KAAK;EAEvD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS+O,iBAAiBA,CAC/BhP,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASgP,YAAYA,CAC1BjP,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,YAAY,EAAE,OAAO,KAAK;EAE5C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASiP,mBAAmBA,CACjClP,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,mBAAmB,EAAE,OAAO,KAAK;EAEnD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASkP,cAAcA,CAC5BnP,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,cAAc,EAAE,OAAO,KAAK;EAE9C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASmP,qBAAqBA,CAEnCpP,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,qBAAqB,EAAE,OAAO,KAAK;EAErD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASoP,eAAeA,CAC7BrP,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,eAAe,EAAE,OAAO,KAAK;EAE/C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASqP,cAAcA,CAC5BtP,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,cAAc,EAAE,OAAO,KAAK;EAE9C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASsP,2BAA2BA,CAEzCvP,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,2BAA2B,EAAE,OAAO,KAAK;EAE3D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASuP,2BAA2BA,CAEzCxP,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,2BAA2B,EAAE,OAAO,KAAK;EAE3D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASwP,qBAAqBA,CAEnCzP,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,qBAAqB,EAAE,OAAO,KAAK;EAErD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASyP,oBAAoBA,CAElC1P,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,oBAAoB,EAAE,OAAO,KAAK;EAEpD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS0P,8BAA8BA,CAE5C3P,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,8BAA8B,EAAE,OAAO,KAAK;EAE9D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS2P,kBAAkBA,CAChC5P,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,kBAAkB,EAAE,OAAO,KAAK;EAElD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS4P,8BAA8BA,CAE5C7P,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,8BAA8B,EAAE,OAAO,KAAK;EAE9D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAAS6P,4BAA4BA,CAE1C9P,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,4BAA4B,EAAE,OAAO,KAAK;EAE5D,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS8P,iBAAiBA,CAC/B/P,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,iBAAiB,EAAE,OAAO,KAAK;EAEjD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS+P,cAAcA,CAC5BhQ,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,iBAAiB;IACtB,KAAK,sBAAsB;IAC3B,KAAK,kBAAkB;IACvB,KAAK,sBAAsB;IAC3B,KAAK,WAAW;IAChB,KAAK,kBAAkB;IACvB,KAAK,gBAAgB;IACrB,KAAK,gBAAgB;IACrB,KAAK,gBAAgB;IACrB,KAAK,aAAa;IAClB,KAAK,uBAAuB;IAC5B,KAAK,mBAAmB;IACxB,KAAK,mBAAmB;IACxB,KAAK,kBAAkB;IACvB,KAAK,gBAAgB;IACrB,KAAK,qBAAqB;IAC1B,KAAK,MAAM;IACX,KAAK,gBAAgB;IACrB,KAAK,cAAc;IACnB,KAAK,qBAAqB;IAC1B,KAAK,oBAAoB;IACzB,KAAK,YAAY;IACjB,KAAK,aAAa;IAClB,KAAK,kBAAkB;IACvB,KAAK,eAAe;IACpB,KAAK,gBAAgB;IACrB,KAAK,aAAa;IAClB,KAAK,gBAAgB;IACrB,KAAK,eAAe;IACpB,KAAK,mBAAmB;IACxB,KAAK,kBAAkB;IACvB,KAAK,eAAe;IACpB,KAAK,SAAS;IACd,KAAK,kBAAkB;IACvB,KAAK,cAAc;IACnB,KAAK,gBAAgB;IACrB,KAAK,aAAa;IAClB,KAAK,iBAAiB;IACtB,KAAK,oBAAoB;IACzB,KAAK,yBAAyB;IAC9B,KAAK,YAAY;IACjB,KAAK,iBAAiB;IACtB,KAAK,gBAAgB;IACrB,KAAK,gBAAgB;IACrB,KAAK,cAAc;IACnB,KAAK,iBAAiB;IACtB,KAAK,kBAAkB;IACvB,KAAK,qBAAqB;IAC1B,KAAK,oBAAoB;IACzB,KAAK,gBAAgB;IACrB,KAAK,eAAe;IACpB,KAAK,mBAAmB;IACxB,KAAK,cAAc;IACnB,KAAK,yBAAyB;IAC9B,KAAK,WAAW;IAChB,KAAK,iBAAiB;IACtB,KAAK,kBAAkB;IACvB,KAAK,sBAAsB;IAC3B,KAAK,0BAA0B;IAC/B,KAAK,wBAAwB;IAC7B,KAAK,iBAAiB;IACtB,KAAK,gBAAgB;IACrB,KAAK,mBAAmB;IACxB,KAAK,wBAAwB;IAC7B,KAAK,0BAA0B;IAC/B,KAAK,iBAAiB;IACtB,KAAK,kBAAkB;IACvB,KAAK,cAAc;IACnB,KAAK,aAAa;IAClB,KAAK,eAAe;IACpB,KAAK,eAAe;IACpB,KAAK,OAAO;IACZ,KAAK,0BAA0B;IAC/B,KAAK,iBAAiB;IACtB,KAAK,iBAAiB;IACtB,KAAK,iBAAiB;IACtB,KAAK,iBAAiB;IACtB,KAAK,QAAQ;IACb,KAAK,eAAe;IACpB,KAAK,0BAA0B;IAC/B,KAAK,0BAA0B;IAC/B,KAAK,wBAAwB;IAC7B,KAAK,eAAe;IACpB,KAAK,uBAAuB;IAC5B,KAAK,sBAAsB;IAC3B,KAAK,oBAAoB;IACzB,KAAK,aAAa;IAClB,KAAK,aAAa;IAClB,KAAK,iBAAiB;MACpB;IACF,KAAK,aAAa;MAChB,QAAQF,IAAI,CAACiQ,YAAY;QACvB,KAAK,YAAY;QACjB,KAAK,eAAe;QACpB,KAAK,gBAAgB;QACrB,KAAK,WAAW;UACd;QACF;UACE,OAAO,KAAK;MAChB;MACA;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOhQ,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASiQ,YAAYA,CAC1BlQ,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,iBAAiB;IACtB,KAAK,sBAAsB;IAC3B,KAAK,kBAAkB;IACvB,KAAK,gBAAgB;IACrB,KAAK,uBAAuB;IAC5B,KAAK,oBAAoB;IACzB,KAAK,YAAY;IACjB,KAAK,eAAe;IACpB,KAAK,gBAAgB;IACrB,KAAK,aAAa;IAClB,KAAK,gBAAgB;IACrB,KAAK,eAAe;IACpB,KAAK,mBAAmB;IACxB,KAAK,kBAAkB;IACvB,KAAK,eAAe;IACpB,KAAK,kBAAkB;IACvB,KAAK,oBAAoB;IACzB,KAAK,yBAAyB;IAC9B,KAAK,gBAAgB;IACrB,KAAK,iBAAiB;IACtB,KAAK,kBAAkB;IACvB,KAAK,yBAAyB;IAC9B,KAAK,iBAAiB;IACtB,KAAK,kBAAkB;IACvB,KAAK,cAAc;IACnB,KAAK,OAAO;IACZ,KAAK,0BAA0B;IAC/B,KAAK,iBAAiB;IACtB,KAAK,iBAAiB;IACtB,KAAK,iBAAiB;IACtB,KAAK,QAAQ;IACb,KAAK,eAAe;IACpB,KAAK,0BAA0B;IAC/B,KAAK,wBAAwB;IAC7B,KAAK,oBAAoB;IACzB,KAAK,YAAY;IACjB,KAAK,aAAa;IAClB,KAAK,gBAAgB;IACrB,KAAK,cAAc;IACnB,KAAK,kBAAkB;IACvB,KAAK,iBAAiB;IACtB,KAAK,gBAAgB;IACrB,KAAK,kBAAkB;IACvB,KAAK,gBAAgB;IACrB,KAAK,yBAAyB;IAC9B,KAAK,sBAAsB;IAC3B,KAAK,+BAA+B;IACpC,KAAK,2BAA2B;IAChC,KAAK,gBAAgB;IACrB,KAAK,uBAAuB;IAC5B,KAAK,iBAAiB;IACtB,KAAK,qBAAqB;MACxB;IACF,KAAK,aAAa;MAChB,QAAQF,IAAI,CAACiQ,YAAY;QACvB,KAAK,YAAY;QACjB,KAAK,YAAY;QACjB,KAAK,eAAe;UAClB;QACF;UACE,OAAO,KAAK;MAChB;MACA;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOhQ,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAASkQ,QAAQA,CACtBnQ,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,kBAAkB;IACvB,KAAK,mBAAmB;MACtB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAASmQ,UAAUA,CACxBpQ,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,gBAAgB;IACrB,KAAK,aAAa;IAClB,KAAK,kBAAkB;IACvB,KAAK,gBAAgB;IACrB,KAAK,cAAc;IACnB,KAAK,qBAAqB;IAC1B,KAAK,oBAAoB;IACzB,KAAK,SAAS;IACd,KAAK,cAAc;IACnB,KAAK,iBAAiB;IACtB,KAAK,gBAAgB;IACrB,KAAK,yBAAyB;IAC9B,KAAK,iBAAiB;IACtB,KAAK,kBAAkB;IACvB,KAAK,gBAAgB;IACrB,KAAK,aAAa;IAClB,KAAK,oBAAoB;IACzB,KAAK,aAAa;IAClB,KAAK,eAAe;MAClB;IACF,KAAK,aAAa;MAChB,IAAIF,IAAI,CAACiQ,YAAY,KAAK,gBAAgB,EAAE;IAC9C;MACE,OAAO,KAAK;EAChB;EAEA,OAAOhQ,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASoQ,aAAaA,CAC3BrQ,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,gBAAgB;IACrB,KAAK,aAAa;IAClB,KAAK,kBAAkB;IACvB,KAAK,gBAAgB;IACrB,KAAK,cAAc;IACnB,KAAK,qBAAqB;IAC1B,KAAK,oBAAoB;IACzB,KAAK,SAAS;IACd,KAAK,cAAc;IACnB,KAAK,iBAAiB;IACtB,KAAK,gBAAgB;IACrB,KAAK,yBAAyB;IAC9B,KAAK,gBAAgB;IACrB,KAAK,aAAa;IAClB,KAAK,oBAAoB;IACzB,KAAK,aAAa;IAClB,KAAK,eAAe;MAClB;IACF,KAAK,aAAa;MAChB,IAAIF,IAAI,CAACiQ,YAAY,KAAK,gBAAgB,EAAE;IAC9C;MACE,OAAO,KAAK;EAChB;EAEA,OAAOhQ,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAASqQ,OAAOA,CACrBtQ,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,gBAAgB;IACrB,KAAK,SAAS;IACd,KAAK,eAAe;MAClB;IACF,KAAK,aAAa;MAChB,IAAIF,IAAI,CAACiQ,YAAY,KAAK,gBAAgB,EAAE;IAC9C;MACE,OAAO,KAAK;EAChB;EAEA,OAAOhQ,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASsQ,WAAWA,CACzBvQ,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,gBAAgB;IACrB,KAAK,gBAAgB;IACrB,KAAK,mBAAmB;IACxB,KAAK,mBAAmB;IACxB,KAAK,kBAAkB;IACvB,KAAK,gBAAgB;IACrB,KAAK,qBAAqB;IAC1B,KAAK,gBAAgB;IACrB,KAAK,cAAc;IACnB,KAAK,qBAAqB;IAC1B,KAAK,aAAa;IAClB,KAAK,kBAAkB;IACvB,KAAK,iBAAiB;IACtB,KAAK,iBAAiB;IACtB,KAAK,gBAAgB;IACrB,KAAK,cAAc;IACnB,KAAK,qBAAqB;IAC1B,KAAK,gBAAgB;IACrB,KAAK,eAAe;IACpB,KAAK,kBAAkB;IACvB,KAAK,sBAAsB;IAC3B,KAAK,0BAA0B;IAC/B,KAAK,wBAAwB;IAC7B,KAAK,gBAAgB;IACrB,KAAK,mBAAmB;IACxB,KAAK,cAAc;IACnB,KAAK,iBAAiB;IACtB,KAAK,kBAAkB;IACvB,KAAK,eAAe;IACpB,KAAK,sBAAsB;IAC3B,KAAK,kBAAkB;IACvB,KAAK,mBAAmB;IACxB,KAAK,iBAAiB;IACtB,KAAK,0BAA0B;IAC/B,KAAK,6BAA6B;IAClC,KAAK,sBAAsB;IAC3B,KAAK,YAAY;IACjB,KAAK,WAAW;IAChB,KAAK,iBAAiB;IACtB,KAAK,mBAAmB;IACxB,KAAK,wBAAwB;IAC7B,KAAK,wBAAwB;IAC7B,KAAK,mBAAmB;IACxB,KAAK,qBAAqB;IAC1B,KAAK,2BAA2B;IAChC,KAAK,oBAAoB;IACzB,KAAK,8BAA8B;MACjC;IACF,KAAK,aAAa;MAChB,QAAQF,IAAI,CAACiQ,YAAY;QACvB,KAAK,WAAW;QAChB,KAAK,aAAa;QAClB,KAAK,gBAAgB;UACnB;QACF;UACE,OAAO,KAAK;MAChB;MACA;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOhQ,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASuQ,gBAAgBA,CAC9BxQ,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,gBAAgB;IACrB,KAAK,mBAAmB;IACxB,KAAK,iBAAiB;IACtB,KAAK,gBAAgB;IACrB,KAAK,iBAAiB;IACtB,KAAK,iBAAiB;MACpB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASwQ,qBAAqBA,CAEnCzQ,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,gBAAgB;IACrB,KAAK,mBAAmB;IACxB,KAAK,iBAAiB;IACtB,KAAK,gBAAgB;MACnB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASyQ,aAAaA,CAC3B1Q,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,uBAAuB;IAC5B,KAAK,aAAa;MAChB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAAS0Q,MAAMA,CACpB3Q,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,kBAAkB;IACvB,KAAK,gBAAgB;IACrB,KAAK,cAAc;IACnB,KAAK,gBAAgB;IACrB,KAAK,gBAAgB;MACnB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAAS2Q,OAAOA,CACrB5Q,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,kBAAkB;IACvB,KAAK,gBAAgB;MACnB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS4Q,mBAAmBA,CACjC7Q,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,qBAAqB;IAC1B,KAAK,yBAAyB;IAC9B,KAAK,oBAAoB;MACvB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAAS6Q,KAAKA,CACnB9Q,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,gBAAgB;IACrB,KAAK,cAAc;IACnB,KAAK,gBAAgB;MACnB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS8Q,eAAeA,CAC7B/Q,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,gBAAgB;IACrB,KAAK,gBAAgB;MACnB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAAS+Q,UAAUA,CACxBhR,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,qBAAqB;IAC1B,KAAK,oBAAoB;IACzB,KAAK,cAAc;IACnB,KAAK,yBAAyB;IAC9B,KAAK,aAAa;IAClB,KAAK,oBAAoB;MACvB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASgR,gBAAgBA,CAC9BjR,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,qBAAqB;IAC1B,KAAK,oBAAoB;IACzB,KAAK,cAAc;IACnB,KAAK,yBAAyB;IAC9B,KAAK,aAAa;IAClB,KAAK,oBAAoB;IACzB,KAAK,aAAa;IAClB,KAAK,eAAe;MAClB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAASiR,SAASA,CACvBlR,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,qBAAqB;IAC1B,KAAK,oBAAoB;IACzB,KAAK,eAAe;IACpB,KAAK,gBAAgB;IACrB,KAAK,aAAa;IAClB,KAAK,gBAAgB;IACrB,KAAK,eAAe;IACpB,KAAK,yBAAyB;IAC9B,KAAK,eAAe;IACpB,KAAK,gBAAgB;MACnB;IACF,KAAK,aAAa;MAChB,IAAIF,IAAI,CAACiQ,YAAY,KAAK,eAAe,EAAE;IAC7C;MACE,OAAO,KAAK;EAChB;EAEA,OAAOhQ,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASkR,aAAaA,CAC3BnR,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,qBAAqB;IAC1B,KAAK,qBAAqB;IAC1B,KAAK,kBAAkB;IACvB,KAAK,sBAAsB;IAC3B,KAAK,0BAA0B;IAC/B,KAAK,wBAAwB;IAC7B,KAAK,mBAAmB;IACxB,KAAK,cAAc;IACnB,KAAK,iBAAiB;IACtB,KAAK,kBAAkB;IACvB,KAAK,eAAe;IACpB,KAAK,sBAAsB;IAC3B,KAAK,kBAAkB;IACvB,KAAK,mBAAmB;IACxB,KAAK,iBAAiB;IACtB,KAAK,0BAA0B;IAC/B,KAAK,6BAA6B;IAClC,KAAK,sBAAsB;IAC3B,KAAK,YAAY;IACjB,KAAK,WAAW;IAChB,KAAK,iBAAiB;IACtB,KAAK,mBAAmB;IACxB,KAAK,wBAAwB;IAC7B,KAAK,wBAAwB;IAC7B,KAAK,mBAAmB;IACxB,KAAK,qBAAqB;IAC1B,KAAK,2BAA2B;MAC9B;IACF,KAAK,aAAa;MAChB,IAAIF,IAAI,CAACiQ,YAAY,KAAK,aAAa,EAAE;IAC3C;MACE,OAAO,KAAK;EAChB;EAEA,OAAOhQ,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASmR,mBAAmBA,CACjCpR,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,YAAY;IACjB,KAAK,aAAa;IAClB,KAAK,mBAAmB;IACxB,KAAK,cAAc;IACnB,KAAK,eAAe;IACpB,KAAK,aAAa;MAChB;IACF,KAAK,aAAa;MAChB,IAAIF,IAAI,CAACiQ,YAAY,KAAK,YAAY,EAAE;IAC1C;MACE,OAAO,KAAK;EAChB;EAEA,OAAOhQ,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASoR,aAAaA,CAC3BrR,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,YAAY;IACjB,KAAK,kBAAkB;IACvB,KAAK,aAAa;IAClB,KAAK,mBAAmB;IACxB,KAAK,cAAc;IACnB,KAAK,eAAe;IACpB,KAAK,aAAa;IAClB,KAAK,gBAAgB;IACrB,KAAK,uBAAuB;IAC5B,KAAK,iBAAiB;IACtB,KAAK,qBAAqB;MACxB;IACF,KAAK,aAAa;MAChB,QAAQF,IAAI,CAACiQ,YAAY;QACvB,KAAK,SAAS;QACd,KAAK,YAAY;UACf;QACF;UACE,OAAO,KAAK;MAChB;MACA;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOhQ,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAASqR,MAAMA,CACpBtR,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,YAAY;IACjB,KAAK,kBAAkB;IACvB,KAAK,aAAa;IAClB,KAAK,mBAAmB;IACxB,KAAK,cAAc;IACnB,KAAK,eAAe;IACpB,KAAK,qBAAqB;IAC1B,KAAK,gBAAgB;IACrB,KAAK,uBAAuB;IAC5B,KAAK,iBAAiB;IACtB,KAAK,qBAAqB;MACxB;IACF,KAAK,aAAa;MAChB,QAAQF,IAAI,CAACiQ,YAAY;QACvB,KAAK,SAAS;QACd,KAAK,YAAY;UACf;QACF;UACE,OAAO,KAAK;MAChB;MACA;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOhQ,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASsR,cAAcA,CAC5BvR,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,YAAY;IACjB,KAAK,iBAAiB;MACpB;IACF,KAAK,aAAa;MAChB,IAAIF,IAAI,CAACiQ,YAAY,KAAK,YAAY,EAAE;IAC1C;MACE,OAAO,KAAK;EAChB;EAEA,OAAOhQ,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAASuR,SAASA,CACvBxR,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,eAAe;IACpB,KAAK,gBAAgB;IACrB,KAAK,aAAa;IAClB,KAAK,gBAAgB;IACrB,KAAK,eAAe;IACpB,KAAK,iBAAiB;IACtB,KAAK,eAAe;IACpB,KAAK,gBAAgB;MACnB;IACF,KAAK,aAAa;MAChB,IAAIF,IAAI,CAACiQ,YAAY,KAAK,eAAe,EAAE;IAC7C;MACE,OAAO,KAAK;EAChB;EAEA,OAAOhQ,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASwR,WAAWA,CACzBzR,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,eAAe;IACpB,KAAK,gBAAgB;IACrB,KAAK,aAAa;IAClB,KAAK,gBAAgB;IACrB,KAAK,eAAe;IACpB,KAAK,cAAc;IACnB,KAAK,mBAAmB;IACxB,KAAK,YAAY;IACjB,KAAK,wBAAwB;IAC7B,KAAK,gBAAgB;IACrB,KAAK,mBAAmB;IACxB,KAAK,SAAS;IACd,KAAK,aAAa;IAClB,KAAK,oBAAoB;IACzB,KAAK,oBAAoB;IACzB,KAAK,gBAAgB;MACnB;IACF,KAAK,aAAa;MAChB,IAAIF,IAAI,CAACiQ,YAAY,KAAK,eAAe,EAAE;IAC7C;MACE,OAAO,KAAK;EAChB;EAEA,OAAOhQ,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASyR,mBAAmBA,CACjC1R,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,cAAc;IACnB,KAAK,gBAAgB;IACrB,KAAK,wBAAwB;IAC7B,KAAK,wBAAwB;IAC7B,KAAK,mBAAmB;IACxB,KAAK,oBAAoB;IACzB,KAAK,0BAA0B;MAC7B;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAAS0R,QAAQA,CACtB3R,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,cAAc;IACnB,KAAK,aAAa;IAClB,KAAK,oBAAoB;MACvB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS2R,cAAcA,CAC5B5R,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,cAAc;IACnB,KAAK,gBAAgB;MACnB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAAS4R,UAAUA,CACxB7R,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,gBAAgB;IACrB,KAAK,eAAe;IACpB,KAAK,uBAAuB;IAC5B,KAAK,sBAAsB;MACzB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS6R,WAAWA,CACzB9R,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,iBAAiB;IACtB,KAAK,eAAe;MAClB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAAS8R,SAASA,CACvB/R,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,mBAAmB;IACxB,KAAK,cAAc;IACnB,KAAK,eAAe;IACpB,KAAK,aAAa;MAChB;IACF,KAAK,aAAa;MAChB,IAAIF,IAAI,CAACiQ,YAAY,KAAK,SAAS,EAAE;IACvC;MACE,OAAO,KAAK;EAChB;EAEA,OAAOhQ,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAAS+R,OAAOA,CACrBhS,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,iBAAiB;IACtB,KAAK,kBAAkB;MACrB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASgS,2BAA2BA,CAEzCjS,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,sBAAsB;IAC3B,KAAK,0BAA0B;IAC/B,KAAK,wBAAwB;IAC7B,KAAK,mBAAmB;MACtB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASiS,mBAAmBA,CACjClS,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,sBAAsB;IAC3B,KAAK,0BAA0B;IAC/B,KAAK,wBAAwB;MAC3B;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASkS,iBAAiBA,CAC/BnS,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,iBAAiB;IACtB,KAAK,wBAAwB;IAC7B,KAAK,0BAA0B;IAC/B,KAAK,iBAAiB;IACtB,KAAK,0BAA0B;IAC/B,KAAK,wBAAwB;MAC3B;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAASmS,UAAUA,CACxBpS,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,uBAAuB;MAC1B;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAASoS,SAASA,CACvBrS,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,sBAAsB;IAC3B,KAAK,oBAAoB;IACzB,KAAK,aAAa;MAChB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAASqS,MAAMA,CACpBtS,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,mBAAmB;IACxB,KAAK,qBAAqB;IAC1B,KAAK,uBAAuB;IAC5B,KAAK,8BAA8B;IACnC,KAAK,2BAA2B;IAChC,KAAK,iBAAiB;IACtB,KAAK,cAAc;IACnB,KAAK,iBAAiB;IACtB,KAAK,kBAAkB;IACvB,KAAK,eAAe;IACpB,KAAK,sBAAsB;IAC3B,KAAK,kBAAkB;IACvB,KAAK,mBAAmB;IACxB,KAAK,iBAAiB;IACtB,KAAK,0BAA0B;IAC/B,KAAK,6BAA6B;IAClC,KAAK,mBAAmB;IACxB,KAAK,sBAAsB;IAC3B,KAAK,wBAAwB;IAC7B,KAAK,mBAAmB;IACxB,KAAK,uBAAuB;IAC5B,KAAK,mBAAmB;IACxB,KAAK,kBAAkB;IACvB,KAAK,sBAAsB;IAC3B,KAAK,yBAAyB;IAC9B,KAAK,4BAA4B;IACjC,KAAK,qBAAqB;IAC1B,KAAK,qBAAqB;IAC1B,KAAK,wBAAwB;IAC7B,KAAK,6BAA6B;IAClC,KAAK,sBAAsB;IAC3B,KAAK,sBAAsB;IAC3B,KAAK,wBAAwB;IAC7B,KAAK,wBAAwB;IAC7B,KAAK,mBAAmB;IACxB,KAAK,oBAAoB;IACzB,KAAK,0BAA0B;IAC/B,KAAK,YAAY;IACjB,KAAK,yBAAyB;IAC9B,KAAK,6BAA6B;IAClC,KAAK,sBAAsB;IAC3B,KAAK,sBAAsB;IAC3B,KAAK,oBAAoB;IACzB,KAAK,qBAAqB;IAC1B,KAAK,sBAAsB;IAC3B,KAAK,WAAW;IAChB,KAAK,gBAAgB;IACrB,KAAK,oBAAoB;IACzB,KAAK,eAAe;IACpB,KAAK,0BAA0B;IAC/B,KAAK,4BAA4B;IACjC,KAAK,qBAAqB;IAC1B,KAAK,UAAU;IACf,KAAK,oBAAoB;IACzB,KAAK,iBAAiB;IACtB,KAAK,iBAAiB;IACtB,KAAK,gBAAgB;IACrB,KAAK,gBAAgB;IACrB,KAAK,gBAAgB;IACrB,KAAK,mBAAmB;IACxB,KAAK,kBAAkB;IACvB,KAAK,kBAAkB;IACvB,KAAK,qBAAqB;IAC1B,KAAK,mBAAmB;IACxB,KAAK,2BAA2B;MAC9B;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAASsS,UAAUA,CACxBvS,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,mBAAmB;IACxB,KAAK,qBAAqB;IAC1B,KAAK,uBAAuB;IAC5B,KAAK,8BAA8B;IACnC,KAAK,2BAA2B;IAChC,KAAK,sBAAsB;IAC3B,KAAK,wBAAwB;IAC7B,KAAK,uBAAuB;IAC5B,KAAK,yBAAyB;IAC9B,KAAK,4BAA4B;IACjC,KAAK,qBAAqB;IAC1B,KAAK,qBAAqB;IAC1B,KAAK,wBAAwB;IAC7B,KAAK,6BAA6B;IAClC,KAAK,sBAAsB;IAC3B,KAAK,sBAAsB;IAC3B,KAAK,6BAA6B;IAClC,KAAK,sBAAsB;IAC3B,KAAK,sBAAsB;IAC3B,KAAK,oBAAoB;IACzB,KAAK,qBAAqB;IAC1B,KAAK,sBAAsB;IAC3B,KAAK,qBAAqB;IAC1B,KAAK,oBAAoB;IACzB,KAAK,mBAAmB;IACxB,KAAK,2BAA2B;MAC9B;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAUO,SAASuS,oBAAoBA,CAElCxS,IAA+B,EAAEC,IAAkB,EAAW;EAC9D,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,mBAAmB;IACxB,KAAK,uBAAuB;IAC5B,KAAK,2BAA2B;IAChC,KAAK,qBAAqB;IAC1B,KAAK,qBAAqB;IAC1B,KAAK,sBAAsB;IAC3B,KAAK,sBAAsB;IAC3B,KAAK,sBAAsB;IAC3B,KAAK,oBAAoB;IACzB,KAAK,oBAAoB;MACvB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASwS,iBAAiBA,CAC/BzS,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,cAAc;IACnB,KAAK,iBAAiB;IACtB,KAAK,kBAAkB;IACvB,KAAK,eAAe;IACpB,KAAK,sBAAsB;IAC3B,KAAK,kBAAkB;IACvB,KAAK,mBAAmB;IACxB,KAAK,iBAAiB;IACtB,KAAK,0BAA0B;IAC/B,KAAK,6BAA6B;IAClC,KAAK,sBAAsB;IAC3B,KAAK,YAAY;IACjB,KAAK,WAAW;MACd;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASyS,eAAeA,CAC7B1S,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,mBAAmB;IACxB,KAAK,mBAAmB;MACtB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAAS0S,UAAUA,CACxB3S,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,iBAAiB;IACtB,KAAK,gBAAgB;IACrB,KAAK,gBAAgB;IACrB,KAAK,gBAAgB;MACnB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS2S,YAAYA,CAC1B5S,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,mBAAmB;IACxB,KAAK,kBAAkB;IACvB,KAAK,kBAAkB;IACvB,KAAK,qBAAqB;MACxB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAAS4S,KAAKA,CACnB7S,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,cAAc;IACnB,KAAK,mBAAmB;IACxB,KAAK,YAAY;IACjB,KAAK,oBAAoB;IACzB,KAAK,wBAAwB;IAC7B,KAAK,gBAAgB;IACrB,KAAK,eAAe;IACpB,KAAK,qBAAqB;IAC1B,KAAK,mBAAmB;IACxB,KAAK,mBAAmB;IACxB,KAAK,oBAAoB;IACzB,KAAK,SAAS;IACd,KAAK,aAAa;IAClB,KAAK,oBAAoB;IACzB,KAAK,oBAAoB;MACvB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS6S,eAAeA,CAC7B9S,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,MAAM;IACX,KAAK,aAAa;IAClB,KAAK,uBAAuB;MAC1B;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS8S,YAAYA,CAC1B/S,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,qBAAqB;IAC1B,KAAK,mBAAmB;IACxB,KAAK,iBAAiB;IACtB,KAAK,iBAAiB;IACtB,KAAK,4BAA4B;IACjC,KAAK,iCAAiC;IACtC,KAAK,qBAAqB;IAC1B,KAAK,mBAAmB;IACxB,KAAK,kBAAkB;IACvB,KAAK,cAAc;IACnB,KAAK,kBAAkB;IACvB,KAAK,iBAAiB;IACtB,KAAK,oBAAoB;IACzB,KAAK,gBAAgB;IACrB,KAAK,eAAe;IACpB,KAAK,iBAAiB;IACtB,KAAK,iBAAiB;IACtB,KAAK,iBAAiB;IACtB,KAAK,iBAAiB;IACtB,KAAK,oBAAoB;IACzB,KAAK,kBAAkB;IACvB,KAAK,eAAe;IACpB,KAAK,YAAY;IACjB,KAAK,gBAAgB;IACrB,KAAK,mBAAmB;IACxB,KAAK,iBAAiB;IACtB,KAAK,iBAAiB;IACtB,KAAK,aAAa;IAClB,KAAK,eAAe;IACpB,KAAK,aAAa;IAClB,KAAK,aAAa;IAClB,KAAK,gBAAgB;IACrB,KAAK,YAAY;IACjB,KAAK,oBAAoB;IACzB,KAAK,aAAa;IAClB,KAAK,oBAAoB;IACzB,KAAK,mBAAmB;IACxB,KAAK,aAAa;IAClB,KAAK,qBAAqB;IAC1B,KAAK,gBAAgB;IACrB,KAAK,qBAAqB;IAC1B,KAAK,cAAc;IACnB,KAAK,uBAAuB;IAC5B,KAAK,eAAe;IACpB,KAAK,+BAA+B;IACpC,KAAK,wBAAwB;IAC7B,KAAK,iBAAiB;IACtB,KAAK,wBAAwB;IAC7B,KAAK,2BAA2B;IAChC,KAAK,gBAAgB;IACrB,KAAK,uBAAuB;IAC5B,KAAK,iBAAiB;IACtB,KAAK,YAAY;IACjB,KAAK,mBAAmB;IACxB,KAAK,cAAc;IACnB,KAAK,qBAAqB;IAC1B,KAAK,eAAe;IACpB,KAAK,cAAc;IACnB,KAAK,2BAA2B;IAChC,KAAK,2BAA2B;IAChC,KAAK,qBAAqB;IAC1B,KAAK,oBAAoB;IACzB,KAAK,8BAA8B;IACnC,KAAK,kBAAkB;IACvB,KAAK,8BAA8B;IACnC,KAAK,4BAA4B;IACjC,KAAK,iBAAiB;MACpB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAAS+S,eAAeA,CAC7BhT,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,4BAA4B;IACjC,KAAK,iCAAiC;IACtC,KAAK,qBAAqB;IAC1B,KAAK,mBAAmB;IACxB,KAAK,kBAAkB;MACrB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAMO,SAASgT,QAAQA,CACtBjT,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,cAAc;IACnB,KAAK,kBAAkB;IACvB,KAAK,iBAAiB;IACtB,KAAK,oBAAoB;IACzB,KAAK,gBAAgB;IACrB,KAAK,eAAe;IACpB,KAAK,iBAAiB;IACtB,KAAK,iBAAiB;IACtB,KAAK,iBAAiB;IACtB,KAAK,iBAAiB;IACtB,KAAK,oBAAoB;IACzB,KAAK,kBAAkB;IACvB,KAAK,eAAe;IACpB,KAAK,YAAY;IACjB,KAAK,gBAAgB;IACrB,KAAK,mBAAmB;IACxB,KAAK,iBAAiB;IACtB,KAAK,iBAAiB;IACtB,KAAK,aAAa;IAClB,KAAK,eAAe;IACpB,KAAK,aAAa;IAClB,KAAK,aAAa;IAClB,KAAK,gBAAgB;IACrB,KAAK,YAAY;IACjB,KAAK,aAAa;IAClB,KAAK,oBAAoB;IACzB,KAAK,mBAAmB;IACxB,KAAK,aAAa;IAClB,KAAK,qBAAqB;IAC1B,KAAK,gBAAgB;IACrB,KAAK,qBAAqB;IAC1B,KAAK,cAAc;IACnB,KAAK,uBAAuB;IAC5B,KAAK,eAAe;IACpB,KAAK,+BAA+B;IACpC,KAAK,cAAc;MACjB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAQO,SAASiT,YAAYA,CAC1BlT,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAI,CAACD,IAAI,EAAE,OAAO,KAAK;EAEvB,QAAQA,IAAI,CAACE,IAAI;IACf,KAAK,cAAc;IACnB,KAAK,kBAAkB;IACvB,KAAK,iBAAiB;IACtB,KAAK,oBAAoB;IACzB,KAAK,gBAAgB;IACrB,KAAK,eAAe;IACpB,KAAK,iBAAiB;IACtB,KAAK,iBAAiB;IACtB,KAAK,iBAAiB;IACtB,KAAK,iBAAiB;IACtB,KAAK,oBAAoB;IACzB,KAAK,kBAAkB;IACvB,KAAK,eAAe;IACpB,KAAK,YAAY;IACjB,KAAK,uBAAuB;IAC5B,KAAK,eAAe;MAClB;IACF;MACE,OAAO,KAAK;EAChB;EAEA,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AASO,SAASkT,eAAeA,CAC7BnT,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAAmT,2BAAkB,EAAC,iBAAiB,EAAE,kBAAkB,CAAC;EACzD,IAAI,CAACpT,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,eAAe,EAAE,OAAO,KAAK;EAE/C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AASO,SAASoT,cAAcA,CAC5BrT,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAAmT,2BAAkB,EAAC,gBAAgB,EAAE,iBAAiB,CAAC;EACvD,IAAI,CAACpT,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,cAAc,EAAE,OAAO,KAAK;EAE9C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AASO,SAASqT,cAAcA,CAC5BtT,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAAmT,2BAAkB,EAAC,gBAAgB,EAAE,eAAe,CAAC;EACrD,IAAI,CAACpT,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,cAAc,EAAE,OAAO,KAAK;EAE9C,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AASO,SAASsT,gBAAgBA,CAC9BvT,IAA+B,EAC/BC,IAAkB,EACT;EACT,IAAAmT,2BAAkB,EAAC,kBAAkB,EAAE,iBAAiB,CAAC;EACzD,IAAI,CAACpT,IAAI,EAAE,OAAO,KAAK;EAEvB,IAAIA,IAAI,CAACE,IAAI,KAAK,gBAAgB,EAAE,OAAO,KAAK;EAEhD,OAAOD,IAAI,IAAI,IAAI,IAAI,IAAAE,qBAAY,EAACH,IAAI,EAAEC,IAAI,CAAC;AACjD;AAIO,SAASuT,mBAAmBA,CACjCxT,IAA+B,EAC/BC,IAAkB,EAC0B;EAC5C,IAAAmT,2BAAkB,EAAC,qBAAqB,EAAE,6BAA6B,CAAC;EACxE,OAAOnB,2BAA2B,CAACjS,IAAI,EAAEC,IAAI,CAAC;AAChD","ignoreList":[]}
=======
{"version":3,"names":["isArrayExpression","node","opts","nodeType","type","shallowEqual","isAssignmentExpression","isBinaryExpression","isInterpreterDirective","isDirective","isDirectiveLiteral","isBlockStatement","isBreakStatement","isCallExpression","isCatchClause","isConditionalExpression","isContinueStatement","isDebuggerStatement","isDoWhileStatement","isEmptyStatement","isExpressionStatement","isFile","isForInStatement","isForStatement","isFunctionDeclaration","isFunctionExpression","isIdentifier","isIfStatement","isLabeledStatement","isStringLiteral","isNumericLiteral","isNullLiteral","isBooleanLiteral","isRegExpLiteral","isLogicalExpression","isMemberExpression","isNewExpression","isProgram","isObjectExpression","isObjectMethod","isObjectProperty","isRestElement","isReturnStatement","isSequenceExpression","isParenthesizedExpression","isSwitchCase","isSwitchStatement","isThisExpression","isThrowStatement","isTryStatement","isUnaryExpression","isUpdateExpression","isVariableDeclaration","isVariableDeclarator","isWhileStatement","isWithStatement","isAssignmentPattern","isArrayPattern","isArrowFunctionExpression","isClassBody","isClassExpression","isClassDeclaration","isExportAllDeclaration","isExportDefaultDeclaration","isExportNamedDeclaration","isExportSpecifier","isForOfStatement","isImportDeclaration","isImportDefaultSpecifier","isImportNamespaceSpecifier","isImportSpecifier","isMetaProperty","isClassMethod","isObjectPattern","isSpreadElement","isSuper","isTaggedTemplateExpression","isTemplateElement","isTemplateLiteral","isYieldExpression","isAwaitExpression","isImport","isBigIntLiteral","isExportNamespaceSpecifier","isOptionalMemberExpression","isOptionalCallExpression","isClassProperty","isClassAccessorProperty","isClassPrivateProperty","isClassPrivateMethod","isPrivateName","isStaticBlock","isAnyTypeAnnotation","isArrayTypeAnnotation","isBooleanTypeAnnotation","isBooleanLiteralTypeAnnotation","isNullLiteralTypeAnnotation","isClassImplements","isDeclareClass","isDeclareFunction","isDeclareInterface","isDeclareModule","isDeclareModuleExports","isDeclareTypeAlias","isDeclareOpaqueType","isDeclareVariable","isDeclareExportDeclaration","isDeclareExportAllDeclaration","isDeclaredPredicate","isExistsTypeAnnotation","isFunctionTypeAnnotation","isFunctionTypeParam","isGenericTypeAnnotation","isInferredPredicate","isInterfaceExtends","isInterfaceDeclaration","isInterfaceTypeAnnotation","isIntersectionTypeAnnotation","isMixedTypeAnnotation","isEmptyTypeAnnotation","isNullableTypeAnnotation","isNumberLiteralTypeAnnotation","isNumberTypeAnnotation","isObjectTypeAnnotation","isObjectTypeInternalSlot","isObjectTypeCallProperty","isObjectTypeIndexer","isObjectTypeProperty","isObjectTypeSpreadProperty","isOpaqueType","isQualifiedTypeIdentifier","isStringLiteralTypeAnnotation","isStringTypeAnnotation","isSymbolTypeAnnotation","isThisTypeAnnotation","isTupleTypeAnnotation","isTypeofTypeAnnotation","isTypeAlias","isTypeAnnotation","isTypeCastExpression","isTypeParameter","isTypeParameterDeclaration","isTypeParameterInstantiation","isUnionTypeAnnotation","isVariance","isVoidTypeAnnotation","isEnumDeclaration","isEnumBooleanBody","isEnumNumberBody","isEnumStringBody","isEnumSymbolBody","isEnumBooleanMember","isEnumNumberMember","isEnumStringMember","isEnumDefaultedMember","isIndexedAccessType","isOptionalIndexedAccessType","isJSXAttribute","isJSXClosingElement","isJSXElement","isJSXEmptyExpression","isJSXExpressionContainer","isJSXSpreadChild","isJSXIdentifier","isJSXMemberExpression","isJSXNamespacedName","isJSXOpeningElement","isJSXSpreadAttribute","isJSXText","isJSXFragment","isJSXOpeningFragment","isJSXClosingFragment","isNoop","isPlaceholder","isV8IntrinsicIdentifier","isArgumentPlaceholder","isBindExpression","isImportAttribute","isDecorator","isDoExpression","isExportDefaultSpecifier","isRecordExpression","isTupleExpression","isDecimalLiteral","isModuleExpression","isTopicReference","isPipelineTopicExpression","isPipelineBareFunction","isPipelinePrimaryTopicReference","isTSParameterProperty","isTSDeclareFunction","isTSDeclareMethod","isTSQualifiedName","isTSCallSignatureDeclaration","isTSConstructSignatureDeclaration","isTSPropertySignature","isTSMethodSignature","isTSIndexSignature","isTSAnyKeyword","isTSBooleanKeyword","isTSBigIntKeyword","isTSIntrinsicKeyword","isTSNeverKeyword","isTSNullKeyword","isTSNumberKeyword","isTSObjectKeyword","isTSStringKeyword","isTSSymbolKeyword","isTSUndefinedKeyword","isTSUnknownKeyword","isTSVoidKeyword","isTSThisType","isTSFunctionType","isTSConstructorType","isTSTypeReference","isTSTypePredicate","isTSTypeQuery","isTSTypeLiteral","isTSArrayType","isTSTupleType","isTSOptionalType","isTSRestType","isTSNamedTupleMember","isTSUnionType","isTSIntersectionType","isTSConditionalType","isTSInferType","isTSParenthesizedType","isTSTypeOperator","isTSIndexedAccessType","isTSMappedType","isTSLiteralType","isTSExpressionWithTypeArguments","isTSInterfaceDeclaration","isTSInterfaceBody","isTSTypeAliasDeclaration","isTSInstantiationExpression","isTSAsExpression","isTSSatisfiesExpression","isTSTypeAssertion","isTSEnumDeclaration","isTSEnumMember","isTSModuleDeclaration","isTSModuleBlock","isTSImportType","isTSImportEqualsDeclaration","isTSExternalModuleReference","isTSNonNullExpression","isTSExportAssignment","isTSNamespaceExportDeclaration","isTSTypeAnnotation","isTSTypeParameterInstantiation","isTSTypeParameterDeclaration","isTSTypeParameter","isStandardized","expectedNode","isExpression","isBinary","isScopable","isBlockParent","isBlock","isStatement","isTerminatorless","isCompletionStatement","isConditional","isLoop","isWhile","isExpressionWrapper","isFor","isForXStatement","isFunction","isFunctionParent","isPureish","isDeclaration","isPatternLike","isLVal","isTSEntityName","isLiteral","isImmutable","isUserWhitespacable","isMethod","isObjectMember","isProperty","isUnaryLike","isPattern","isClass","isImportOrExportDeclaration","isExportDeclaration","isModuleSpecifier","isAccessor","isPrivate","isFlow","isFlowType","isFlowBaseAnnotation","isFlowDeclaration","isFlowPredicate","isEnumBody","isEnumMember","isJSX","isMiscellaneous","isTypeScript","isTSTypeElement","isTSType","isTSBaseType","isNumberLiteral","deprecationWarning","isRegexLiteral","isRestProperty","isSpreadProperty","isModuleDeclaration"],"sources":["../../../src/validators/generated/index.ts"],"sourcesContent":["/*\n * This file is auto-generated! Do not modify it directly.\n * To re-generate run 'make build'\n */\nimport shallowEqual from \"../../utils/shallowEqual\";\nimport type * as t from \"../..\";\nimport deprecationWarning from \"../../utils/deprecationWarning\";\n\nexport function isArrayExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ArrayExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ArrayExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isAssignmentExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.AssignmentExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"AssignmentExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isBinaryExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.BinaryExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"BinaryExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isInterpreterDirective(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.InterpreterDirective {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"InterpreterDirective\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDirective(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Directive {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"Directive\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDirectiveLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DirectiveLiteral {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DirectiveLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isBlockStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.BlockStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"BlockStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isBreakStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.BreakStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"BreakStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isCallExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.CallExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"CallExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isCatchClause(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.CatchClause {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"CatchClause\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isConditionalExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ConditionalExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ConditionalExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isContinueStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ContinueStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ContinueStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDebuggerStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DebuggerStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DebuggerStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDoWhileStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DoWhileStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DoWhileStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEmptyStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EmptyStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"EmptyStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isExpressionStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ExpressionStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ExpressionStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFile(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.File {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"File\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isForInStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ForInStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ForInStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isForStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ForStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ForStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFunctionDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.FunctionDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"FunctionDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFunctionExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.FunctionExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"FunctionExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isIdentifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Identifier {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"Identifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isIfStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.IfStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"IfStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isLabeledStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.LabeledStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"LabeledStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isStringLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.StringLiteral {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"StringLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isNumericLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.NumericLiteral {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"NumericLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isNullLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.NullLiteral {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"NullLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isBooleanLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.BooleanLiteral {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"BooleanLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isRegExpLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.RegExpLiteral {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"RegExpLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isLogicalExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.LogicalExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"LogicalExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isMemberExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.MemberExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"MemberExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isNewExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.NewExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"NewExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isProgram(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Program {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"Program\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isObjectExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ObjectExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ObjectExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isObjectMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ObjectMethod {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ObjectMethod\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isObjectProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ObjectProperty {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ObjectProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isRestElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.RestElement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"RestElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isReturnStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ReturnStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ReturnStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isSequenceExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.SequenceExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"SequenceExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isParenthesizedExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ParenthesizedExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ParenthesizedExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isSwitchCase(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.SwitchCase {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"SwitchCase\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isSwitchStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.SwitchStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"SwitchStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isThisExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ThisExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ThisExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isThrowStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ThrowStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ThrowStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTryStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TryStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TryStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isUnaryExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.UnaryExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"UnaryExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isUpdateExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.UpdateExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"UpdateExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isVariableDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.VariableDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"VariableDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isVariableDeclarator(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.VariableDeclarator {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"VariableDeclarator\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isWhileStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.WhileStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"WhileStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isWithStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.WithStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"WithStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isAssignmentPattern(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.AssignmentPattern {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"AssignmentPattern\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isArrayPattern(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ArrayPattern {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ArrayPattern\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isArrowFunctionExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ArrowFunctionExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ArrowFunctionExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isClassBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ClassBody {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ClassBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isClassExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ClassExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ClassExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isClassDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ClassDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ClassDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isExportAllDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ExportAllDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ExportAllDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isExportDefaultDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ExportDefaultDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ExportDefaultDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isExportNamedDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ExportNamedDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ExportNamedDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isExportSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ExportSpecifier {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ExportSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isForOfStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ForOfStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ForOfStatement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isImportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ImportDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ImportDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isImportDefaultSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ImportDefaultSpecifier {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ImportDefaultSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isImportNamespaceSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ImportNamespaceSpecifier {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ImportNamespaceSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isImportSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ImportSpecifier {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ImportSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isMetaProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.MetaProperty {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"MetaProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isClassMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ClassMethod {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ClassMethod\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isObjectPattern(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ObjectPattern {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ObjectPattern\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isSpreadElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.SpreadElement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"SpreadElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isSuper(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Super {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"Super\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTaggedTemplateExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TaggedTemplateExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TaggedTemplateExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTemplateElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TemplateElement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TemplateElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTemplateLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TemplateLiteral {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TemplateLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isYieldExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.YieldExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"YieldExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isAwaitExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.AwaitExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"AwaitExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isImport(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Import {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"Import\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isBigIntLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.BigIntLiteral {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"BigIntLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isExportNamespaceSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ExportNamespaceSpecifier {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ExportNamespaceSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isOptionalMemberExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.OptionalMemberExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"OptionalMemberExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isOptionalCallExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.OptionalCallExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"OptionalCallExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isClassProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ClassProperty {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ClassProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isClassAccessorProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ClassAccessorProperty {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ClassAccessorProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isClassPrivateProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ClassPrivateProperty {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ClassPrivateProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isClassPrivateMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ClassPrivateMethod {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ClassPrivateMethod\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isPrivateName(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.PrivateName {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"PrivateName\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isStaticBlock(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.StaticBlock {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"StaticBlock\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isAnyTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.AnyTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"AnyTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isArrayTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ArrayTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ArrayTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isBooleanTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.BooleanTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"BooleanTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isBooleanLiteralTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.BooleanLiteralTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"BooleanLiteralTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isNullLiteralTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.NullLiteralTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"NullLiteralTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isClassImplements(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ClassImplements {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ClassImplements\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclareClass(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DeclareClass {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DeclareClass\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclareFunction(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DeclareFunction {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DeclareFunction\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclareInterface(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DeclareInterface {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DeclareInterface\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclareModule(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DeclareModule {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DeclareModule\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclareModuleExports(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DeclareModuleExports {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DeclareModuleExports\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclareTypeAlias(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DeclareTypeAlias {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DeclareTypeAlias\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclareOpaqueType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DeclareOpaqueType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DeclareOpaqueType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclareVariable(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DeclareVariable {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DeclareVariable\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclareExportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DeclareExportDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DeclareExportDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclareExportAllDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DeclareExportAllDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DeclareExportAllDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclaredPredicate(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DeclaredPredicate {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DeclaredPredicate\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isExistsTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ExistsTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ExistsTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFunctionTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.FunctionTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"FunctionTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFunctionTypeParam(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.FunctionTypeParam {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"FunctionTypeParam\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isGenericTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.GenericTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"GenericTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isInferredPredicate(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.InferredPredicate {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"InferredPredicate\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isInterfaceExtends(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.InterfaceExtends {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"InterfaceExtends\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isInterfaceDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.InterfaceDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"InterfaceDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isInterfaceTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.InterfaceTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"InterfaceTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isIntersectionTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.IntersectionTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"IntersectionTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isMixedTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.MixedTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"MixedTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEmptyTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EmptyTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"EmptyTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isNullableTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.NullableTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"NullableTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isNumberLiteralTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.NumberLiteralTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"NumberLiteralTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isNumberTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.NumberTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"NumberTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isObjectTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ObjectTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ObjectTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isObjectTypeInternalSlot(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ObjectTypeInternalSlot {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ObjectTypeInternalSlot\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isObjectTypeCallProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ObjectTypeCallProperty {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ObjectTypeCallProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isObjectTypeIndexer(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ObjectTypeIndexer {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ObjectTypeIndexer\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isObjectTypeProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ObjectTypeProperty {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ObjectTypeProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isObjectTypeSpreadProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ObjectTypeSpreadProperty {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ObjectTypeSpreadProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isOpaqueType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.OpaqueType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"OpaqueType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isQualifiedTypeIdentifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.QualifiedTypeIdentifier {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"QualifiedTypeIdentifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isStringLiteralTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.StringLiteralTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"StringLiteralTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isStringTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.StringTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"StringTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isSymbolTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.SymbolTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"SymbolTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isThisTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ThisTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ThisTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTupleTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TupleTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TupleTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTypeofTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TypeofTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TypeofTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTypeAlias(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TypeAlias {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TypeAlias\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTypeCastExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TypeCastExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TypeCastExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTypeParameter(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TypeParameter {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TypeParameter\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTypeParameterDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TypeParameterDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TypeParameterDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTypeParameterInstantiation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TypeParameterInstantiation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TypeParameterInstantiation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isUnionTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.UnionTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"UnionTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isVariance(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Variance {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"Variance\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isVoidTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.VoidTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"VoidTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEnumDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EnumDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"EnumDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEnumBooleanBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EnumBooleanBody {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"EnumBooleanBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEnumNumberBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EnumNumberBody {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"EnumNumberBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEnumStringBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EnumStringBody {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"EnumStringBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEnumSymbolBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EnumSymbolBody {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"EnumSymbolBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEnumBooleanMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EnumBooleanMember {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"EnumBooleanMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEnumNumberMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EnumNumberMember {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"EnumNumberMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEnumStringMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EnumStringMember {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"EnumStringMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEnumDefaultedMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EnumDefaultedMember {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"EnumDefaultedMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isIndexedAccessType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.IndexedAccessType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"IndexedAccessType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isOptionalIndexedAccessType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.OptionalIndexedAccessType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"OptionalIndexedAccessType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXAttribute(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXAttribute {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXAttribute\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXClosingElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXClosingElement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXClosingElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXElement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXEmptyExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXEmptyExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXEmptyExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXExpressionContainer(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXExpressionContainer {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXExpressionContainer\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXSpreadChild(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXSpreadChild {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXSpreadChild\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXIdentifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXIdentifier {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXIdentifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXMemberExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXMemberExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXMemberExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXNamespacedName(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXNamespacedName {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXNamespacedName\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXOpeningElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXOpeningElement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXOpeningElement\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXSpreadAttribute(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXSpreadAttribute {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXSpreadAttribute\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXText(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXText {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXText\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXFragment(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXFragment {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXFragment\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXOpeningFragment(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXOpeningFragment {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXOpeningFragment\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSXClosingFragment(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSXClosingFragment {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"JSXClosingFragment\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isNoop(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Noop {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"Noop\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isPlaceholder(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Placeholder {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"Placeholder\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isV8IntrinsicIdentifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.V8IntrinsicIdentifier {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"V8IntrinsicIdentifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isArgumentPlaceholder(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ArgumentPlaceholder {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ArgumentPlaceholder\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isBindExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.BindExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"BindExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isImportAttribute(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ImportAttribute {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ImportAttribute\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDecorator(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Decorator {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"Decorator\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDoExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DoExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DoExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isExportDefaultSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ExportDefaultSpecifier {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ExportDefaultSpecifier\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isRecordExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.RecordExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"RecordExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTupleExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TupleExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TupleExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDecimalLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.DecimalLiteral {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"DecimalLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isModuleExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ModuleExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"ModuleExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTopicReference(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TopicReference {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TopicReference\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isPipelineTopicExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.PipelineTopicExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"PipelineTopicExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isPipelineBareFunction(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.PipelineBareFunction {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"PipelineBareFunction\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isPipelinePrimaryTopicReference(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.PipelinePrimaryTopicReference {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"PipelinePrimaryTopicReference\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSParameterProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSParameterProperty {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSParameterProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSDeclareFunction(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSDeclareFunction {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSDeclareFunction\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSDeclareMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSDeclareMethod {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSDeclareMethod\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSQualifiedName(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSQualifiedName {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSQualifiedName\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSCallSignatureDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSCallSignatureDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSCallSignatureDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSConstructSignatureDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSConstructSignatureDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSConstructSignatureDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSPropertySignature(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSPropertySignature {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSPropertySignature\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSMethodSignature(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSMethodSignature {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSMethodSignature\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSIndexSignature(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSIndexSignature {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSIndexSignature\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSAnyKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSAnyKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSAnyKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSBooleanKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSBooleanKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSBooleanKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSBigIntKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSBigIntKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSBigIntKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSIntrinsicKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSIntrinsicKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSIntrinsicKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSNeverKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSNeverKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSNeverKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSNullKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSNullKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSNullKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSNumberKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSNumberKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSNumberKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSObjectKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSObjectKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSObjectKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSStringKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSStringKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSStringKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSSymbolKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSSymbolKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSSymbolKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSUndefinedKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSUndefinedKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSUndefinedKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSUnknownKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSUnknownKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSUnknownKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSVoidKeyword(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSVoidKeyword {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSVoidKeyword\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSThisType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSThisType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSThisType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSFunctionType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSFunctionType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSFunctionType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSConstructorType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSConstructorType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSConstructorType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypeReference(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypeReference {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTypeReference\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypePredicate(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypePredicate {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTypePredicate\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypeQuery(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypeQuery {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTypeQuery\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypeLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypeLiteral {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTypeLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSArrayType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSArrayType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSArrayType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTupleType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTupleType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTupleType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSOptionalType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSOptionalType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSOptionalType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSRestType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSRestType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSRestType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSNamedTupleMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSNamedTupleMember {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSNamedTupleMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSUnionType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSUnionType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSUnionType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSIntersectionType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSIntersectionType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSIntersectionType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSConditionalType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSConditionalType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSConditionalType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSInferType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSInferType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSInferType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSParenthesizedType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSParenthesizedType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSParenthesizedType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypeOperator(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypeOperator {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTypeOperator\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSIndexedAccessType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSIndexedAccessType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSIndexedAccessType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSMappedType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSMappedType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSMappedType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSLiteralType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSLiteralType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSLiteralType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSExpressionWithTypeArguments(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSExpressionWithTypeArguments {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSExpressionWithTypeArguments\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSInterfaceDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSInterfaceDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSInterfaceDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSInterfaceBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSInterfaceBody {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSInterfaceBody\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypeAliasDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypeAliasDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTypeAliasDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSInstantiationExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSInstantiationExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSInstantiationExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSAsExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSAsExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSAsExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSSatisfiesExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSSatisfiesExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSSatisfiesExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypeAssertion(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypeAssertion {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTypeAssertion\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSEnumDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSEnumDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSEnumDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSEnumMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSEnumMember {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSEnumMember\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSModuleDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSModuleDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSModuleDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSModuleBlock(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSModuleBlock {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSModuleBlock\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSImportType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSImportType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSImportType\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSImportEqualsDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSImportEqualsDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSImportEqualsDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSExternalModuleReference(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSExternalModuleReference {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSExternalModuleReference\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSNonNullExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSNonNullExpression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSNonNullExpression\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSExportAssignment(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSExportAssignment {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSExportAssignment\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSNamespaceExportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSNamespaceExportDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSNamespaceExportDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypeAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypeAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTypeAnnotation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypeParameterInstantiation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypeParameterInstantiation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTypeParameterInstantiation\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypeParameterDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypeParameterDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTypeParameterDeclaration\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypeParameter(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypeParameter {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"TSTypeParameter\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isStandardized(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Standardized {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"ArrayExpression\" === nodeType ||\n    \"AssignmentExpression\" === nodeType ||\n    \"BinaryExpression\" === nodeType ||\n    \"InterpreterDirective\" === nodeType ||\n    \"Directive\" === nodeType ||\n    \"DirectiveLiteral\" === nodeType ||\n    \"BlockStatement\" === nodeType ||\n    \"BreakStatement\" === nodeType ||\n    \"CallExpression\" === nodeType ||\n    \"CatchClause\" === nodeType ||\n    \"ConditionalExpression\" === nodeType ||\n    \"ContinueStatement\" === nodeType ||\n    \"DebuggerStatement\" === nodeType ||\n    \"DoWhileStatement\" === nodeType ||\n    \"EmptyStatement\" === nodeType ||\n    \"ExpressionStatement\" === nodeType ||\n    \"File\" === nodeType ||\n    \"ForInStatement\" === nodeType ||\n    \"ForStatement\" === nodeType ||\n    \"FunctionDeclaration\" === nodeType ||\n    \"FunctionExpression\" === nodeType ||\n    \"Identifier\" === nodeType ||\n    \"IfStatement\" === nodeType ||\n    \"LabeledStatement\" === nodeType ||\n    \"StringLiteral\" === nodeType ||\n    \"NumericLiteral\" === nodeType ||\n    \"NullLiteral\" === nodeType ||\n    \"BooleanLiteral\" === nodeType ||\n    \"RegExpLiteral\" === nodeType ||\n    \"LogicalExpression\" === nodeType ||\n    \"MemberExpression\" === nodeType ||\n    \"NewExpression\" === nodeType ||\n    \"Program\" === nodeType ||\n    \"ObjectExpression\" === nodeType ||\n    \"ObjectMethod\" === nodeType ||\n    \"ObjectProperty\" === nodeType ||\n    \"RestElement\" === nodeType ||\n    \"ReturnStatement\" === nodeType ||\n    \"SequenceExpression\" === nodeType ||\n    \"ParenthesizedExpression\" === nodeType ||\n    \"SwitchCase\" === nodeType ||\n    \"SwitchStatement\" === nodeType ||\n    \"ThisExpression\" === nodeType ||\n    \"ThrowStatement\" === nodeType ||\n    \"TryStatement\" === nodeType ||\n    \"UnaryExpression\" === nodeType ||\n    \"UpdateExpression\" === nodeType ||\n    \"VariableDeclaration\" === nodeType ||\n    \"VariableDeclarator\" === nodeType ||\n    \"WhileStatement\" === nodeType ||\n    \"WithStatement\" === nodeType ||\n    \"AssignmentPattern\" === nodeType ||\n    \"ArrayPattern\" === nodeType ||\n    \"ArrowFunctionExpression\" === nodeType ||\n    \"ClassBody\" === nodeType ||\n    \"ClassExpression\" === nodeType ||\n    \"ClassDeclaration\" === nodeType ||\n    \"ExportAllDeclaration\" === nodeType ||\n    \"ExportDefaultDeclaration\" === nodeType ||\n    \"ExportNamedDeclaration\" === nodeType ||\n    \"ExportSpecifier\" === nodeType ||\n    \"ForOfStatement\" === nodeType ||\n    \"ImportDeclaration\" === nodeType ||\n    \"ImportDefaultSpecifier\" === nodeType ||\n    \"ImportNamespaceSpecifier\" === nodeType ||\n    \"ImportSpecifier\" === nodeType ||\n    \"MetaProperty\" === nodeType ||\n    \"ClassMethod\" === nodeType ||\n    \"ObjectPattern\" === nodeType ||\n    \"SpreadElement\" === nodeType ||\n    \"Super\" === nodeType ||\n    \"TaggedTemplateExpression\" === nodeType ||\n    \"TemplateElement\" === nodeType ||\n    \"TemplateLiteral\" === nodeType ||\n    \"YieldExpression\" === nodeType ||\n    \"AwaitExpression\" === nodeType ||\n    \"Import\" === nodeType ||\n    \"BigIntLiteral\" === nodeType ||\n    \"ExportNamespaceSpecifier\" === nodeType ||\n    \"OptionalMemberExpression\" === nodeType ||\n    \"OptionalCallExpression\" === nodeType ||\n    \"ClassProperty\" === nodeType ||\n    \"ClassAccessorProperty\" === nodeType ||\n    \"ClassPrivateProperty\" === nodeType ||\n    \"ClassPrivateMethod\" === nodeType ||\n    \"PrivateName\" === nodeType ||\n    \"StaticBlock\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      (\"Identifier\" === (node as t.Placeholder).expectedNode ||\n        \"StringLiteral\" === (node as t.Placeholder).expectedNode ||\n        \"BlockStatement\" === (node as t.Placeholder).expectedNode ||\n        \"ClassBody\" === (node as t.Placeholder).expectedNode))\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isExpression(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Expression {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"ArrayExpression\" === nodeType ||\n    \"AssignmentExpression\" === nodeType ||\n    \"BinaryExpression\" === nodeType ||\n    \"CallExpression\" === nodeType ||\n    \"ConditionalExpression\" === nodeType ||\n    \"FunctionExpression\" === nodeType ||\n    \"Identifier\" === nodeType ||\n    \"StringLiteral\" === nodeType ||\n    \"NumericLiteral\" === nodeType ||\n    \"NullLiteral\" === nodeType ||\n    \"BooleanLiteral\" === nodeType ||\n    \"RegExpLiteral\" === nodeType ||\n    \"LogicalExpression\" === nodeType ||\n    \"MemberExpression\" === nodeType ||\n    \"NewExpression\" === nodeType ||\n    \"ObjectExpression\" === nodeType ||\n    \"SequenceExpression\" === nodeType ||\n    \"ParenthesizedExpression\" === nodeType ||\n    \"ThisExpression\" === nodeType ||\n    \"UnaryExpression\" === nodeType ||\n    \"UpdateExpression\" === nodeType ||\n    \"ArrowFunctionExpression\" === nodeType ||\n    \"ClassExpression\" === nodeType ||\n    \"MetaProperty\" === nodeType ||\n    \"Super\" === nodeType ||\n    \"TaggedTemplateExpression\" === nodeType ||\n    \"TemplateLiteral\" === nodeType ||\n    \"YieldExpression\" === nodeType ||\n    \"AwaitExpression\" === nodeType ||\n    \"Import\" === nodeType ||\n    \"BigIntLiteral\" === nodeType ||\n    \"OptionalMemberExpression\" === nodeType ||\n    \"OptionalCallExpression\" === nodeType ||\n    \"TypeCastExpression\" === nodeType ||\n    \"JSXElement\" === nodeType ||\n    \"JSXFragment\" === nodeType ||\n    \"BindExpression\" === nodeType ||\n    \"DoExpression\" === nodeType ||\n    \"RecordExpression\" === nodeType ||\n    \"TupleExpression\" === nodeType ||\n    \"DecimalLiteral\" === nodeType ||\n    \"ModuleExpression\" === nodeType ||\n    \"TopicReference\" === nodeType ||\n    \"PipelineTopicExpression\" === nodeType ||\n    \"PipelineBareFunction\" === nodeType ||\n    \"PipelinePrimaryTopicReference\" === nodeType ||\n    \"TSInstantiationExpression\" === nodeType ||\n    \"TSAsExpression\" === nodeType ||\n    \"TSSatisfiesExpression\" === nodeType ||\n    \"TSTypeAssertion\" === nodeType ||\n    \"TSNonNullExpression\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      (\"Expression\" === (node as t.Placeholder).expectedNode ||\n        \"Identifier\" === (node as t.Placeholder).expectedNode ||\n        \"StringLiteral\" === (node as t.Placeholder).expectedNode))\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isBinary(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Binary {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\"BinaryExpression\" === nodeType || \"LogicalExpression\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isScopable(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Scopable {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"BlockStatement\" === nodeType ||\n    \"CatchClause\" === nodeType ||\n    \"DoWhileStatement\" === nodeType ||\n    \"ForInStatement\" === nodeType ||\n    \"ForStatement\" === nodeType ||\n    \"FunctionDeclaration\" === nodeType ||\n    \"FunctionExpression\" === nodeType ||\n    \"Program\" === nodeType ||\n    \"ObjectMethod\" === nodeType ||\n    \"SwitchStatement\" === nodeType ||\n    \"WhileStatement\" === nodeType ||\n    \"ArrowFunctionExpression\" === nodeType ||\n    \"ClassExpression\" === nodeType ||\n    \"ClassDeclaration\" === nodeType ||\n    \"ForOfStatement\" === nodeType ||\n    \"ClassMethod\" === nodeType ||\n    \"ClassPrivateMethod\" === nodeType ||\n    \"StaticBlock\" === nodeType ||\n    \"TSModuleBlock\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      \"BlockStatement\" === (node as t.Placeholder).expectedNode)\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isBlockParent(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.BlockParent {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"BlockStatement\" === nodeType ||\n    \"CatchClause\" === nodeType ||\n    \"DoWhileStatement\" === nodeType ||\n    \"ForInStatement\" === nodeType ||\n    \"ForStatement\" === nodeType ||\n    \"FunctionDeclaration\" === nodeType ||\n    \"FunctionExpression\" === nodeType ||\n    \"Program\" === nodeType ||\n    \"ObjectMethod\" === nodeType ||\n    \"SwitchStatement\" === nodeType ||\n    \"WhileStatement\" === nodeType ||\n    \"ArrowFunctionExpression\" === nodeType ||\n    \"ForOfStatement\" === nodeType ||\n    \"ClassMethod\" === nodeType ||\n    \"ClassPrivateMethod\" === nodeType ||\n    \"StaticBlock\" === nodeType ||\n    \"TSModuleBlock\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      \"BlockStatement\" === (node as t.Placeholder).expectedNode)\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isBlock(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Block {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"BlockStatement\" === nodeType ||\n    \"Program\" === nodeType ||\n    \"TSModuleBlock\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      \"BlockStatement\" === (node as t.Placeholder).expectedNode)\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Statement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"BlockStatement\" === nodeType ||\n    \"BreakStatement\" === nodeType ||\n    \"ContinueStatement\" === nodeType ||\n    \"DebuggerStatement\" === nodeType ||\n    \"DoWhileStatement\" === nodeType ||\n    \"EmptyStatement\" === nodeType ||\n    \"ExpressionStatement\" === nodeType ||\n    \"ForInStatement\" === nodeType ||\n    \"ForStatement\" === nodeType ||\n    \"FunctionDeclaration\" === nodeType ||\n    \"IfStatement\" === nodeType ||\n    \"LabeledStatement\" === nodeType ||\n    \"ReturnStatement\" === nodeType ||\n    \"SwitchStatement\" === nodeType ||\n    \"ThrowStatement\" === nodeType ||\n    \"TryStatement\" === nodeType ||\n    \"VariableDeclaration\" === nodeType ||\n    \"WhileStatement\" === nodeType ||\n    \"WithStatement\" === nodeType ||\n    \"ClassDeclaration\" === nodeType ||\n    \"ExportAllDeclaration\" === nodeType ||\n    \"ExportDefaultDeclaration\" === nodeType ||\n    \"ExportNamedDeclaration\" === nodeType ||\n    \"ForOfStatement\" === nodeType ||\n    \"ImportDeclaration\" === nodeType ||\n    \"DeclareClass\" === nodeType ||\n    \"DeclareFunction\" === nodeType ||\n    \"DeclareInterface\" === nodeType ||\n    \"DeclareModule\" === nodeType ||\n    \"DeclareModuleExports\" === nodeType ||\n    \"DeclareTypeAlias\" === nodeType ||\n    \"DeclareOpaqueType\" === nodeType ||\n    \"DeclareVariable\" === nodeType ||\n    \"DeclareExportDeclaration\" === nodeType ||\n    \"DeclareExportAllDeclaration\" === nodeType ||\n    \"InterfaceDeclaration\" === nodeType ||\n    \"OpaqueType\" === nodeType ||\n    \"TypeAlias\" === nodeType ||\n    \"EnumDeclaration\" === nodeType ||\n    \"TSDeclareFunction\" === nodeType ||\n    \"TSInterfaceDeclaration\" === nodeType ||\n    \"TSTypeAliasDeclaration\" === nodeType ||\n    \"TSEnumDeclaration\" === nodeType ||\n    \"TSModuleDeclaration\" === nodeType ||\n    \"TSImportEqualsDeclaration\" === nodeType ||\n    \"TSExportAssignment\" === nodeType ||\n    \"TSNamespaceExportDeclaration\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      (\"Statement\" === (node as t.Placeholder).expectedNode ||\n        \"Declaration\" === (node as t.Placeholder).expectedNode ||\n        \"BlockStatement\" === (node as t.Placeholder).expectedNode))\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTerminatorless(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Terminatorless {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"BreakStatement\" === nodeType ||\n    \"ContinueStatement\" === nodeType ||\n    \"ReturnStatement\" === nodeType ||\n    \"ThrowStatement\" === nodeType ||\n    \"YieldExpression\" === nodeType ||\n    \"AwaitExpression\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isCompletionStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.CompletionStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"BreakStatement\" === nodeType ||\n    \"ContinueStatement\" === nodeType ||\n    \"ReturnStatement\" === nodeType ||\n    \"ThrowStatement\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isConditional(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Conditional {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\"ConditionalExpression\" === nodeType || \"IfStatement\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isLoop(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Loop {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"DoWhileStatement\" === nodeType ||\n    \"ForInStatement\" === nodeType ||\n    \"ForStatement\" === nodeType ||\n    \"WhileStatement\" === nodeType ||\n    \"ForOfStatement\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isWhile(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.While {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\"DoWhileStatement\" === nodeType || \"WhileStatement\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isExpressionWrapper(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ExpressionWrapper {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"ExpressionStatement\" === nodeType ||\n    \"ParenthesizedExpression\" === nodeType ||\n    \"TypeCastExpression\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFor(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.For {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"ForInStatement\" === nodeType ||\n    \"ForStatement\" === nodeType ||\n    \"ForOfStatement\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isForXStatement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ForXStatement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\"ForInStatement\" === nodeType || \"ForOfStatement\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFunction(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Function {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"FunctionDeclaration\" === nodeType ||\n    \"FunctionExpression\" === nodeType ||\n    \"ObjectMethod\" === nodeType ||\n    \"ArrowFunctionExpression\" === nodeType ||\n    \"ClassMethod\" === nodeType ||\n    \"ClassPrivateMethod\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFunctionParent(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.FunctionParent {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"FunctionDeclaration\" === nodeType ||\n    \"FunctionExpression\" === nodeType ||\n    \"ObjectMethod\" === nodeType ||\n    \"ArrowFunctionExpression\" === nodeType ||\n    \"ClassMethod\" === nodeType ||\n    \"ClassPrivateMethod\" === nodeType ||\n    \"StaticBlock\" === nodeType ||\n    \"TSModuleBlock\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isPureish(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Pureish {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"FunctionDeclaration\" === nodeType ||\n    \"FunctionExpression\" === nodeType ||\n    \"StringLiteral\" === nodeType ||\n    \"NumericLiteral\" === nodeType ||\n    \"NullLiteral\" === nodeType ||\n    \"BooleanLiteral\" === nodeType ||\n    \"RegExpLiteral\" === nodeType ||\n    \"ArrowFunctionExpression\" === nodeType ||\n    \"BigIntLiteral\" === nodeType ||\n    \"DecimalLiteral\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      \"StringLiteral\" === (node as t.Placeholder).expectedNode)\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Declaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"FunctionDeclaration\" === nodeType ||\n    \"VariableDeclaration\" === nodeType ||\n    \"ClassDeclaration\" === nodeType ||\n    \"ExportAllDeclaration\" === nodeType ||\n    \"ExportDefaultDeclaration\" === nodeType ||\n    \"ExportNamedDeclaration\" === nodeType ||\n    \"ImportDeclaration\" === nodeType ||\n    \"DeclareClass\" === nodeType ||\n    \"DeclareFunction\" === nodeType ||\n    \"DeclareInterface\" === nodeType ||\n    \"DeclareModule\" === nodeType ||\n    \"DeclareModuleExports\" === nodeType ||\n    \"DeclareTypeAlias\" === nodeType ||\n    \"DeclareOpaqueType\" === nodeType ||\n    \"DeclareVariable\" === nodeType ||\n    \"DeclareExportDeclaration\" === nodeType ||\n    \"DeclareExportAllDeclaration\" === nodeType ||\n    \"InterfaceDeclaration\" === nodeType ||\n    \"OpaqueType\" === nodeType ||\n    \"TypeAlias\" === nodeType ||\n    \"EnumDeclaration\" === nodeType ||\n    \"TSDeclareFunction\" === nodeType ||\n    \"TSInterfaceDeclaration\" === nodeType ||\n    \"TSTypeAliasDeclaration\" === nodeType ||\n    \"TSEnumDeclaration\" === nodeType ||\n    \"TSModuleDeclaration\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      \"Declaration\" === (node as t.Placeholder).expectedNode)\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isPatternLike(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.PatternLike {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"Identifier\" === nodeType ||\n    \"RestElement\" === nodeType ||\n    \"AssignmentPattern\" === nodeType ||\n    \"ArrayPattern\" === nodeType ||\n    \"ObjectPattern\" === nodeType ||\n    \"TSAsExpression\" === nodeType ||\n    \"TSSatisfiesExpression\" === nodeType ||\n    \"TSTypeAssertion\" === nodeType ||\n    \"TSNonNullExpression\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      (\"Pattern\" === (node as t.Placeholder).expectedNode ||\n        \"Identifier\" === (node as t.Placeholder).expectedNode))\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isLVal(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.LVal {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"Identifier\" === nodeType ||\n    \"MemberExpression\" === nodeType ||\n    \"RestElement\" === nodeType ||\n    \"AssignmentPattern\" === nodeType ||\n    \"ArrayPattern\" === nodeType ||\n    \"ObjectPattern\" === nodeType ||\n    \"TSParameterProperty\" === nodeType ||\n    \"TSAsExpression\" === nodeType ||\n    \"TSSatisfiesExpression\" === nodeType ||\n    \"TSTypeAssertion\" === nodeType ||\n    \"TSNonNullExpression\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      (\"Pattern\" === (node as t.Placeholder).expectedNode ||\n        \"Identifier\" === (node as t.Placeholder).expectedNode))\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSEntityName(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSEntityName {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"Identifier\" === nodeType ||\n    \"TSQualifiedName\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      \"Identifier\" === (node as t.Placeholder).expectedNode)\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Literal {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"StringLiteral\" === nodeType ||\n    \"NumericLiteral\" === nodeType ||\n    \"NullLiteral\" === nodeType ||\n    \"BooleanLiteral\" === nodeType ||\n    \"RegExpLiteral\" === nodeType ||\n    \"TemplateLiteral\" === nodeType ||\n    \"BigIntLiteral\" === nodeType ||\n    \"DecimalLiteral\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      \"StringLiteral\" === (node as t.Placeholder).expectedNode)\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isImmutable(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Immutable {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"StringLiteral\" === nodeType ||\n    \"NumericLiteral\" === nodeType ||\n    \"NullLiteral\" === nodeType ||\n    \"BooleanLiteral\" === nodeType ||\n    \"BigIntLiteral\" === nodeType ||\n    \"JSXAttribute\" === nodeType ||\n    \"JSXClosingElement\" === nodeType ||\n    \"JSXElement\" === nodeType ||\n    \"JSXExpressionContainer\" === nodeType ||\n    \"JSXSpreadChild\" === nodeType ||\n    \"JSXOpeningElement\" === nodeType ||\n    \"JSXText\" === nodeType ||\n    \"JSXFragment\" === nodeType ||\n    \"JSXOpeningFragment\" === nodeType ||\n    \"JSXClosingFragment\" === nodeType ||\n    \"DecimalLiteral\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      \"StringLiteral\" === (node as t.Placeholder).expectedNode)\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isUserWhitespacable(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.UserWhitespacable {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"ObjectMethod\" === nodeType ||\n    \"ObjectProperty\" === nodeType ||\n    \"ObjectTypeInternalSlot\" === nodeType ||\n    \"ObjectTypeCallProperty\" === nodeType ||\n    \"ObjectTypeIndexer\" === nodeType ||\n    \"ObjectTypeProperty\" === nodeType ||\n    \"ObjectTypeSpreadProperty\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isMethod(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Method {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"ObjectMethod\" === nodeType ||\n    \"ClassMethod\" === nodeType ||\n    \"ClassPrivateMethod\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isObjectMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ObjectMember {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\"ObjectMethod\" === nodeType || \"ObjectProperty\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Property {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"ObjectProperty\" === nodeType ||\n    \"ClassProperty\" === nodeType ||\n    \"ClassAccessorProperty\" === nodeType ||\n    \"ClassPrivateProperty\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isUnaryLike(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.UnaryLike {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\"UnaryExpression\" === nodeType || \"SpreadElement\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isPattern(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Pattern {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"AssignmentPattern\" === nodeType ||\n    \"ArrayPattern\" === nodeType ||\n    \"ObjectPattern\" === nodeType ||\n    (nodeType === \"Placeholder\" &&\n      \"Pattern\" === (node as t.Placeholder).expectedNode)\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isClass(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Class {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\"ClassExpression\" === nodeType || \"ClassDeclaration\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isImportOrExportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ImportOrExportDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"ExportAllDeclaration\" === nodeType ||\n    \"ExportDefaultDeclaration\" === nodeType ||\n    \"ExportNamedDeclaration\" === nodeType ||\n    \"ImportDeclaration\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isExportDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ExportDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"ExportAllDeclaration\" === nodeType ||\n    \"ExportDefaultDeclaration\" === nodeType ||\n    \"ExportNamedDeclaration\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isModuleSpecifier(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ModuleSpecifier {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"ExportSpecifier\" === nodeType ||\n    \"ImportDefaultSpecifier\" === nodeType ||\n    \"ImportNamespaceSpecifier\" === nodeType ||\n    \"ImportSpecifier\" === nodeType ||\n    \"ExportNamespaceSpecifier\" === nodeType ||\n    \"ExportDefaultSpecifier\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isAccessor(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Accessor {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\"ClassAccessorProperty\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isPrivate(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Private {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"ClassPrivateProperty\" === nodeType ||\n    \"ClassPrivateMethod\" === nodeType ||\n    \"PrivateName\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFlow(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Flow {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"AnyTypeAnnotation\" === nodeType ||\n    \"ArrayTypeAnnotation\" === nodeType ||\n    \"BooleanTypeAnnotation\" === nodeType ||\n    \"BooleanLiteralTypeAnnotation\" === nodeType ||\n    \"NullLiteralTypeAnnotation\" === nodeType ||\n    \"ClassImplements\" === nodeType ||\n    \"DeclareClass\" === nodeType ||\n    \"DeclareFunction\" === nodeType ||\n    \"DeclareInterface\" === nodeType ||\n    \"DeclareModule\" === nodeType ||\n    \"DeclareModuleExports\" === nodeType ||\n    \"DeclareTypeAlias\" === nodeType ||\n    \"DeclareOpaqueType\" === nodeType ||\n    \"DeclareVariable\" === nodeType ||\n    \"DeclareExportDeclaration\" === nodeType ||\n    \"DeclareExportAllDeclaration\" === nodeType ||\n    \"DeclaredPredicate\" === nodeType ||\n    \"ExistsTypeAnnotation\" === nodeType ||\n    \"FunctionTypeAnnotation\" === nodeType ||\n    \"FunctionTypeParam\" === nodeType ||\n    \"GenericTypeAnnotation\" === nodeType ||\n    \"InferredPredicate\" === nodeType ||\n    \"InterfaceExtends\" === nodeType ||\n    \"InterfaceDeclaration\" === nodeType ||\n    \"InterfaceTypeAnnotation\" === nodeType ||\n    \"IntersectionTypeAnnotation\" === nodeType ||\n    \"MixedTypeAnnotation\" === nodeType ||\n    \"EmptyTypeAnnotation\" === nodeType ||\n    \"NullableTypeAnnotation\" === nodeType ||\n    \"NumberLiteralTypeAnnotation\" === nodeType ||\n    \"NumberTypeAnnotation\" === nodeType ||\n    \"ObjectTypeAnnotation\" === nodeType ||\n    \"ObjectTypeInternalSlot\" === nodeType ||\n    \"ObjectTypeCallProperty\" === nodeType ||\n    \"ObjectTypeIndexer\" === nodeType ||\n    \"ObjectTypeProperty\" === nodeType ||\n    \"ObjectTypeSpreadProperty\" === nodeType ||\n    \"OpaqueType\" === nodeType ||\n    \"QualifiedTypeIdentifier\" === nodeType ||\n    \"StringLiteralTypeAnnotation\" === nodeType ||\n    \"StringTypeAnnotation\" === nodeType ||\n    \"SymbolTypeAnnotation\" === nodeType ||\n    \"ThisTypeAnnotation\" === nodeType ||\n    \"TupleTypeAnnotation\" === nodeType ||\n    \"TypeofTypeAnnotation\" === nodeType ||\n    \"TypeAlias\" === nodeType ||\n    \"TypeAnnotation\" === nodeType ||\n    \"TypeCastExpression\" === nodeType ||\n    \"TypeParameter\" === nodeType ||\n    \"TypeParameterDeclaration\" === nodeType ||\n    \"TypeParameterInstantiation\" === nodeType ||\n    \"UnionTypeAnnotation\" === nodeType ||\n    \"Variance\" === nodeType ||\n    \"VoidTypeAnnotation\" === nodeType ||\n    \"EnumDeclaration\" === nodeType ||\n    \"EnumBooleanBody\" === nodeType ||\n    \"EnumNumberBody\" === nodeType ||\n    \"EnumStringBody\" === nodeType ||\n    \"EnumSymbolBody\" === nodeType ||\n    \"EnumBooleanMember\" === nodeType ||\n    \"EnumNumberMember\" === nodeType ||\n    \"EnumStringMember\" === nodeType ||\n    \"EnumDefaultedMember\" === nodeType ||\n    \"IndexedAccessType\" === nodeType ||\n    \"OptionalIndexedAccessType\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFlowType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.FlowType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"AnyTypeAnnotation\" === nodeType ||\n    \"ArrayTypeAnnotation\" === nodeType ||\n    \"BooleanTypeAnnotation\" === nodeType ||\n    \"BooleanLiteralTypeAnnotation\" === nodeType ||\n    \"NullLiteralTypeAnnotation\" === nodeType ||\n    \"ExistsTypeAnnotation\" === nodeType ||\n    \"FunctionTypeAnnotation\" === nodeType ||\n    \"GenericTypeAnnotation\" === nodeType ||\n    \"InterfaceTypeAnnotation\" === nodeType ||\n    \"IntersectionTypeAnnotation\" === nodeType ||\n    \"MixedTypeAnnotation\" === nodeType ||\n    \"EmptyTypeAnnotation\" === nodeType ||\n    \"NullableTypeAnnotation\" === nodeType ||\n    \"NumberLiteralTypeAnnotation\" === nodeType ||\n    \"NumberTypeAnnotation\" === nodeType ||\n    \"ObjectTypeAnnotation\" === nodeType ||\n    \"StringLiteralTypeAnnotation\" === nodeType ||\n    \"StringTypeAnnotation\" === nodeType ||\n    \"SymbolTypeAnnotation\" === nodeType ||\n    \"ThisTypeAnnotation\" === nodeType ||\n    \"TupleTypeAnnotation\" === nodeType ||\n    \"TypeofTypeAnnotation\" === nodeType ||\n    \"UnionTypeAnnotation\" === nodeType ||\n    \"VoidTypeAnnotation\" === nodeType ||\n    \"IndexedAccessType\" === nodeType ||\n    \"OptionalIndexedAccessType\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFlowBaseAnnotation(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.FlowBaseAnnotation {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"AnyTypeAnnotation\" === nodeType ||\n    \"BooleanTypeAnnotation\" === nodeType ||\n    \"NullLiteralTypeAnnotation\" === nodeType ||\n    \"MixedTypeAnnotation\" === nodeType ||\n    \"EmptyTypeAnnotation\" === nodeType ||\n    \"NumberTypeAnnotation\" === nodeType ||\n    \"StringTypeAnnotation\" === nodeType ||\n    \"SymbolTypeAnnotation\" === nodeType ||\n    \"ThisTypeAnnotation\" === nodeType ||\n    \"VoidTypeAnnotation\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFlowDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.FlowDeclaration {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"DeclareClass\" === nodeType ||\n    \"DeclareFunction\" === nodeType ||\n    \"DeclareInterface\" === nodeType ||\n    \"DeclareModule\" === nodeType ||\n    \"DeclareModuleExports\" === nodeType ||\n    \"DeclareTypeAlias\" === nodeType ||\n    \"DeclareOpaqueType\" === nodeType ||\n    \"DeclareVariable\" === nodeType ||\n    \"DeclareExportDeclaration\" === nodeType ||\n    \"DeclareExportAllDeclaration\" === nodeType ||\n    \"InterfaceDeclaration\" === nodeType ||\n    \"OpaqueType\" === nodeType ||\n    \"TypeAlias\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isFlowPredicate(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.FlowPredicate {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\"DeclaredPredicate\" === nodeType || \"InferredPredicate\" === nodeType) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEnumBody(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EnumBody {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"EnumBooleanBody\" === nodeType ||\n    \"EnumNumberBody\" === nodeType ||\n    \"EnumStringBody\" === nodeType ||\n    \"EnumSymbolBody\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isEnumMember(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.EnumMember {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"EnumBooleanMember\" === nodeType ||\n    \"EnumNumberMember\" === nodeType ||\n    \"EnumStringMember\" === nodeType ||\n    \"EnumDefaultedMember\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isJSX(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.JSX {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"JSXAttribute\" === nodeType ||\n    \"JSXClosingElement\" === nodeType ||\n    \"JSXElement\" === nodeType ||\n    \"JSXEmptyExpression\" === nodeType ||\n    \"JSXExpressionContainer\" === nodeType ||\n    \"JSXSpreadChild\" === nodeType ||\n    \"JSXIdentifier\" === nodeType ||\n    \"JSXMemberExpression\" === nodeType ||\n    \"JSXNamespacedName\" === nodeType ||\n    \"JSXOpeningElement\" === nodeType ||\n    \"JSXSpreadAttribute\" === nodeType ||\n    \"JSXText\" === nodeType ||\n    \"JSXFragment\" === nodeType ||\n    \"JSXOpeningFragment\" === nodeType ||\n    \"JSXClosingFragment\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isMiscellaneous(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.Miscellaneous {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"Noop\" === nodeType ||\n    \"Placeholder\" === nodeType ||\n    \"V8IntrinsicIdentifier\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTypeScript(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TypeScript {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"TSParameterProperty\" === nodeType ||\n    \"TSDeclareFunction\" === nodeType ||\n    \"TSDeclareMethod\" === nodeType ||\n    \"TSQualifiedName\" === nodeType ||\n    \"TSCallSignatureDeclaration\" === nodeType ||\n    \"TSConstructSignatureDeclaration\" === nodeType ||\n    \"TSPropertySignature\" === nodeType ||\n    \"TSMethodSignature\" === nodeType ||\n    \"TSIndexSignature\" === nodeType ||\n    \"TSAnyKeyword\" === nodeType ||\n    \"TSBooleanKeyword\" === nodeType ||\n    \"TSBigIntKeyword\" === nodeType ||\n    \"TSIntrinsicKeyword\" === nodeType ||\n    \"TSNeverKeyword\" === nodeType ||\n    \"TSNullKeyword\" === nodeType ||\n    \"TSNumberKeyword\" === nodeType ||\n    \"TSObjectKeyword\" === nodeType ||\n    \"TSStringKeyword\" === nodeType ||\n    \"TSSymbolKeyword\" === nodeType ||\n    \"TSUndefinedKeyword\" === nodeType ||\n    \"TSUnknownKeyword\" === nodeType ||\n    \"TSVoidKeyword\" === nodeType ||\n    \"TSThisType\" === nodeType ||\n    \"TSFunctionType\" === nodeType ||\n    \"TSConstructorType\" === nodeType ||\n    \"TSTypeReference\" === nodeType ||\n    \"TSTypePredicate\" === nodeType ||\n    \"TSTypeQuery\" === nodeType ||\n    \"TSTypeLiteral\" === nodeType ||\n    \"TSArrayType\" === nodeType ||\n    \"TSTupleType\" === nodeType ||\n    \"TSOptionalType\" === nodeType ||\n    \"TSRestType\" === nodeType ||\n    \"TSNamedTupleMember\" === nodeType ||\n    \"TSUnionType\" === nodeType ||\n    \"TSIntersectionType\" === nodeType ||\n    \"TSConditionalType\" === nodeType ||\n    \"TSInferType\" === nodeType ||\n    \"TSParenthesizedType\" === nodeType ||\n    \"TSTypeOperator\" === nodeType ||\n    \"TSIndexedAccessType\" === nodeType ||\n    \"TSMappedType\" === nodeType ||\n    \"TSLiteralType\" === nodeType ||\n    \"TSExpressionWithTypeArguments\" === nodeType ||\n    \"TSInterfaceDeclaration\" === nodeType ||\n    \"TSInterfaceBody\" === nodeType ||\n    \"TSTypeAliasDeclaration\" === nodeType ||\n    \"TSInstantiationExpression\" === nodeType ||\n    \"TSAsExpression\" === nodeType ||\n    \"TSSatisfiesExpression\" === nodeType ||\n    \"TSTypeAssertion\" === nodeType ||\n    \"TSEnumDeclaration\" === nodeType ||\n    \"TSEnumMember\" === nodeType ||\n    \"TSModuleDeclaration\" === nodeType ||\n    \"TSModuleBlock\" === nodeType ||\n    \"TSImportType\" === nodeType ||\n    \"TSImportEqualsDeclaration\" === nodeType ||\n    \"TSExternalModuleReference\" === nodeType ||\n    \"TSNonNullExpression\" === nodeType ||\n    \"TSExportAssignment\" === nodeType ||\n    \"TSNamespaceExportDeclaration\" === nodeType ||\n    \"TSTypeAnnotation\" === nodeType ||\n    \"TSTypeParameterInstantiation\" === nodeType ||\n    \"TSTypeParameterDeclaration\" === nodeType ||\n    \"TSTypeParameter\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSTypeElement(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSTypeElement {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"TSCallSignatureDeclaration\" === nodeType ||\n    \"TSConstructSignatureDeclaration\" === nodeType ||\n    \"TSPropertySignature\" === nodeType ||\n    \"TSMethodSignature\" === nodeType ||\n    \"TSIndexSignature\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"TSAnyKeyword\" === nodeType ||\n    \"TSBooleanKeyword\" === nodeType ||\n    \"TSBigIntKeyword\" === nodeType ||\n    \"TSIntrinsicKeyword\" === nodeType ||\n    \"TSNeverKeyword\" === nodeType ||\n    \"TSNullKeyword\" === nodeType ||\n    \"TSNumberKeyword\" === nodeType ||\n    \"TSObjectKeyword\" === nodeType ||\n    \"TSStringKeyword\" === nodeType ||\n    \"TSSymbolKeyword\" === nodeType ||\n    \"TSUndefinedKeyword\" === nodeType ||\n    \"TSUnknownKeyword\" === nodeType ||\n    \"TSVoidKeyword\" === nodeType ||\n    \"TSThisType\" === nodeType ||\n    \"TSFunctionType\" === nodeType ||\n    \"TSConstructorType\" === nodeType ||\n    \"TSTypeReference\" === nodeType ||\n    \"TSTypePredicate\" === nodeType ||\n    \"TSTypeQuery\" === nodeType ||\n    \"TSTypeLiteral\" === nodeType ||\n    \"TSArrayType\" === nodeType ||\n    \"TSTupleType\" === nodeType ||\n    \"TSOptionalType\" === nodeType ||\n    \"TSRestType\" === nodeType ||\n    \"TSUnionType\" === nodeType ||\n    \"TSIntersectionType\" === nodeType ||\n    \"TSConditionalType\" === nodeType ||\n    \"TSInferType\" === nodeType ||\n    \"TSParenthesizedType\" === nodeType ||\n    \"TSTypeOperator\" === nodeType ||\n    \"TSIndexedAccessType\" === nodeType ||\n    \"TSMappedType\" === nodeType ||\n    \"TSLiteralType\" === nodeType ||\n    \"TSExpressionWithTypeArguments\" === nodeType ||\n    \"TSImportType\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isTSBaseType(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.TSBaseType {\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (\n    \"TSAnyKeyword\" === nodeType ||\n    \"TSBooleanKeyword\" === nodeType ||\n    \"TSBigIntKeyword\" === nodeType ||\n    \"TSIntrinsicKeyword\" === nodeType ||\n    \"TSNeverKeyword\" === nodeType ||\n    \"TSNullKeyword\" === nodeType ||\n    \"TSNumberKeyword\" === nodeType ||\n    \"TSObjectKeyword\" === nodeType ||\n    \"TSStringKeyword\" === nodeType ||\n    \"TSSymbolKeyword\" === nodeType ||\n    \"TSUndefinedKeyword\" === nodeType ||\n    \"TSUnknownKeyword\" === nodeType ||\n    \"TSVoidKeyword\" === nodeType ||\n    \"TSThisType\" === nodeType ||\n    \"TSLiteralType\" === nodeType\n  ) {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isNumberLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): boolean {\n  deprecationWarning(\"isNumberLiteral\", \"isNumericLiteral\");\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"NumberLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isRegexLiteral(\n  node: object | null | undefined,\n  opts?: object | null,\n): boolean {\n  deprecationWarning(\"isRegexLiteral\", \"isRegExpLiteral\");\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"RegexLiteral\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isRestProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): boolean {\n  deprecationWarning(\"isRestProperty\", \"isRestElement\");\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"RestProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isSpreadProperty(\n  node: object | null | undefined,\n  opts?: object | null,\n): boolean {\n  deprecationWarning(\"isSpreadProperty\", \"isSpreadElement\");\n  if (!node) return false;\n\n  const nodeType = (node as t.Node).type;\n  if (nodeType === \"SpreadProperty\") {\n    if (typeof opts === \"undefined\") {\n      return true;\n    } else {\n      return shallowEqual(node, opts);\n    }\n  }\n\n  return false;\n}\nexport function isModuleDeclaration(\n  node: object | null | undefined,\n  opts?: object | null,\n): node is t.ImportOrExportDeclaration {\n  deprecationWarning(\"isModuleDeclaration\", \"isImportOrExportDeclaration\");\n  return isImportOrExportDeclaration(node, opts);\n}\n"],"mappings":"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"}
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
