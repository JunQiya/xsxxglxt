<<<<<<< HEAD
<<<<<<< HEAD
{"version":3,"names":["_cache","require","_index","_context","_removal","_t","_hoister","arrowFunctionExpression","assertExpression","assignmentExpression","blockStatement","callExpression","cloneNode","expressionStatement","isAssignmentExpression","isCallExpression","isExportNamedDeclaration","isExpression","isIdentifier","isSequenceExpression","isSuper","thisExpression","insertBefore","nodes_","_assertUnremoved","call","nodes","_verifyNodeList","parentPath","parent","isExpressionStatement","isLabeledStatement","isExportDefaultDeclaration","isDeclaration","isNodeType","isJSXElement","isForStatement","key","node","push","replaceExpressionWithStatements","Array","isArray","container","_containerInsertBefore","isStatementOrBlock","shouldInsertCurrentNode","expression","blockPath","replaceWith","unshiftContainer","Error","_containerInsert","from","updateSiblingKeys","length","paths","splice","i","_this$context","to","path","getSibling","context","queue","pushContext","contexts","_getQueueContexts","setScope","debug","maybeQueue","_containerInsertAfter","last","arr","isHiddenInSequenceExpression","expressions","isAlmostConstantAssignment","scope","left","blockScope","getBlockParent","hasOwnBinding","name","getOwnBinding","constantViolations","insertAfter","get","map","self","isPattern","unshift","callee","isPure","isMethod","computed","temp","generateDeclaredUidIdentifier","pushContainer","fromIndex","incrementBy","getCachedPaths","msg","type","NodePath","listKey","verifiedNodes","setContext","replaceWithMultiple","exports","hoist","hoister","PathHoister","run"],"sources":["../../src/path/modification.ts"],"sourcesContent":["// This file contains methods that modify the path/node in some ways.\n\nimport { getCachedPaths } from \"../cache.ts\";\nimport NodePath from \"./index.ts\";\nimport { _getQueueContexts, pushContext, setScope } from \"./context.ts\";\nimport { _assertUnremoved } from \"./removal.ts\";\nimport {\n  arrowFunctionExpression,\n  assertExpression,\n  assignmentExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  isAssignmentExpression,\n  isCallExpression,\n  isExportNamedDeclaration,\n  isExpression,\n  isIdentifier,\n  isSequenceExpression,\n  isSuper,\n  thisExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type Scope from \"../scope/index.ts\";\nimport type {\n  NodeList,\n  NodeOrNodeList,\n  NodeListType,\n  NodePaths,\n} from \"./index.ts\";\n\n/**\n * Insert the provided nodes before the current one.\n */\n\nexport function insertBefore<Nodes extends NodeOrNodeList<t.Node>>(\n  this: NodePath,\n  nodes_: Nodes,\n): NodePaths<Nodes> {\n  _assertUnremoved.call(this);\n\n  const nodes = _verifyNodeList.call(this, nodes_);\n\n  const { parentPath, parent } = this;\n\n  if (\n    parentPath.isExpressionStatement() ||\n    parentPath.isLabeledStatement() ||\n    // https://github.com/babel/babel/issues/15293\n    // When Babel transforms `export class String { field }`, the class properties plugin will inject the defineProperty\n    // helper, which depends on the builtins e.g. String, Number, Symbol, etc. To prevent them from being shadowed by local\n    // exports, the helper injector replaces the named export into `class _String { field }; export { _String as String }`,\n    // with `parentPath` here changed to the moved ClassDeclaration, causing rare inconsistency between `parent` and `parentPath`.\n    // Here we retrieve the parent type from the `parent` property. This is a temporary fix and we should revisit when\n    // helpers should get injected.\n    isExportNamedDeclaration(parent) ||\n    (parentPath.isExportDefaultDeclaration() && this.isDeclaration())\n  ) {\n    return parentPath.insertBefore(nodes as Nodes);\n  } else if (\n    (this.isNodeType(\"Expression\") && !this.isJSXElement()) ||\n    (parentPath.isForStatement() && this.key === \"init\")\n  ) {\n    if (this.node) nodes.push(this.node);\n    // @ts-expect-error todo(flow->ts): check that nodes is an array of statements\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return _containerInsertBefore.call(this, nodes) as NodePaths<Nodes>;\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node as t.Statement;\n    const shouldInsertCurrentNode =\n      node &&\n      (!this.isExpressionStatement() ||\n        (node as t.ExpressionStatement).expression != null);\n\n    const [blockPath] = this.replaceWith(\n      blockStatement(shouldInsertCurrentNode ? [node] : []),\n    );\n    return blockPath.unshiftContainer(\n      \"body\",\n      nodes as t.Statement[],\n    ) as NodePaths<Nodes>;\n  } else {\n    throw new Error(\n      \"We don't know what to do with this node type. \" +\n        \"We were previously a Statement but we can't fit in here?\",\n    );\n  }\n}\n\nexport function _containerInsert<Nodes extends NodeList<t.Node>>(\n  this: NodePath,\n  from: number,\n  nodes: Nodes,\n): NodePaths<Nodes> {\n  updateSiblingKeys.call(this, from, nodes.length);\n\n  const paths: NodePath[] = [];\n\n  // @ts-expect-error todo(flow->ts): this.container could be a NodePath\n  this.container.splice(from, 0, ...nodes);\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context?.queue) {\n      pushContext.call(path, this.context);\n    }\n  }\n\n  const contexts = _getQueueContexts.call(this);\n\n  for (const path of paths) {\n    setScope.call(path);\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths as NodePaths<Nodes>;\n}\n\nexport function _containerInsertBefore<Nodes extends NodeList<t.Node>>(\n  this: NodePath,\n  nodes: Nodes,\n): NodePaths<Nodes> {\n  return _containerInsert.call(\n    this,\n    this.key as number,\n    nodes,\n  ) as NodePaths<Nodes>;\n}\n\nexport function _containerInsertAfter<Nodes extends NodeList<t.Node>>(\n  this: NodePath,\n  nodes: Nodes,\n): NodePaths<Nodes> {\n  return _containerInsert.call(\n    this,\n    (this.key as number) + 1,\n    nodes,\n  ) as NodePaths<Nodes>;\n}\n\nconst last = <T>(arr: T[]) => arr[arr.length - 1];\n\nfunction isHiddenInSequenceExpression(path: NodePath): boolean {\n  return (\n    isSequenceExpression(path.parent) &&\n    (last(path.parent.expressions) !== path.node ||\n      isHiddenInSequenceExpression(path.parentPath))\n  );\n}\n\nfunction isAlmostConstantAssignment(\n  node: t.Node,\n  scope: Scope,\n): node is t.AssignmentExpression & { left: t.Identifier } {\n  if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {\n    return false;\n  }\n\n  // Not every scope can contain variables. For example, we might be in\n  // a ClassScope either in the ClassHeritage or in a computed key.\n  const blockScope = scope.getBlockParent();\n\n  // If the variable is defined in the current scope and only assigned here,\n  // we can be sure that its value won't change.\n  return (\n    blockScope.hasOwnBinding(node.left.name) &&\n    blockScope.getOwnBinding(node.left.name)!.constantViolations.length <= 1\n  );\n}\n\n/**\n * Insert the provided nodes after the current one. When inserting nodes after an\n * expression, ensure that the completion record is correct by pushing the current node.\n */\n\nexport function insertAfter<Nodes extends NodeOrNodeList<t.Node>>(\n  this: NodePath,\n  nodes_: Nodes,\n): NodePaths<Nodes> {\n  _assertUnremoved.call(this);\n\n  if (this.isSequenceExpression()) {\n    return last(this.get(\"expressions\")).insertAfter(nodes_);\n  }\n\n  const nodes = _verifyNodeList.call(this, nodes_);\n\n  const { parentPath, parent } = this;\n  if (\n    parentPath.isExpressionStatement() ||\n    parentPath.isLabeledStatement() ||\n    // see insertBefore\n    isExportNamedDeclaration(parent) ||\n    (parentPath.isExportDefaultDeclaration() && this.isDeclaration())\n  ) {\n    return parentPath.insertAfter(\n      nodes.map(node => {\n        // Usually after an expression we can safely insert another expression:\n        //   A.insertAfter(B)\n        //     foo = A;  -> foo = (A, B);\n        // If A is an expression statement, it isn't safe anymore so we need to\n        // convert B to an expression statement\n        //     A;        -> A; B // No semicolon! It could break if followed by [!\n        return isExpression(node) ? expressionStatement(node) : node;\n      }),\n      // todo: this cast is unsound, we wrap some expression nodes in expressionStatement but never unwrap them in the return values.\n    ) as NodePaths<Nodes>;\n  } else if (\n    (this.isNodeType(\"Expression\") &&\n      !this.isJSXElement() &&\n      !parentPath.isJSXElement()) ||\n    (parentPath.isForStatement() && this.key === \"init\")\n  ) {\n    const self = this as NodePath<t.Expression | t.VariableDeclaration>;\n    if (self.node) {\n      const node = self.node;\n      let { scope } = this;\n\n      if (scope.path.isPattern()) {\n        assertExpression(node);\n\n        self.replaceWith(callExpression(arrowFunctionExpression([], node), []));\n        (self.get(\"callee.body\") as NodePath<t.Expression>).insertAfter(nodes);\n        // todo: this cast is unsound, we wrap nodes in the IIFE but never unwrap them in the return values.\n        // consider just returning the insertAfter result.\n        return [self] as NodePaths<Nodes>;\n      }\n\n      if (isHiddenInSequenceExpression(self)) {\n        nodes.unshift(node);\n      }\n      // We need to preserve the value of this expression.\n      else if (isCallExpression(node) && isSuper(node.callee)) {\n        nodes.unshift(node);\n        // `super(...)` always evaluates to `this`.\n        nodes.push(thisExpression());\n      } else if (isAlmostConstantAssignment(node, scope)) {\n        nodes.unshift(node);\n        nodes.push(cloneNode(node.left));\n      } else if (scope.isPure(node, true)) {\n        // Insert the nodes before rather than after; it's not observable.\n        nodes.push(node);\n      } else {\n        // Inserting after the computed key of a method should insert the\n        // temporary binding in the method's parent's scope.\n        if (parentPath.isMethod({ computed: true, key: node })) {\n          scope = scope.parent!;\n        }\n        const temp = scope.generateDeclaredUidIdentifier();\n        nodes.unshift(\n          expressionStatement(\n            // @ts-expect-error todo(flow->ts): This can be a variable\n            // declaration in the \"init\" of a for statement, but that's\n            // invalid here.\n            assignmentExpression(\"=\", cloneNode(temp), node),\n          ),\n        );\n        nodes.push(expressionStatement(cloneNode(temp)));\n      }\n    }\n    // @ts-expect-error todo(flow->ts): check that nodes is an array of statements\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return _containerInsertAfter.call(this, nodes) as NodePaths<Nodes>;\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node as t.Statement;\n    const shouldInsertCurrentNode =\n      node &&\n      (!this.isExpressionStatement() ||\n        (node as t.ExpressionStatement).expression != null);\n\n    const [blockPath] = this.replaceWith(\n      blockStatement(shouldInsertCurrentNode ? [node] : []),\n    );\n    return blockPath.pushContainer(\n      \"body\",\n      nodes as t.Statement[],\n    ) as NodePaths<Nodes>;\n  } else {\n    throw new Error(\n      \"We don't know what to do with this node type. \" +\n        \"We were previously a Statement but we can't fit in here?\",\n    );\n  }\n}\n\n/**\n * Update all sibling node paths after `fromIndex` by `incrementBy`.\n */\n\nexport function updateSiblingKeys(\n  this: NodePath,\n  fromIndex: number,\n  incrementBy: number,\n) {\n  if (!this.parent) return;\n\n  const paths = getCachedPaths(this);\n  if (!paths) return;\n\n  for (const [, path] of paths) {\n    if (\n      typeof path.key === \"number\" &&\n      path.container === this.container &&\n      path.key >= fromIndex\n    ) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nexport function _verifyNodeList<N extends t.Node>(\n  this: NodePath,\n  nodes: N | N[],\n) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof NodePath) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(\n        `Node list ${msg} with the index of ${i} and type of ${type}`,\n      );\n    }\n  }\n\n  return nodes;\n}\n\ntype NodeKeyOfArrays<N extends t.Node> = {\n  [P in string & keyof N]-?: N[P] extends Array<t.Node | null> ? P : never;\n}[string & keyof N];\n\nexport function unshiftContainer<\n  N extends t.Node,\n  K extends NodeKeyOfArrays<N>,\n  Nodes extends NodeOrNodeList<NodeListType<N, K>>,\n>(this: NodePath<N>, listKey: K, nodes: Nodes): NodePaths<Nodes> {\n  _assertUnremoved.call(this);\n\n  const verifiedNodes = _verifyNodeList.call(this, nodes);\n\n  // get the first path and insert our nodes before it, if it doesn't exist then it\n  // doesn't matter, our nodes will be inserted anyway\n  const container = (this.node as N)[listKey] as t.Node[];\n  const path = NodePath.get({\n    parentPath: this,\n    parent: this.node,\n    container,\n    listKey,\n    key: 0,\n  }).setContext(this.context);\n\n  return _containerInsertBefore.call(path, verifiedNodes) as NodePaths<Nodes>;\n}\n\nexport function pushContainer<\n  N extends t.Node,\n  K extends NodeKeyOfArrays<N>,\n  Nodes extends NodeOrNodeList<NodeListType<N, K>>,\n>(this: NodePath<N>, listKey: K, nodes: Nodes): NodePaths<Nodes> {\n  _assertUnremoved.call(this);\n\n  const verifiedNodes = _verifyNodeList.call(this, nodes);\n\n  // get an invisible path that represents the last node + 1 and replace it with our\n  // nodes, effectively inlining it\n\n  const container = (this.node as N)[listKey] as t.Node[];\n  const path = NodePath.get({\n    parentPath: this,\n    parent: this.node,\n    container,\n    listKey,\n    key: container.length,\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes) as NodePaths<Nodes>;\n}\n\nimport PathHoister from \"./lib/hoister.ts\" with { if: \"!process.env.BABEL_8_BREAKING && !USE_ESM\" };\nif (!process.env.BABEL_8_BREAKING && !USE_ESM) {\n  /**\n   * Hoist the current node to the highest scope possible and return a UID\n   * referencing it.\n   */\n  // eslint-disable-next-line no-restricted-globals\n  exports.hoist = function hoist<N extends t.Node>(\n    this: NodePath<N>,\n    scope: Scope = this.scope,\n  ) {\n    const hoister = new PathHoister<N>(this, scope);\n    return hoister.run();\n  };\n}\n"],"mappings":"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","ignoreList":[]}
=======
{"version":3,"names":["arrowFunctionExpression","assertExpression","assignmentExpression","blockStatement","callExpression","cloneNode","expressionStatement","isAssignmentExpression","isCallExpression","isExportNamedDeclaration","isExpression","isIdentifier","isSequenceExpression","isSuper","thisExpression","insertBefore","nodes_","_assertUnremoved","nodes","_verifyNodeList","parentPath","parent","isExpressionStatement","isLabeledStatement","isExportDefaultDeclaration","isDeclaration","isNodeType","isJSXElement","isForStatement","key","node","push","replaceExpressionWithStatements","Array","isArray","container","_containerInsertBefore","isStatementOrBlock","shouldInsertCurrentNode","expression","replaceWith","unshiftContainer","Error","_containerInsert","from","updateSiblingKeys","length","paths","splice","i","to","path","getSibling","context","queue","pushContext","contexts","_getQueueContexts","setScope","debug","maybeQueue","_containerInsertAfter","last","arr","isHiddenInSequenceExpression","expressions","isAlmostConstantAssignment","scope","left","blockScope","getBlockParent","hasOwnBinding","name","getOwnBinding","constantViolations","insertAfter","get","map","isPattern","unshift","callee","isPure","isMethod","computed","temp","generateDeclaredUidIdentifier","pushContainer","fromIndex","incrementBy","pathCache","msg","type","NodePath","listKey","setContext","verifiedNodes","replaceWithMultiple","hoist","hoister","PathHoister","run"],"sources":["../../src/path/modification.ts"],"sourcesContent":["// This file contains methods that modify the path/node in some ways.\n\nimport { path as pathCache } from \"../cache\";\nimport PathHoister from \"./lib/hoister\";\nimport NodePath from \"./index\";\nimport {\n  arrowFunctionExpression,\n  assertExpression,\n  assignmentExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  isAssignmentExpression,\n  isCallExpression,\n  isExportNamedDeclaration,\n  isExpression,\n  isIdentifier,\n  isSequenceExpression,\n  isSuper,\n  thisExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type Scope from \"../scope\";\n\n/**\n * Insert the provided nodes before the current one.\n */\n\nexport function insertBefore(\n  this: NodePath,\n  nodes_: t.Node | t.Node[],\n): NodePath[] {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const { parentPath, parent } = this;\n\n  if (\n    parentPath.isExpressionStatement() ||\n    parentPath.isLabeledStatement() ||\n    // https://github.com/babel/babel/issues/15293\n    // When Babel transforms `export class String { field }`, the class properties plugin will inject the defineProperty\n    // helper, which depends on the builtins e.g. String, Number, Symbol, etc. To prevent them from being shadowed by local\n    // exports, the helper injector replaces the named export into `class _String { field }; export { _String as String }`,\n    // with `parentPath` here changed to the moved ClassDeclaration, causing rare inconsistency between `parent` and `parentPath`.\n    // Here we retrieve the parent type from the `parent` property. This is a temporary fix and we should revisit when\n    // helpers should get injected.\n    isExportNamedDeclaration(parent) ||\n    (parentPath.isExportDefaultDeclaration() && this.isDeclaration())\n  ) {\n    return parentPath.insertBefore(nodes);\n  } else if (\n    (this.isNodeType(\"Expression\") && !this.isJSXElement()) ||\n    (parentPath.isForStatement() && this.key === \"init\")\n  ) {\n    if (this.node) nodes.push(this.node);\n    // @ts-expect-error todo(flow->ts): check that nodes is an array of statements\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node as t.Statement;\n    const shouldInsertCurrentNode =\n      node &&\n      (!this.isExpressionStatement() ||\n        (node as t.ExpressionStatement).expression != null);\n\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return (this as NodePath<t.BlockStatement>).unshiftContainer(\n      \"body\",\n      // @ts-expect-error Fixme: refine nodes to t.BlockStatement[\"body\"] when this is a BlockStatement path\n      nodes,\n    );\n  } else {\n    throw new Error(\n      \"We don't know what to do with this node type. \" +\n        \"We were previously a Statement but we can't fit in here?\",\n    );\n  }\n}\n\nexport function _containerInsert<N extends t.Node>(\n  this: NodePath,\n  from: number,\n  nodes: N[],\n): NodePath<N>[] {\n  this.updateSiblingKeys(from, nodes.length);\n\n  const paths: NodePath<N>[] = [];\n\n  // @ts-expect-error todo(flow->ts): this.container could be a NodePath\n  this.container.splice(from, 0, ...nodes);\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to) as NodePath<N>;\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nexport function _containerInsertBefore<N extends t.Node>(\n  this: NodePath,\n  nodes: N[],\n) {\n  return this._containerInsert(this.key as number, nodes);\n}\n\nexport function _containerInsertAfter<N extends t.Node>(\n  this: NodePath,\n  nodes: N[],\n) {\n  return this._containerInsert((this.key as number) + 1, nodes);\n}\n\nconst last = <T>(arr: T[]) => arr[arr.length - 1];\n\nfunction isHiddenInSequenceExpression(path: NodePath): boolean {\n  return (\n    isSequenceExpression(path.parent) &&\n    (last(path.parent.expressions) !== path.node ||\n      isHiddenInSequenceExpression(path.parentPath))\n  );\n}\n\nfunction isAlmostConstantAssignment(\n  node: t.Node,\n  scope: Scope,\n): node is t.AssignmentExpression & { left: t.Identifier } {\n  if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {\n    return false;\n  }\n\n  // Not every scope can contain variables. For example, we might be in\n  // a ClassScope either in the ClassHeritage or in a computed key.\n  const blockScope = scope.getBlockParent();\n\n  // If the variable is defined in the current scope and only assigned here,\n  // we can be sure that its value won't change.\n  return (\n    blockScope.hasOwnBinding(node.left.name) &&\n    blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1\n  );\n}\n\n/**\n * Insert the provided nodes after the current one. When inserting nodes after an\n * expression, ensure that the completion record is correct by pushing the current node.\n */\n\nexport function insertAfter(\n  this: NodePath,\n  nodes_: t.Node | t.Node[],\n): NodePath[] {\n  this._assertUnremoved();\n\n  if (this.isSequenceExpression()) {\n    return last(this.get(\"expressions\")).insertAfter(nodes_);\n  }\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const { parentPath, parent } = this;\n  if (\n    parentPath.isExpressionStatement() ||\n    parentPath.isLabeledStatement() ||\n    // see insertBefore\n    isExportNamedDeclaration(parent) ||\n    (parentPath.isExportDefaultDeclaration() && this.isDeclaration())\n  ) {\n    return parentPath.insertAfter(\n      nodes.map(node => {\n        // Usually after an expression we can safely insert another expression:\n        //   A.insertAfter(B)\n        //     foo = A;  -> foo = (A, B);\n        // If A is an expression statement, it isn't safe anymore so we need to\n        // convert B to an expression statement\n        //     A;        -> A; B // No semicolon! It could break if followed by [!\n        return isExpression(node) ? expressionStatement(node) : node;\n      }),\n    );\n  } else if (\n    (this.isNodeType(\"Expression\") &&\n      !this.isJSXElement() &&\n      !parentPath.isJSXElement()) ||\n    (parentPath.isForStatement() && this.key === \"init\")\n  ) {\n    if (this.node) {\n      const node = this.node as t.Expression | t.VariableDeclaration;\n      let { scope } = this;\n\n      if (scope.path.isPattern()) {\n        assertExpression(node);\n\n        this.replaceWith(callExpression(arrowFunctionExpression([], node), []));\n        (this.get(\"callee.body\") as NodePath<t.Expression>).insertAfter(nodes);\n        return [this];\n      }\n\n      if (isHiddenInSequenceExpression(this)) {\n        nodes.unshift(node);\n      }\n      // We need to preserve the value of this expression.\n      else if (isCallExpression(node) && isSuper(node.callee)) {\n        nodes.unshift(node);\n        // `super(...)` always evaluates to `this`.\n        nodes.push(thisExpression());\n      } else if (isAlmostConstantAssignment(node, scope)) {\n        nodes.unshift(node);\n        nodes.push(cloneNode(node.left));\n      } else if (scope.isPure(node, true)) {\n        // Insert the nodes before rather than after; it's not observable.\n        nodes.push(node);\n      } else {\n        // Inserting after the computed key of a method should insert the\n        // temporary binding in the method's parent's scope.\n        if (parentPath.isMethod({ computed: true, key: node })) {\n          scope = scope.parent;\n        }\n        const temp = scope.generateDeclaredUidIdentifier();\n        nodes.unshift(\n          expressionStatement(\n            // @ts-expect-error todo(flow->ts): This can be a variable\n            // declaration in the \"init\" of a for statement, but that's\n            // invalid here.\n            assignmentExpression(\"=\", cloneNode(temp), node),\n          ),\n        );\n        nodes.push(expressionStatement(cloneNode(temp)));\n      }\n    }\n    // @ts-expect-error todo(flow->ts): check that nodes is an array of statements\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node as t.Statement;\n    const shouldInsertCurrentNode =\n      node &&\n      (!this.isExpressionStatement() ||\n        (node as t.ExpressionStatement).expression != null);\n\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    // @ts-expect-error Fixme: refine nodes to t.BlockStatement[\"body\"] when this is a BlockStatement path\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\n      \"We don't know what to do with this node type. \" +\n        \"We were previously a Statement but we can't fit in here?\",\n    );\n  }\n}\n\n/**\n * Update all sibling node paths after `fromIndex` by `incrementBy`.\n */\n\nexport function updateSiblingKeys(\n  this: NodePath,\n  fromIndex: number,\n  incrementBy: number,\n) {\n  if (!this.parent) return;\n\n  const paths = pathCache.get(this.parent);\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nexport function _verifyNodeList<N extends t.Node>(\n  this: NodePath,\n  nodes: N | N[],\n): N[] {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof NodePath) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(\n        `Node list ${msg} with the index of ${i} and type of ${type}`,\n      );\n    }\n  }\n\n  return nodes;\n}\n\nexport function unshiftContainer<N extends t.Node, K extends keyof N & string>(\n  this: NodePath<N>,\n  listKey: K,\n  nodes: N[K] extends (infer E)[]\n    ? E | E[]\n    : // todo: refine to t.Node[]\n      //  ? E extends t.Node\n      //    ? E | E[]\n      //    : never\n      never,\n) {\n  // todo: NodePaths<Nodes>\n  this._assertUnremoved();\n\n  // @ts-expect-error fixme\n  nodes = this._verifyNodeList(nodes);\n\n  // get the first path and insert our nodes before it, if it doesn't exist then it\n  // doesn't matter, our nodes will be inserted anyway\n  const path = NodePath.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey] as unknown as t.Node | t.Node[],\n    listKey,\n    key: 0,\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(\n    // @ts-expect-error typings needed to narrow down nodes as t.Node[]\n    nodes,\n  );\n}\n\nexport function pushContainer<N extends t.Node, K extends keyof N & string>(\n  this: NodePath<N>,\n  listKey: K,\n  nodes: N[K] extends (infer E)[]\n    ? E | E[]\n    : // todo: refine to t.Node[]\n      //  ? E extends t.Node\n      //    ? E | E[]\n      //    : never\n      never,\n) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(\n    // @ts-expect-error refine typings\n    nodes,\n  );\n\n  // get an invisible path that represents the last node + 1 and replace it with our\n  // nodes, effectively inlining it\n\n  const container = this.node[listKey];\n  const path = NodePath.get({\n    parentPath: this,\n    parent: this.node,\n    container: container as unknown as t.Node | t.Node[],\n    listKey,\n    // @ts-expect-error TS cannot infer that container is t.Node[]\n    key: container.length,\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\n/**\n * Hoist the current node to the highest scope possible and return a UID\n * referencing it.\n */\nexport function hoist<T extends t.Node>(\n  this: NodePath<T>,\n  scope: Scope = this.scope,\n) {\n  const hoister = new PathHoister<T>(this, scope);\n  return hoister.run();\n}\n"],"mappings":"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"}
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
{"version":3,"names":["_cache","require","_hoister","_index","_t","arrowFunctionExpression","assertExpression","assignmentExpression","blockStatement","callExpression","cloneNode","expressionStatement","isAssignmentExpression","isCallExpression","isExportNamedDeclaration","isExpression","isIdentifier","isSequenceExpression","isSuper","thisExpression","insertBefore","nodes_","_assertUnremoved","nodes","_verifyNodeList","parentPath","parent","isExpressionStatement","isLabeledStatement","isExportDefaultDeclaration","isDeclaration","isNodeType","isJSXElement","isForStatement","key","node","push","replaceExpressionWithStatements","Array","isArray","container","_containerInsertBefore","isStatementOrBlock","shouldInsertCurrentNode","expression","replaceWith","unshiftContainer","Error","_containerInsert","from","updateSiblingKeys","length","paths","splice","i","_this$context","to","path","getSibling","context","queue","pushContext","contexts","_getQueueContexts","setScope","debug","maybeQueue","_containerInsertAfter","last","arr","isHiddenInSequenceExpression","expressions","isAlmostConstantAssignment","scope","left","blockScope","getBlockParent","hasOwnBinding","name","getOwnBinding","constantViolations","insertAfter","get","map","isPattern","unshift","callee","isPure","isMethod","computed","temp","generateDeclaredUidIdentifier","pushContainer","fromIndex","incrementBy","getCachedPaths","hub","msg","type","NodePath","listKey","setContext","verifiedNodes","replaceWithMultiple","hoist","hoister","PathHoister","run"],"sources":["../../src/path/modification.ts"],"sourcesContent":["// This file contains methods that modify the path/node in some ways.\n\nimport { getCachedPaths } from \"../cache.ts\";\nimport PathHoister from \"./lib/hoister.ts\";\nimport NodePath from \"./index.ts\";\nimport {\n  arrowFunctionExpression,\n  assertExpression,\n  assignmentExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  isAssignmentExpression,\n  isCallExpression,\n  isExportNamedDeclaration,\n  isExpression,\n  isIdentifier,\n  isSequenceExpression,\n  isSuper,\n  thisExpression,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport type Scope from \"../scope/index.ts\";\n\n/**\n * Insert the provided nodes before the current one.\n */\n\nexport function insertBefore(\n  this: NodePath,\n  nodes_: t.Node | t.Node[],\n): NodePath[] {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const { parentPath, parent } = this;\n\n  if (\n    parentPath.isExpressionStatement() ||\n    parentPath.isLabeledStatement() ||\n    // https://github.com/babel/babel/issues/15293\n    // When Babel transforms `export class String { field }`, the class properties plugin will inject the defineProperty\n    // helper, which depends on the builtins e.g. String, Number, Symbol, etc. To prevent them from being shadowed by local\n    // exports, the helper injector replaces the named export into `class _String { field }; export { _String as String }`,\n    // with `parentPath` here changed to the moved ClassDeclaration, causing rare inconsistency between `parent` and `parentPath`.\n    // Here we retrieve the parent type from the `parent` property. This is a temporary fix and we should revisit when\n    // helpers should get injected.\n    isExportNamedDeclaration(parent) ||\n    (parentPath.isExportDefaultDeclaration() && this.isDeclaration())\n  ) {\n    return parentPath.insertBefore(nodes);\n  } else if (\n    (this.isNodeType(\"Expression\") && !this.isJSXElement()) ||\n    (parentPath.isForStatement() && this.key === \"init\")\n  ) {\n    if (this.node) nodes.push(this.node);\n    // @ts-expect-error todo(flow->ts): check that nodes is an array of statements\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node as t.Statement;\n    const shouldInsertCurrentNode =\n      node &&\n      (!this.isExpressionStatement() ||\n        (node as t.ExpressionStatement).expression != null);\n\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return (this as NodePath<t.BlockStatement>).unshiftContainer(\n      \"body\",\n      // @ts-expect-error Fixme: refine nodes to t.BlockStatement[\"body\"] when this is a BlockStatement path\n      nodes,\n    );\n  } else {\n    throw new Error(\n      \"We don't know what to do with this node type. \" +\n        \"We were previously a Statement but we can't fit in here?\",\n    );\n  }\n}\n\nexport function _containerInsert<N extends t.Node>(\n  this: NodePath,\n  from: number,\n  nodes: N[],\n): NodePath<N>[] {\n  this.updateSiblingKeys(from, nodes.length);\n\n  const paths: NodePath<N>[] = [];\n\n  // @ts-expect-error todo(flow->ts): this.container could be a NodePath\n  this.container.splice(from, 0, ...nodes);\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to) as NodePath<N>;\n    paths.push(path);\n\n    if (this.context?.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nexport function _containerInsertBefore<N extends t.Node>(\n  this: NodePath,\n  nodes: N[],\n) {\n  return this._containerInsert(this.key as number, nodes);\n}\n\nexport function _containerInsertAfter<N extends t.Node>(\n  this: NodePath,\n  nodes: N[],\n) {\n  return this._containerInsert((this.key as number) + 1, nodes);\n}\n\nconst last = <T>(arr: T[]) => arr[arr.length - 1];\n\nfunction isHiddenInSequenceExpression(path: NodePath): boolean {\n  return (\n    isSequenceExpression(path.parent) &&\n    (last(path.parent.expressions) !== path.node ||\n      isHiddenInSequenceExpression(path.parentPath))\n  );\n}\n\nfunction isAlmostConstantAssignment(\n  node: t.Node,\n  scope: Scope,\n): node is t.AssignmentExpression & { left: t.Identifier } {\n  if (!isAssignmentExpression(node) || !isIdentifier(node.left)) {\n    return false;\n  }\n\n  // Not every scope can contain variables. For example, we might be in\n  // a ClassScope either in the ClassHeritage or in a computed key.\n  const blockScope = scope.getBlockParent();\n\n  // If the variable is defined in the current scope and only assigned here,\n  // we can be sure that its value won't change.\n  return (\n    blockScope.hasOwnBinding(node.left.name) &&\n    blockScope.getOwnBinding(node.left.name).constantViolations.length <= 1\n  );\n}\n\n/**\n * Insert the provided nodes after the current one. When inserting nodes after an\n * expression, ensure that the completion record is correct by pushing the current node.\n */\n\nexport function insertAfter(\n  this: NodePath,\n  nodes_: t.Node | t.Node[],\n): NodePath[] {\n  this._assertUnremoved();\n\n  if (this.isSequenceExpression()) {\n    return last(this.get(\"expressions\")).insertAfter(nodes_);\n  }\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const { parentPath, parent } = this;\n  if (\n    parentPath.isExpressionStatement() ||\n    parentPath.isLabeledStatement() ||\n    // see insertBefore\n    isExportNamedDeclaration(parent) ||\n    (parentPath.isExportDefaultDeclaration() && this.isDeclaration())\n  ) {\n    return parentPath.insertAfter(\n      nodes.map(node => {\n        // Usually after an expression we can safely insert another expression:\n        //   A.insertAfter(B)\n        //     foo = A;  -> foo = (A, B);\n        // If A is an expression statement, it isn't safe anymore so we need to\n        // convert B to an expression statement\n        //     A;        -> A; B // No semicolon! It could break if followed by [!\n        return isExpression(node) ? expressionStatement(node) : node;\n      }),\n    );\n  } else if (\n    (this.isNodeType(\"Expression\") &&\n      !this.isJSXElement() &&\n      !parentPath.isJSXElement()) ||\n    (parentPath.isForStatement() && this.key === \"init\")\n  ) {\n    if (this.node) {\n      const node = this.node as t.Expression | t.VariableDeclaration;\n      let { scope } = this;\n\n      if (scope.path.isPattern()) {\n        assertExpression(node);\n\n        this.replaceWith(callExpression(arrowFunctionExpression([], node), []));\n        (this.get(\"callee.body\") as NodePath<t.Expression>).insertAfter(nodes);\n        return [this];\n      }\n\n      if (isHiddenInSequenceExpression(this)) {\n        nodes.unshift(node);\n      }\n      // We need to preserve the value of this expression.\n      else if (isCallExpression(node) && isSuper(node.callee)) {\n        nodes.unshift(node);\n        // `super(...)` always evaluates to `this`.\n        nodes.push(thisExpression());\n      } else if (isAlmostConstantAssignment(node, scope)) {\n        nodes.unshift(node);\n        nodes.push(cloneNode(node.left));\n      } else if (scope.isPure(node, true)) {\n        // Insert the nodes before rather than after; it's not observable.\n        nodes.push(node);\n      } else {\n        // Inserting after the computed key of a method should insert the\n        // temporary binding in the method's parent's scope.\n        if (parentPath.isMethod({ computed: true, key: node })) {\n          scope = scope.parent;\n        }\n        const temp = scope.generateDeclaredUidIdentifier();\n        nodes.unshift(\n          expressionStatement(\n            // @ts-expect-error todo(flow->ts): This can be a variable\n            // declaration in the \"init\" of a for statement, but that's\n            // invalid here.\n            assignmentExpression(\"=\", cloneNode(temp), node),\n          ),\n        );\n        nodes.push(expressionStatement(cloneNode(temp)));\n      }\n    }\n    // @ts-expect-error todo(flow->ts): check that nodes is an array of statements\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node as t.Statement;\n    const shouldInsertCurrentNode =\n      node &&\n      (!this.isExpressionStatement() ||\n        (node as t.ExpressionStatement).expression != null);\n\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    // @ts-expect-error Fixme: refine nodes to t.BlockStatement[\"body\"] when this is a BlockStatement path\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\n      \"We don't know what to do with this node type. \" +\n        \"We were previously a Statement but we can't fit in here?\",\n    );\n  }\n}\n\n/**\n * Update all sibling node paths after `fromIndex` by `incrementBy`.\n */\n\nexport function updateSiblingKeys(\n  this: NodePath,\n  fromIndex: number,\n  incrementBy: number,\n) {\n  if (!this.parent) return;\n\n  const paths = getCachedPaths(this.hub, this.parent) || ([] as never[]);\n\n  for (const [, path] of paths) {\n    if (typeof path.key === \"number\" && path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nexport function _verifyNodeList<N extends t.Node>(\n  this: NodePath,\n  nodes: N | N[],\n): N[] {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof NodePath) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(\n        `Node list ${msg} with the index of ${i} and type of ${type}`,\n      );\n    }\n  }\n\n  return nodes;\n}\n\nexport function unshiftContainer<N extends t.Node, K extends keyof N & string>(\n  this: NodePath<N>,\n  listKey: K,\n  nodes: N[K] extends (infer E)[]\n    ? E | E[]\n    : // todo: refine to t.Node[]\n      //  ? E extends t.Node\n      //    ? E | E[]\n      //    : never\n      never,\n) {\n  // todo: NodePaths<Nodes>\n  this._assertUnremoved();\n\n  // @ts-expect-error fixme\n  nodes = this._verifyNodeList(nodes);\n\n  // get the first path and insert our nodes before it, if it doesn't exist then it\n  // doesn't matter, our nodes will be inserted anyway\n  const path = NodePath.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey] as unknown as t.Node | t.Node[],\n    listKey,\n    key: 0,\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(\n    // @ts-expect-error typings needed to narrow down nodes as t.Node[]\n    nodes,\n  );\n}\n\nexport function pushContainer<N extends t.Node, K extends keyof N & string>(\n  this: NodePath<N>,\n  listKey: K,\n  nodes: N[K] extends (infer E)[]\n    ? E | E[]\n    : // todo: refine to t.Node[]\n      //  ? E extends t.Node\n      //    ? E | E[]\n      //    : never\n      never,\n) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(\n    // @ts-expect-error refine typings\n    nodes,\n  );\n\n  // get an invisible path that represents the last node + 1 and replace it with our\n  // nodes, effectively inlining it\n\n  const container = this.node[listKey];\n  const path = NodePath.get({\n    parentPath: this,\n    parent: this.node,\n    container: container as unknown as t.Node | t.Node[],\n    listKey,\n    // @ts-expect-error TS cannot infer that container is t.Node[]\n    key: container.length,\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\n/**\n * Hoist the current node to the highest scope possible and return a UID\n * referencing it.\n */\nexport function hoist<T extends t.Node>(\n  this: NodePath<T>,\n  scope: Scope = this.scope,\n) {\n  const hoister = new PathHoister<T>(this, scope);\n  return hoister.run();\n}\n"],"mappings":"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","ignoreList":[]}
>>>>>>> parent of 99ae58fb (IP)
