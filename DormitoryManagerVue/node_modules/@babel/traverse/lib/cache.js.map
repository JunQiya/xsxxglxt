<<<<<<< HEAD
<<<<<<< HEAD
{"version":3,"names":["pathsCache","exports","path","WeakMap","scope","clear","clearPath","clearScope","getCachedPaths","parent","parentPath","get","getOrCreateCachedPaths","node","paths","set","Map"],"sources":["../src/cache.ts"],"sourcesContent":["import type { Node } from \"@babel/types\";\nimport type NodePath from \"./path/index.ts\";\nimport type Scope from \"./scope/index.ts\";\n\nlet pathsCache: WeakMap<Node, Map<Node, NodePath>> = new WeakMap();\nexport { pathsCache as path };\nexport let scope: WeakMap<Node, Scope> = new WeakMap();\n\nexport function clear() {\n  clearPath();\n  clearScope();\n}\n\nexport function clearPath() {\n  pathsCache = new WeakMap();\n}\n\nexport function clearScope() {\n  scope = new WeakMap();\n}\n\nexport function getCachedPaths(path: NodePath) {\n  const { parent, parentPath } = path;\n  return process.env.BABEL_8_BREAKING && parentPath\n    ? parentPath._store\n    : pathsCache.get(parent);\n}\n\nexport function getOrCreateCachedPaths(\n  node: Node,\n  parentPath?: NodePath | null,\n) {\n  if (process.env.BABEL_8_BREAKING && parentPath) {\n    return (parentPath._store ||= new Map());\n  }\n\n  let paths = pathsCache.get(node);\n  if (!paths) pathsCache.set(node, (paths = new Map()));\n\n  return paths;\n}\n"],"mappings":";;;;;;;;;;;AAIA,IAAIA,UAA8C,GAAAC,OAAA,CAAAC,IAAA,GAAG,IAAIC,OAAO,CAAC,CAAC;AAE3D,IAAIC,KAA2B,GAAAH,OAAA,CAAAG,KAAA,GAAG,IAAID,OAAO,CAAC,CAAC;AAE/C,SAASE,KAAKA,CAAA,EAAG;EACtBC,SAAS,CAAC,CAAC;EACXC,UAAU,CAAC,CAAC;AACd;AAEO,SAASD,SAASA,CAAA,EAAG;EAC1BL,OAAA,CAAAC,IAAA,GAAAF,UAAU,GAAG,IAAIG,OAAO,CAAC,CAAC;AAC5B;AAEO,SAASI,UAAUA,CAAA,EAAG;EAC3BN,OAAA,CAAAG,KAAA,GAAAA,KAAK,GAAG,IAAID,OAAO,CAAC,CAAC;AACvB;AAEO,SAASK,cAAcA,CAACN,IAAc,EAAE;EAC7C,MAAM;IAAEO,MAAM;IAAEC;EAAW,CAAC,GAAGR,IAAI;EACnC,OAEIF,UAAU,CAACW,GAAG,CAACF,MAAM,CAAC;AAC5B;AAEO,SAASG,sBAAsBA,CACpCC,IAAU,EACVH,UAA4B,EAC5B;EAAA;EAKA,IAAII,KAAK,GAAGd,UAAU,CAACW,GAAG,CAACE,IAAI,CAAC;EAChC,IAAI,CAACC,KAAK,EAAEd,UAAU,CAACe,GAAG,CAACF,IAAI,EAAGC,KAAK,GAAG,IAAIE,GAAG,CAAC,CAAE,CAAC;EAErD,OAAOF,KAAK;AACd","ignoreList":[]}
=======
{"version":3,"names":["path","WeakMap","scope","clear","clearPath","clearScope"],"sources":["../src/cache.ts"],"sourcesContent":["export let path = new WeakMap();\nexport let scope = new WeakMap();\n\nexport function clear() {\n  clearPath();\n  clearScope();\n}\n\nexport function clearPath() {\n  path = new WeakMap();\n}\n\nexport function clearScope() {\n  scope = new WeakMap();\n}\n"],"mappings":";;;;;;;;;AAAO,IAAIA,IAAI,GAAG,IAAIC,OAAO,EAAE;AAAC;AACzB,IAAIC,KAAK,GAAG,IAAID,OAAO,EAAE;AAAC;AAE1B,SAASE,KAAK,GAAG;EACtBC,SAAS,EAAE;EACXC,UAAU,EAAE;AACd;AAEO,SAASD,SAAS,GAAG;EAC1B,eAAAJ,IAAI,GAAG,IAAIC,OAAO,EAAE;AACtB;AAEO,SAASI,UAAU,GAAG;EAC3B,gBAAAH,KAAK,GAAG,IAAID,OAAO,EAAE;AACvB"}
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
{"version":3,"names":["pathsCache","exports","path","WeakMap","scope","clear","clearPath","clearScope","nullHub","Object","freeze","getCachedPaths","hub","parent","_pathsCache$get","_hub","get","getOrCreateCachedPaths","_hub2","_hub3","parents","set","paths","Map"],"sources":["../src/cache.ts"],"sourcesContent":["import type { Node } from \"@babel/types\";\nimport type NodePath from \"./path/index.ts\";\nimport type Scope from \"./scope/index.ts\";\nimport type { HubInterface } from \"./hub.ts\";\n\nlet pathsCache: WeakMap<\n  HubInterface | typeof nullHub,\n  WeakMap<Node, Map<Node, NodePath>>\n> = new WeakMap();\nexport { pathsCache as path };\nexport let scope: WeakMap<Node, Scope> = new WeakMap();\n\nexport function clear() {\n  clearPath();\n  clearScope();\n}\n\nexport function clearPath() {\n  pathsCache = new WeakMap();\n}\n\nexport function clearScope() {\n  scope = new WeakMap();\n}\n\n// NodePath#hub can be null, but it's not a valid weakmap key because it\n// cannot be collected by GC. Use an object, knowing tht it will not be\n// collected anyway. It's not a memory leak because pathsCache.get(nullHub)\n// is itself a weakmap, so its entries can still be collected.\nconst nullHub = Object.freeze({} as const);\n\nexport function getCachedPaths(hub: HubInterface | null, parent: Node) {\n  if (!process.env.BABEL_8_BREAKING) {\n    // Only use Hub as part of the cache key in Babel 8, because it is a\n    // breaking change (it causes incompatibilities with older `@babel/core`\n    // versions: see https://github.com/babel/babel/pull/15759)\n    hub = null;\n  }\n  return pathsCache.get(hub ?? nullHub)?.get(parent);\n}\n\nexport function getOrCreateCachedPaths(hub: HubInterface | null, parent: Node) {\n  if (!process.env.BABEL_8_BREAKING) {\n    hub = null;\n  }\n\n  let parents = pathsCache.get(hub ?? nullHub);\n  if (!parents) pathsCache.set(hub ?? nullHub, (parents = new WeakMap()));\n\n  let paths = parents.get(parent);\n  if (!paths) parents.set(parent, (paths = new Map()));\n\n  return paths;\n}\n"],"mappings":";;;;;;;;;;;AAKA,IAAIA,UAGH,GAAAC,OAAA,CAAAC,IAAA,GAAG,IAAIC,OAAO,CAAC,CAAC;AAEV,IAAIC,KAA2B,GAAAH,OAAA,CAAAG,KAAA,GAAG,IAAID,OAAO,CAAC,CAAC;AAE/C,SAASE,KAAKA,CAAA,EAAG;EACtBC,SAAS,CAAC,CAAC;EACXC,UAAU,CAAC,CAAC;AACd;AAEO,SAASD,SAASA,CAAA,EAAG;EAC1BL,OAAA,CAAAC,IAAA,GAAAF,UAAU,GAAG,IAAIG,OAAO,CAAC,CAAC;AAC5B;AAEO,SAASI,UAAUA,CAAA,EAAG;EAC3BN,OAAA,CAAAG,KAAA,GAAAA,KAAK,GAAG,IAAID,OAAO,CAAC,CAAC;AACvB;AAMA,MAAMK,OAAO,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAU,CAAC;AAEnC,SAASC,cAAcA,CAACC,GAAwB,EAAEC,MAAY,EAAE;EAAA,IAAAC,eAAA,EAAAC,IAAA;EAClC;IAIjCH,GAAG,GAAG,IAAI;EACZ;EACA,QAAAE,eAAA,GAAOd,UAAU,CAACgB,GAAG,EAAAD,IAAA,GAACH,GAAG,YAAAG,IAAA,GAAIP,OAAO,CAAC,qBAA9BM,eAAA,CAAgCE,GAAG,CAACH,MAAM,CAAC;AACpD;AAEO,SAASI,sBAAsBA,CAACL,GAAwB,EAAEC,MAAY,EAAE;EAAA,IAAAK,KAAA,EAAAC,KAAA;EAC1C;IACjCP,GAAG,GAAG,IAAI;EACZ;EAEA,IAAIQ,OAAO,GAAGpB,UAAU,CAACgB,GAAG,EAAAE,KAAA,GAACN,GAAG,YAAAM,KAAA,GAAIV,OAAO,CAAC;EAC5C,IAAI,CAACY,OAAO,EAAEpB,UAAU,CAACqB,GAAG,EAAAF,KAAA,GAACP,GAAG,YAAAO,KAAA,GAAIX,OAAO,EAAGY,OAAO,GAAG,IAAIjB,OAAO,CAAC,CAAE,CAAC;EAEvE,IAAImB,KAAK,GAAGF,OAAO,CAACJ,GAAG,CAACH,MAAM,CAAC;EAC/B,IAAI,CAACS,KAAK,EAAEF,OAAO,CAACC,GAAG,CAACR,MAAM,EAAGS,KAAK,GAAG,IAAIC,GAAG,CAAC,CAAE,CAAC;EAEpD,OAAOD,KAAK;AACd","ignoreList":[]}
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)
