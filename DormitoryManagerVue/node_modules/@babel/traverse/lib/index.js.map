<<<<<<< HEAD
<<<<<<< HEAD
{"version":3,"names":["require","visitors","exports","_t","cache","_traverseNode","_index","_index2","_hub","VISITOR_KEYS","removeProperties","traverseFast","traverse","parent","opts","scope","state","parentPath","visitSelf","noScope","type","Error","explode","traverseNode","undefined","_default","default","verify","cheap","node","enter","path","skipKeys","clearNode","tree","hasType","denylistTypes","includes","skip","stop"],"sources":["../src/index.ts"],"sourcesContent":["import \"./path/context.ts\"; // We have some cycles, this ensures correct order to avoid TDZ\nimport * as visitors from \"./visitors.ts\";\nimport {\n  VISITOR_KEYS,\n  removeProperties,\n  type RemovePropertiesOptions,\n  traverseFast,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport * as cache from \"./cache.ts\";\nimport type NodePath from \"./path/index.ts\";\nimport type { default as Scope, Binding } from \"./scope/index.ts\";\nimport type { ExplodedVisitor, Visitor, VisitorBase } from \"./types.ts\";\nimport { traverseNode } from \"./traverse-node.ts\";\n\nexport type { ExplodedVisitor, Visitor, VisitorBase, Binding };\nexport { default as NodePath } from \"./path/index.ts\";\nexport { default as Scope } from \"./scope/index.ts\";\nexport { default as Hub } from \"./hub.ts\";\nexport type { HubInterface } from \"./hub.ts\";\nexport type { VisitWrapper } from \"./visitors.ts\";\n\nexport { visitors };\n\nexport type TraverseOptions<S = t.Node> = {\n  scope?: Scope;\n  noScope?: boolean;\n  denylist?: string[];\n  shouldSkip?: (node: NodePath) => boolean;\n} & Visitor<S>;\n\nexport type ExplodedTraverseOptions<S = t.Node> = TraverseOptions<S> &\n  ExplodedVisitor<S>;\n\nfunction traverse<S>(\n  parent: t.Node,\n  opts: TraverseOptions<S>,\n  scope: Scope | null | undefined,\n  state: S,\n  parentPath?: NodePath,\n  visitSelf?: boolean,\n): void;\n\nfunction traverse(\n  parent: t.Node,\n  opts: TraverseOptions,\n  scope?: Scope | null,\n  state?: any,\n  parentPath?: NodePath,\n  visitSelf?: boolean,\n): void;\n\nfunction traverse<Options extends TraverseOptions>(\n  parent: t.Node,\n  // @ts-expect-error provide {} as default value for Options\n  opts: Options = {},\n  scope?: Scope | null,\n  state?: any,\n  parentPath?: NodePath,\n  visitSelf?: boolean,\n) {\n  if (!parent) return;\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\n        \"You must pass a scope and parentPath unless traversing a Program/File. \" +\n          `Instead of that you tried to traverse a ${parent.type} node without ` +\n          \"passing scope and parentPath.\",\n      );\n    }\n  }\n\n  if (!parentPath && visitSelf) {\n    throw new Error(\"visitSelf can only be used when providing a NodePath.\");\n  }\n\n  if (!VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts as Visitor);\n\n  traverseNode(\n    parent,\n    opts as ExplodedVisitor,\n    scope,\n    state,\n    parentPath,\n    /* skipKeys */ undefined,\n    visitSelf,\n  );\n}\n\nexport default traverse;\n\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node: t.Node, enter: (node: t.Node) => void) {\n  traverseFast(node, enter);\n  return;\n};\n\ntraverse.node = function (\n  node: t.Node,\n  opts: ExplodedTraverseOptions,\n  scope?: Scope,\n  state?: any,\n  path?: NodePath,\n  skipKeys?: Record<string, boolean>,\n) {\n  traverseNode(node, opts, scope, state, path, skipKeys);\n  // traverse.node always returns undefined\n};\n\ntraverse.clearNode = function (node: t.Node, opts?: RemovePropertiesOptions) {\n  removeProperties(node, opts);\n};\n\ntraverse.removeProperties = function (\n  tree: t.Node,\n  opts?: RemovePropertiesOptions,\n) {\n  traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\ntraverse.hasType = function (\n  tree: t.Node,\n  type: t.Node[\"type\"],\n  denylistTypes?: Array<string>,\n): boolean {\n  // the node we're searching in is denylisted\n  if (denylistTypes?.includes(tree.type)) return false;\n\n  // the type we're looking for is the same as the passed node\n  if (tree.type === type) return true;\n\n  return traverseFast(tree, function (node) {\n    if (denylistTypes?.includes(node.type)) {\n      return traverseFast.skip;\n    }\n    if (node.type === type) {\n      return traverseFast.stop;\n    }\n  });\n};\n\ntraverse.cache = cache;\n"],"mappings":"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","ignoreList":[]}
=======
{"version":3,"names":["VISITOR_KEYS","removeProperties","traverseFast","traverse","parent","opts","scope","state","parentPath","noScope","type","Error","visitors","explode","traverseNode","verify","cheap","node","enter","path","skipKeys","clearNode","cache","delete","tree","hasDenylistedType","has","stop","hasType","denylistTypes","includes","denylist"],"sources":["../src/index.ts"],"sourcesContent":["import * as visitors from \"./visitors\";\nimport {\n  VISITOR_KEYS,\n  removeProperties,\n  type RemovePropertiesOptions,\n  traverseFast,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport * as cache from \"./cache\";\nimport type NodePath from \"./path\";\nimport type { default as Scope, Binding } from \"./scope\";\nimport type { Visitor } from \"./types\";\nimport { traverseNode } from \"./traverse-node\";\n\nexport type { Visitor, Binding };\nexport { default as NodePath } from \"./path\";\nexport { default as Scope } from \"./scope\";\nexport { default as Hub } from \"./hub\";\nexport type { HubInterface } from \"./hub\";\n\nexport { visitors };\n\nexport type TraverseOptions<S = t.Node> = {\n  scope?: Scope;\n  noScope?: boolean;\n  denylist?: string[];\n} & Visitor<S>;\n\nfunction traverse<S>(\n  parent: t.Node,\n  opts: TraverseOptions<S>,\n  scope: Scope | undefined,\n  state: S,\n  parentPath?: NodePath,\n): void;\n\nfunction traverse(\n  parent: t.Node,\n  opts: TraverseOptions,\n  scope?: Scope,\n  state?: any,\n  parentPath?: NodePath,\n): void;\n\nfunction traverse<Options extends TraverseOptions>(\n  parent: t.Node,\n  // @ts-expect-error provide {} as default value for Options\n  opts: Options = {},\n  scope?: Scope,\n  state?: any,\n  parentPath?: NodePath,\n) {\n  if (!parent) return;\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\n        \"You must pass a scope and parentPath unless traversing a Program/File. \" +\n          `Instead of that you tried to traverse a ${parent.type} node without ` +\n          \"passing scope and parentPath.\",\n      );\n    }\n  }\n\n  if (!VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts as Visitor);\n\n  traverseNode(parent, opts, scope, state, parentPath);\n}\n\nexport default traverse;\n\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node: t.Node, enter: (node: t.Node) => void) {\n  return traverseFast(node, enter);\n};\n\ntraverse.node = function (\n  node: t.Node,\n  opts: TraverseOptions,\n  scope?: Scope,\n  state?: any,\n  path?: NodePath,\n  skipKeys?: Record<string, boolean>,\n) {\n  traverseNode(node, opts, scope, state, path, skipKeys);\n  // traverse.node always returns undefined\n};\n\ntraverse.clearNode = function (node: t.Node, opts?: RemovePropertiesOptions) {\n  removeProperties(node, opts);\n\n  cache.path.delete(node);\n};\n\ntraverse.removeProperties = function (\n  tree: t.Node,\n  opts?: RemovePropertiesOptions,\n) {\n  traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\ntype HasDenylistedTypeState = {\n  has: boolean;\n  type: t.Node[\"type\"];\n};\nfunction hasDenylistedType(path: NodePath, state: HasDenylistedTypeState) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (\n  tree: t.Node,\n  type: t.Node[\"type\"],\n  denylistTypes?: Array<string>,\n): boolean {\n  // the node we're searching in is denylisted\n  if (denylistTypes?.includes(tree.type)) return false;\n\n  // the type we're looking for is the same as the passed node\n  if (tree.type === type) return true;\n\n  const state: HasDenylistedTypeState = {\n    has: false,\n    type: type,\n  };\n\n  traverse(\n    tree,\n    {\n      noScope: true,\n      denylist: denylistTypes,\n      enter: hasDenylistedType,\n    },\n    null,\n    state,\n  );\n\n  return state.has;\n};\n\ntraverse.cache = cache;\n"],"mappings":"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"}
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
{"version":3,"names":["visitors","require","exports","_t","cache","_traverseNode","_index","_index2","_hub","VISITOR_KEYS","removeProperties","traverseFast","traverse","parent","opts","scope","state","parentPath","visitSelf","noScope","type","Error","explode","traverseNode","_default","default","verify","cheap","node","enter","path","skipKeys","clearNode","tree","hasDenylistedType","has","stop","hasType","denylistTypes","includes","denylist"],"sources":["../src/index.ts"],"sourcesContent":["import * as visitors from \"./visitors.ts\";\nimport {\n  VISITOR_KEYS,\n  removeProperties,\n  type RemovePropertiesOptions,\n  traverseFast,\n} from \"@babel/types\";\nimport type * as t from \"@babel/types\";\nimport * as cache from \"./cache.ts\";\nimport type NodePath from \"./path/index.ts\";\nimport type { default as Scope, Binding } from \"./scope/index.ts\";\nimport type { ExplodedVisitor, Visitor } from \"./types.ts\";\nimport { traverseNode } from \"./traverse-node.ts\";\n\nexport type { ExplodedVisitor, Visitor, Binding };\nexport { default as NodePath } from \"./path/index.ts\";\nexport { default as Scope } from \"./scope/index.ts\";\nexport { default as Hub } from \"./hub.ts\";\nexport type { HubInterface } from \"./hub.ts\";\n\nexport { visitors };\n\nexport type TraverseOptions<S = t.Node> = {\n  scope?: Scope;\n  noScope?: boolean;\n  denylist?: string[];\n  shouldSkip?: (node: NodePath) => boolean;\n} & Visitor<S>;\n\nexport type ExplodedTraverseOptions<S = t.Node> = TraverseOptions<S> &\n  ExplodedVisitor<S>;\n\nfunction traverse<S>(\n  parent: t.Node,\n  opts: TraverseOptions<S>,\n  scope: Scope | undefined,\n  state: S,\n  parentPath?: NodePath,\n  visitSelf?: boolean,\n): void;\n\nfunction traverse(\n  parent: t.Node,\n  opts: TraverseOptions,\n  scope?: Scope,\n  state?: any,\n  parentPath?: NodePath,\n  visitSelf?: boolean,\n): void;\n\nfunction traverse<Options extends TraverseOptions>(\n  parent: t.Node,\n  // @ts-expect-error provide {} as default value for Options\n  opts: Options = {},\n  scope?: Scope,\n  state?: any,\n  parentPath?: NodePath,\n  visitSelf?: boolean,\n) {\n  if (!parent) return;\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\n        \"You must pass a scope and parentPath unless traversing a Program/File. \" +\n          `Instead of that you tried to traverse a ${parent.type} node without ` +\n          \"passing scope and parentPath.\",\n      );\n    }\n  }\n\n  if (!parentPath && visitSelf) {\n    throw new Error(\"visitSelf can only be used when providing a NodePath.\");\n  }\n\n  if (!VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts as Visitor);\n\n  traverseNode(\n    parent,\n    opts as ExplodedVisitor,\n    scope,\n    state,\n    parentPath,\n    /* skipKeys */ null,\n    visitSelf,\n  );\n}\n\nexport default traverse;\n\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node: t.Node, enter: (node: t.Node) => void) {\n  traverseFast(node, enter);\n  return;\n};\n\ntraverse.node = function (\n  node: t.Node,\n  opts: ExplodedTraverseOptions,\n  scope?: Scope,\n  state?: any,\n  path?: NodePath,\n  skipKeys?: Record<string, boolean>,\n) {\n  traverseNode(node, opts, scope, state, path, skipKeys);\n  // traverse.node always returns undefined\n};\n\ntraverse.clearNode = function (node: t.Node, opts?: RemovePropertiesOptions) {\n  removeProperties(node, opts);\n};\n\ntraverse.removeProperties = function (\n  tree: t.Node,\n  opts?: RemovePropertiesOptions,\n) {\n  traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\ntype HasDenylistedTypeState = {\n  has: boolean;\n  type: t.Node[\"type\"];\n};\nfunction hasDenylistedType(path: NodePath, state: HasDenylistedTypeState) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (\n  tree: t.Node,\n  type: t.Node[\"type\"],\n  denylistTypes?: Array<string>,\n): boolean {\n  // the node we're searching in is denylisted\n  if (denylistTypes?.includes(tree.type)) return false;\n\n  // the type we're looking for is the same as the passed node\n  if (tree.type === type) return true;\n\n  const state: HasDenylistedTypeState = {\n    has: false,\n    type: type,\n  };\n\n  traverse(\n    tree,\n    {\n      noScope: true,\n      denylist: denylistTypes,\n      enter: hasDenylistedType,\n    },\n    null,\n    state,\n  );\n\n  return state.has;\n};\n\ntraverse.cache = cache;\n"],"mappings":"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","ignoreList":[]}
>>>>>>> parent of 99ae58fb (修正代码，并打包成功上传部署到服务器（测试IP地址）)
