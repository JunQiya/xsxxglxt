<<<<<<< HEAD
<<<<<<< HEAD
{"version":3,"names":["_helperReplaceSupers","require","_core","_traverse","_helperAnnotateAsPure","_inlineCallSuperHelpers","buildConstructor","classRef","constructorBody","node","func","t","functionDeclaration","cloneNode","inherits","transformClass","path","file","builtinClasses","isLoose","assumptions","supportUnicodeId","classState","parent","undefined","scope","classId","superName","superReturns","isDerived","extendsNative","construct","userConstructor","userConstructorPath","hasConstructor","body","superThises","pushedInherits","pushedCreateClass","protoAlias","dynamicKeys","Map","methods","instance","hasComputed","list","map","static","setState","newState","Object","assign","findThisesVisitor","visitors","environmentVisitor","ThisExpression","push","createClassHelper","args","callExpression","addHelper","maybeCreateConstructor","classBodyPath","get","isClassMethod","kind","params","template","statement","ast","blockStatement","unshiftContainer","classMethod","identifier","buildBody","pushBody","verifyConstructor","pushDescriptors","classBodyPaths","isClassProperty","isClassPrivateProperty","buildCodeFrameError","decorators","isConstructor","replaceSupers","ReplaceSupers","methodPath","objectRef","superRef","constantSuper","refToPreserve","replace","traverse","ReturnStatement","getFunctionParent","isArrowFunctionExpression","pushConstructor","_path$ensureFunctionN","ensureFunctionName","NodePath","prototype","wrapped","replaceWith","pushMethod","pushInheritsToBody","props","placement","length","desc","obj","objectExpression","objectProperty","key","properties","arrayExpression","nullLiteral","lastNonNullIndex","i","isNullLiteral","slice","returnStatement","wrapSuperCall","bareSuper","thisRef","bareSuperNode","call","superIsCallableConstructor","arguments","unshift","thisExpression","isSpreadElement","isIdentifier","argument","name","callee","memberExpression","logicalExpression","_bareSuperNode$argume","bareSuperNodeArguments","addCallSuperHelper","parentPath","isExpressionStatement","container","assignmentExpression","maxGuaranteedSuperBeforeIndex","ref","generateDeclaredUidIdentifier","buildAssertThisInitialized","bareSupers","Super","isCallExpression","lastParentPath","find","Math","min","type","left","isConditional","test","object","guaranteedCalls","Set","thisPath","isMemberExpression","thisIndex","exprPath","isSequenceExpression","listKey","isOptionalCallExpression","has","add","wrapReturn","returnArg","thisExpr","returnParams","bodyPaths","guaranteedSuperBeforeFinish","pop","isReturnStatement","pushContainer","returnPath","processMethod","descKey","isNumericLiteral","isBigIntLiteral","stringLiteral","String","value","toComputedKey","isStringLiteral","fn","toExpression","descriptor","set","setClassMethods","insertProtoAliasOnce","methodName","computed","isLiteral","functionExpression","id","generator","async","expr","expressionStatement","inheritsComments","generateUidIdentifier","classProto","protoDeclaration","variableDeclaration","variableDeclarator","method","directives","hasInstanceDescriptors","hasStaticDescriptors","extractDynamicKeys","elem","isPure","generateUidIdentifierBasedOnNode","setupClosureParamsArgs","closureParams","closureArgs","arg","annotateAsPure","param","classTransformer","superClass","hasBinding","noClassCalls","isStrict","isInStrictMode","constructorOnly","directive","directiveLiteral","arrowFunctionExpression"],"sources":["../src/transformClass.ts"],"sourcesContent":["import type { NodePath, Scope, File } from \"@babel/core\";\nimport ReplaceSupers from \"@babel/helper-replace-supers\";\nimport { template, types as t } from \"@babel/core\";\nimport { visitors } from \"@babel/traverse\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\n\nimport addCallSuperHelper from \"./inline-callSuper-helpers.ts\";\n\ntype ClassAssumptions = {\n  setClassMethods: boolean;\n  constantSuper: boolean;\n  superIsCallableConstructor: boolean;\n  noClassCalls: boolean;\n};\n\ntype ClassConstructor = t.ClassMethod & { kind: \"constructor\" };\n\nfunction buildConstructor(\n  classRef: t.Identifier,\n  constructorBody: t.BlockStatement,\n  node: t.Class,\n) {\n  const func = t.functionDeclaration(\n    t.cloneNode(classRef),\n    [],\n    constructorBody,\n  );\n  t.inherits(func, node);\n  return func;\n}\n\ntype Descriptor = {\n  key: t.Expression;\n  get?: t.Expression | null;\n  set?: t.Expression | null;\n  value?: t.Expression | null;\n  constructor?: t.Expression | null;\n};\n\ntype State = {\n  parent: t.Node;\n  scope: Scope;\n  node: t.Class;\n  path: NodePath<t.Class>;\n  file: File;\n\n  classId: t.Identifier | void;\n  classRef: t.Identifier;\n  superName: t.Expression | null;\n  superReturns: NodePath<t.ReturnStatement>[];\n  isDerived: boolean;\n  extendsNative: boolean;\n\n  construct: t.FunctionDeclaration;\n  constructorBody: t.BlockStatement;\n  userConstructor: ClassConstructor;\n  userConstructorPath: NodePath<ClassConstructor>;\n  hasConstructor: boolean;\n\n  body: t.Statement[];\n  superThises: NodePath<t.ThisExpression>[];\n  pushedInherits: boolean;\n  pushedCreateClass: boolean;\n  protoAlias: t.Identifier | null;\n  isLoose: boolean;\n\n  dynamicKeys: Map<string, t.Expression>;\n\n  methods: {\n    // 'list' is in the same order as the elements appear in the class body.\n    // if there aren't computed keys, we can safely reorder class elements\n    // and use 'map' to merge duplicates.\n    instance: {\n      hasComputed: boolean;\n      list: Descriptor[];\n      map: Map<string, Descriptor>;\n    };\n    static: {\n      hasComputed: boolean;\n      list: Descriptor[];\n      map: Map<string, Descriptor>;\n    };\n  };\n};\n\ntype PropertyInfo = {\n  instance: t.ObjectExpression[] | null;\n  static: t.ObjectExpression[] | null;\n};\n\nexport default function transformClass(\n  path: NodePath<t.Class>,\n  file: File,\n  builtinClasses: ReadonlySet<string>,\n  isLoose: boolean,\n  assumptions: ClassAssumptions,\n  supportUnicodeId: boolean,\n) {\n  const classState: State = {\n    parent: undefined,\n    scope: undefined,\n    node: undefined,\n    path: undefined,\n    file: undefined,\n\n    classId: undefined,\n    classRef: undefined,\n    superName: null,\n    superReturns: [],\n    isDerived: false,\n    extendsNative: false,\n\n    construct: undefined,\n    constructorBody: undefined,\n    userConstructor: undefined,\n    userConstructorPath: undefined,\n    hasConstructor: false,\n\n    body: [],\n    superThises: [],\n    pushedInherits: false,\n    pushedCreateClass: false,\n    protoAlias: null,\n    isLoose: false,\n\n    dynamicKeys: new Map(),\n\n    methods: {\n      instance: {\n        hasComputed: false,\n        list: [],\n        map: new Map(),\n      },\n      static: {\n        hasComputed: false,\n        list: [],\n        map: new Map(),\n      },\n    },\n  };\n\n  const setState = (newState: Partial<State>) => {\n    Object.assign(classState, newState);\n  };\n\n  const findThisesVisitor = visitors.environmentVisitor({\n    ThisExpression(path) {\n      classState.superThises.push(path);\n    },\n  });\n\n  function createClassHelper(args: t.Expression[]) {\n    return t.callExpression(classState.file.addHelper(\"createClass\"), args);\n  }\n\n  /**\n   * Creates a class constructor or bail out if there is one\n   */\n  function maybeCreateConstructor() {\n    const classBodyPath = classState.path.get(\"body\");\n    for (const path of classBodyPath.get(\"body\")) {\n      if (path.isClassMethod({ kind: \"constructor\" })) return;\n    }\n\n    const params: t.FunctionExpression[\"params\"] = [];\n    let body;\n\n    if (classState.isDerived) {\n      body = template.statement.ast`{\n          super(...arguments);\n        }` as t.BlockStatement;\n    } else {\n      body = t.blockStatement([]);\n    }\n\n    classBodyPath.unshiftContainer(\n      \"body\",\n      t.classMethod(\"constructor\", t.identifier(\"constructor\"), params, body),\n    );\n  }\n\n  function buildBody() {\n    maybeCreateConstructor();\n    pushBody();\n    verifyConstructor();\n\n    if (classState.userConstructor) {\n      const { constructorBody, userConstructor, construct } = classState;\n\n      constructorBody.body.push(...userConstructor.body.body);\n      t.inherits(construct, userConstructor);\n      t.inherits(constructorBody, userConstructor.body);\n    }\n\n    pushDescriptors();\n  }\n\n  function pushBody() {\n    const classBodyPaths: Array<any> = classState.path.get(\"body.body\");\n\n    for (const path of classBodyPaths) {\n      const node = path.node;\n\n      if (path.isClassProperty() || path.isClassPrivateProperty()) {\n        throw path.buildCodeFrameError(\"Missing class properties transform.\");\n      }\n\n      if (node.decorators) {\n        throw path.buildCodeFrameError(\n          \"Method has decorators, put the decorator plugin before the classes one.\",\n        );\n      }\n\n      if (t.isClassMethod(node)) {\n        const isConstructor = node.kind === \"constructor\";\n\n        const replaceSupers = new ReplaceSupers({\n          methodPath: path,\n          objectRef: classState.classRef,\n          superRef: classState.superName,\n          constantSuper: assumptions.constantSuper,\n          file: classState.file,\n          refToPreserve: classState.classRef,\n        });\n\n        replaceSupers.replace();\n\n        const superReturns: NodePath<t.ReturnStatement>[] = [];\n        path.traverse(\n          visitors.environmentVisitor({\n            ReturnStatement(path) {\n              if (!path.getFunctionParent().isArrowFunctionExpression()) {\n                superReturns.push(path);\n              }\n            },\n          }),\n        );\n\n        if (isConstructor) {\n          pushConstructor(superReturns, node as ClassConstructor, path);\n        } else {\n          if (!process.env.BABEL_8_BREAKING && !USE_ESM && !IS_STANDALONE) {\n            // polyfill when being run by an older Babel version\n            path.ensureFunctionName ??=\n              // eslint-disable-next-line no-restricted-globals\n              require(\"@babel/traverse\").NodePath.prototype.ensureFunctionName;\n          }\n          path.ensureFunctionName(supportUnicodeId);\n          let wrapped;\n          if (node !== path.node) {\n            wrapped = path.node;\n            // The node has been wrapped. Reset it to the original once, but store the wrapper.\n            path.replaceWith(node);\n          }\n\n          pushMethod(node, wrapped);\n        }\n      }\n    }\n  }\n\n  function pushDescriptors() {\n    pushInheritsToBody();\n\n    const { body } = classState;\n\n    const props: PropertyInfo = {\n      instance: null,\n      static: null,\n    };\n\n    for (const placement of [\"static\", \"instance\"] as const) {\n      if (classState.methods[placement].list.length) {\n        props[placement] = classState.methods[placement].list.map(desc => {\n          const obj = t.objectExpression([\n            t.objectProperty(t.identifier(\"key\"), desc.key),\n          ]);\n\n          for (const kind of [\"get\", \"set\", \"value\"] as const) {\n            if (desc[kind] != null) {\n              obj.properties.push(\n                t.objectProperty(t.identifier(kind), desc[kind]),\n              );\n            }\n          }\n\n          return obj;\n        });\n      }\n    }\n\n    if (props.instance || props.static) {\n      let args = [\n        t.cloneNode(classState.classRef), // Constructor\n        props.instance ? t.arrayExpression(props.instance) : t.nullLiteral(), // instanceDescriptors\n        props.static ? t.arrayExpression(props.static) : t.nullLiteral(), // staticDescriptors\n      ];\n\n      let lastNonNullIndex = 0;\n      for (let i = 0; i < args.length; i++) {\n        if (!t.isNullLiteral(args[i])) lastNonNullIndex = i;\n      }\n      args = args.slice(0, lastNonNullIndex + 1);\n\n      body.push(t.returnStatement(createClassHelper(args)));\n      classState.pushedCreateClass = true;\n    }\n  }\n\n  function wrapSuperCall(\n    bareSuper: NodePath<t.CallExpression>,\n    superRef: t.Expression,\n    thisRef: () => t.Identifier,\n    body: NodePath<t.BlockStatement>,\n  ) {\n    const bareSuperNode = bareSuper.node;\n    let call;\n\n    if (assumptions.superIsCallableConstructor) {\n      bareSuperNode.arguments.unshift(t.thisExpression());\n      if (\n        bareSuperNode.arguments.length === 2 &&\n        t.isSpreadElement(bareSuperNode.arguments[1]) &&\n        t.isIdentifier(bareSuperNode.arguments[1].argument, {\n          name: \"arguments\",\n        })\n      ) {\n        // special case single arguments spread\n        bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;\n        bareSuperNode.callee = t.memberExpression(\n          t.cloneNode(superRef),\n          t.identifier(\"apply\"),\n        );\n      } else {\n        bareSuperNode.callee = t.memberExpression(\n          t.cloneNode(superRef),\n          t.identifier(\"call\"),\n        );\n      }\n\n      call = t.logicalExpression(\"||\", bareSuperNode, t.thisExpression());\n    } else {\n      const args: t.Expression[] = [\n        t.thisExpression(),\n        t.cloneNode(classState.classRef),\n      ];\n      if (bareSuperNode.arguments?.length) {\n        const bareSuperNodeArguments = bareSuperNode.arguments as (\n          | t.Expression\n          | t.SpreadElement\n        )[];\n\n        /**\n         * test262/test/language/expressions/super/call-spread-err-sngl-err-itr-get-get.js\n         *\n         * var iter = {};\n         * Object.defineProperty(iter, Symbol.iterator, {\n         *   get: function() {\n         *     throw new Test262Error();\n         *   }\n         * })\n         * super(...iter);\n         */\n\n        if (\n          bareSuperNodeArguments.length === 1 &&\n          t.isSpreadElement(bareSuperNodeArguments[0]) &&\n          t.isIdentifier(bareSuperNodeArguments[0].argument, {\n            name: \"arguments\",\n          })\n        ) {\n          args.push(bareSuperNodeArguments[0].argument);\n        } else {\n          args.push(t.arrayExpression(bareSuperNodeArguments));\n        }\n      }\n      call = t.callExpression(addCallSuperHelper(classState.file), args);\n    }\n\n    if (\n      bareSuper.parentPath.isExpressionStatement() &&\n      bareSuper.parentPath.container === body.node.body &&\n      body.node.body.length - 1 === bareSuper.parentPath.key\n    ) {\n      // this super call is the last statement in the body so we can just straight up\n      // turn it into a return\n\n      if (classState.superThises.length) {\n        call = t.assignmentExpression(\"=\", thisRef(), call);\n      }\n\n      bareSuper.parentPath.replaceWith(t.returnStatement(call));\n    } else {\n      bareSuper.replaceWith(t.assignmentExpression(\"=\", thisRef(), call));\n    }\n  }\n\n  function verifyConstructor() {\n    if (!classState.isDerived) return;\n\n    const path = classState.userConstructorPath;\n    const body = path.get(\"body\");\n\n    const constructorBody = path.get(\"body\");\n\n    let maxGuaranteedSuperBeforeIndex = constructorBody.node.body.length;\n\n    path.traverse(findThisesVisitor);\n\n    let thisRef = function () {\n      const ref = path.scope.generateDeclaredUidIdentifier(\"this\");\n      maxGuaranteedSuperBeforeIndex++;\n      thisRef = () => t.cloneNode(ref);\n      return ref;\n    };\n\n    const buildAssertThisInitialized = function () {\n      return t.callExpression(\n        classState.file.addHelper(\"assertThisInitialized\"),\n        [thisRef()],\n      );\n    };\n\n    const bareSupers: NodePath<t.CallExpression>[] = [];\n    path.traverse(\n      visitors.environmentVisitor({\n        Super(path) {\n          const { node, parentPath } = path;\n          if (parentPath.isCallExpression({ callee: node })) {\n            bareSupers.unshift(parentPath);\n          }\n        },\n      }),\n    );\n\n    for (const bareSuper of bareSupers) {\n      wrapSuperCall(bareSuper, classState.superName, thisRef, body);\n\n      if (maxGuaranteedSuperBeforeIndex >= 0) {\n        let lastParentPath: NodePath;\n        bareSuper.find(function (parentPath) {\n          // hit top so short circuit\n          if (parentPath === constructorBody) {\n            maxGuaranteedSuperBeforeIndex = Math.min(\n              maxGuaranteedSuperBeforeIndex,\n              lastParentPath.key as number,\n            );\n            return true;\n          }\n\n          const { type } = parentPath;\n          switch (type) {\n            case \"ExpressionStatement\":\n            case \"SequenceExpression\":\n            case \"AssignmentExpression\":\n            case \"BinaryExpression\":\n            case \"MemberExpression\":\n            case \"CallExpression\":\n            case \"NewExpression\":\n            case \"VariableDeclarator\":\n            case \"VariableDeclaration\":\n            case \"BlockStatement\":\n            case \"ArrayExpression\":\n            case \"ObjectExpression\":\n            case \"ObjectProperty\":\n            case \"TemplateLiteral\":\n              lastParentPath = parentPath;\n              return false;\n            default:\n              if (\n                (type === \"LogicalExpression\" &&\n                  parentPath.node.left === lastParentPath.node) ||\n                (parentPath.isConditional() &&\n                  parentPath.node.test === lastParentPath.node) ||\n                (type === \"OptionalCallExpression\" &&\n                  parentPath.node.callee === lastParentPath.node) ||\n                (type === \"OptionalMemberExpression\" &&\n                  parentPath.node.object === lastParentPath.node)\n              ) {\n                lastParentPath = parentPath;\n                return false;\n              }\n          }\n\n          maxGuaranteedSuperBeforeIndex = -1;\n          return true;\n        });\n      }\n    }\n\n    const guaranteedCalls = new Set<NodePath>();\n\n    for (const thisPath of classState.superThises) {\n      const { node, parentPath } = thisPath;\n      if (parentPath.isMemberExpression({ object: node })) {\n        thisPath.replaceWith(thisRef());\n        continue;\n      }\n\n      let thisIndex: number;\n      thisPath.find(function (parentPath) {\n        if (parentPath.parentPath === constructorBody) {\n          thisIndex = parentPath.key as number;\n          return true;\n        }\n      });\n\n      let exprPath: NodePath = thisPath.parentPath.isSequenceExpression()\n        ? thisPath.parentPath\n        : thisPath;\n      if (\n        exprPath.listKey === \"arguments\" &&\n        (exprPath.parentPath.isCallExpression() ||\n          exprPath.parentPath.isOptionalCallExpression())\n      ) {\n        exprPath = exprPath.parentPath;\n      } else {\n        exprPath = null;\n      }\n\n      if (\n        (maxGuaranteedSuperBeforeIndex !== -1 &&\n          thisIndex > maxGuaranteedSuperBeforeIndex) ||\n        guaranteedCalls.has(exprPath)\n      ) {\n        thisPath.replaceWith(thisRef());\n      } else {\n        if (exprPath) {\n          guaranteedCalls.add(exprPath);\n        }\n        thisPath.replaceWith(buildAssertThisInitialized());\n      }\n    }\n\n    let wrapReturn;\n\n    if (classState.isLoose) {\n      wrapReturn = (returnArg: t.Expression | void) => {\n        const thisExpr = buildAssertThisInitialized();\n        return returnArg\n          ? t.logicalExpression(\"||\", returnArg, thisExpr)\n          : thisExpr;\n      };\n    } else {\n      wrapReturn = (returnArg: t.Expression | undefined) => {\n        const returnParams: t.Expression[] = [thisRef()];\n        if (returnArg != null) {\n          returnParams.push(returnArg);\n        }\n        return t.callExpression(\n          classState.file.addHelper(\"possibleConstructorReturn\"),\n          returnParams,\n        );\n      };\n    }\n\n    // if we have a return as the last node in the body then we've already caught that\n    // return\n    const bodyPaths = body.get(\"body\");\n    const guaranteedSuperBeforeFinish =\n      maxGuaranteedSuperBeforeIndex !== -1 &&\n      maxGuaranteedSuperBeforeIndex < bodyPaths.length;\n    if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {\n      body.pushContainer(\n        \"body\",\n        t.returnStatement(\n          guaranteedSuperBeforeFinish\n            ? thisRef()\n            : buildAssertThisInitialized(),\n        ),\n      );\n    }\n\n    for (const returnPath of classState.superReturns) {\n      returnPath\n        .get(\"argument\")\n        .replaceWith(wrapReturn(returnPath.node.argument));\n    }\n  }\n\n  /**\n   * Push a method to its respective mutatorMap.\n   */\n  function pushMethod(node: t.ClassMethod, wrapped?: t.Expression) {\n    if (node.kind === \"method\") {\n      if (processMethod(node)) return;\n    }\n\n    const placement = node.static ? \"static\" : \"instance\";\n    const methods = classState.methods[placement];\n\n    const descKey = node.kind === \"method\" ? \"value\" : node.kind;\n    const key =\n      t.isNumericLiteral(node.key) || t.isBigIntLiteral(node.key)\n        ? t.stringLiteral(String(node.key.value))\n        : t.toComputedKey(node);\n    methods.hasComputed = !t.isStringLiteral(key);\n\n    const fn: t.Expression = wrapped ?? t.toExpression(node);\n\n    let descriptor: Descriptor;\n    if (\n      !methods.hasComputed &&\n      methods.map.has((key as t.StringLiteral).value)\n    ) {\n      descriptor = methods.map.get((key as t.StringLiteral).value);\n      descriptor[descKey] = fn;\n\n      if (descKey === \"value\") {\n        descriptor.get = null;\n        descriptor.set = null;\n      } else {\n        descriptor.value = null;\n      }\n    } else {\n      descriptor = {\n        key:\n          // private name has been handled in class-properties transform\n          key as t.Expression,\n        [descKey]: fn,\n      } as Descriptor;\n      methods.list.push(descriptor);\n\n      if (!methods.hasComputed) {\n        methods.map.set((key as t.StringLiteral).value, descriptor);\n      }\n    }\n  }\n\n  function processMethod(node: t.ClassMethod) {\n    if (assumptions.setClassMethods && !node.decorators) {\n      // use assignments instead of define properties for loose classes\n      let { classRef } = classState;\n      if (!node.static) {\n        insertProtoAliasOnce();\n        classRef = classState.protoAlias;\n      }\n      const methodName = t.memberExpression(\n        t.cloneNode(classRef),\n        node.key,\n        node.computed || t.isLiteral(node.key),\n      );\n\n      const func: t.Expression = t.functionExpression(\n        // @ts-expect-error We actually set and id through .ensureFunctionName\n        node.id,\n        // @ts-expect-error Fixme: should throw when we see TSParameterProperty\n        node.params,\n        node.body,\n        node.generator,\n        node.async,\n      );\n      t.inherits(func, node);\n\n      const expr = t.expressionStatement(\n        t.assignmentExpression(\"=\", methodName, func),\n      );\n      t.inheritsComments(expr, node);\n      classState.body.push(expr);\n      return true;\n    }\n\n    return false;\n  }\n\n  function insertProtoAliasOnce() {\n    if (classState.protoAlias === null) {\n      setState({ protoAlias: classState.scope.generateUidIdentifier(\"proto\") });\n      const classProto = t.memberExpression(\n        classState.classRef,\n        t.identifier(\"prototype\"),\n      );\n      const protoDeclaration = t.variableDeclaration(\"var\", [\n        t.variableDeclarator(classState.protoAlias, classProto),\n      ]);\n\n      classState.body.push(protoDeclaration);\n    }\n  }\n\n  /**\n   * Replace the constructor body of our class.\n   */\n  function pushConstructor(\n    superReturns: NodePath<t.ReturnStatement>[],\n    method: ClassConstructor,\n    path: NodePath<ClassConstructor>,\n  ) {\n    setState({\n      userConstructorPath: path,\n      userConstructor: method,\n      hasConstructor: true,\n      superReturns,\n    });\n\n    const { construct } = classState;\n\n    t.inheritsComments(construct, method);\n\n    // @ts-expect-error Fixme: should throw when we see TSParameterProperty\n    construct.params = method.params;\n\n    t.inherits(construct.body, method.body);\n    construct.body.directives = method.body.directives;\n\n    // we haven't pushed any descriptors yet\n    // @ts-expect-error todo(flow->ts) maybe remove this block - properties from condition are not used anywhere else\n    if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {\n      pushDescriptors();\n    }\n\n    pushInheritsToBody();\n  }\n\n  /**\n   * Push inherits helper to body.\n   */\n  function pushInheritsToBody() {\n    if (!classState.isDerived || classState.pushedInherits) return;\n\n    classState.pushedInherits = true;\n\n    // Unshift to ensure that the constructor inheritance is set up before\n    // any properties can be assigned to the prototype.\n\n    classState.body.unshift(\n      t.expressionStatement(\n        t.callExpression(\n          classState.file.addHelper(\n            classState.isLoose ? \"inheritsLoose\" : \"inherits\",\n          ),\n          [t.cloneNode(classState.classRef), t.cloneNode(classState.superName)],\n        ),\n      ),\n    );\n  }\n\n  function extractDynamicKeys() {\n    const { dynamicKeys, node, scope } = classState;\n\n    for (const elem of node.body.body) {\n      if (!t.isClassMethod(elem) || !elem.computed) continue;\n      if (scope.isPure(elem.key, /* constants only*/ true)) continue;\n\n      const id = scope.generateUidIdentifierBasedOnNode(elem.key);\n      dynamicKeys.set(id.name, elem.key);\n\n      elem.key = id;\n    }\n  }\n\n  function setupClosureParamsArgs() {\n    const { superName, dynamicKeys } = classState;\n    const closureParams = [];\n    const closureArgs = [];\n\n    if (classState.isDerived) {\n      let arg = t.cloneNode(superName);\n      if (classState.extendsNative) {\n        arg = t.callExpression(classState.file.addHelper(\"wrapNativeSuper\"), [\n          arg,\n        ]);\n        annotateAsPure(arg);\n      }\n\n      const param =\n        classState.scope.generateUidIdentifierBasedOnNode(superName);\n\n      closureParams.push(param);\n      closureArgs.push(arg);\n\n      setState({ superName: t.cloneNode(param) });\n    }\n\n    for (const [name, value] of dynamicKeys) {\n      closureParams.push(t.identifier(name));\n      closureArgs.push(value);\n    }\n\n    return { closureParams, closureArgs };\n  }\n\n  function classTransformer(\n    path: NodePath<t.Class>,\n    file: File,\n    builtinClasses: ReadonlySet<string>,\n    isLoose: boolean,\n  ) {\n    setState({\n      parent: path.parent,\n      scope: path.scope,\n      node: path.node,\n      path,\n      file,\n      isLoose,\n    });\n\n    setState({\n      classId: classState.node.id,\n      // this is the name of the binding that will **always** reference the class we've constructed\n      classRef: classState.node.id\n        ? t.identifier(classState.node.id.name)\n        : classState.scope.generateUidIdentifier(\"class\"),\n      superName: classState.node.superClass,\n      isDerived: !!classState.node.superClass,\n      constructorBody: t.blockStatement([]),\n    });\n\n    setState({\n      extendsNative:\n        t.isIdentifier(classState.superName) &&\n        builtinClasses.has(classState.superName.name) &&\n        !classState.scope.hasBinding(\n          classState.superName.name,\n          /* noGlobals */ true,\n        ),\n    });\n\n    const { classRef, node, constructorBody } = classState;\n\n    setState({\n      construct: buildConstructor(classRef, constructorBody, node),\n    });\n\n    extractDynamicKeys();\n\n    const { body } = classState;\n    const { closureParams, closureArgs } = setupClosureParamsArgs();\n\n    buildBody();\n\n    // make sure this class isn't directly called (with A() instead new A())\n    if (!assumptions.noClassCalls) {\n      constructorBody.body.unshift(\n        t.expressionStatement(\n          t.callExpression(classState.file.addHelper(\"classCallCheck\"), [\n            t.thisExpression(),\n            t.cloneNode(classState.classRef),\n          ]),\n        ),\n      );\n    }\n\n    const isStrict = path.isInStrictMode();\n    let constructorOnly = body.length === 0;\n    if (constructorOnly && !isStrict) {\n      for (const param of classState.construct.params) {\n        // It's illegal to put a use strict directive into the body of a function\n        // with non-simple parameters for some reason. So, we have to use a strict\n        // wrapper function.\n        if (!t.isIdentifier(param)) {\n          constructorOnly = false;\n          break;\n        }\n      }\n    }\n\n    const directives = constructorOnly\n      ? classState.construct.body.directives\n      : [];\n    if (!isStrict) {\n      directives.push(t.directive(t.directiveLiteral(\"use strict\")));\n    }\n\n    if (constructorOnly) {\n      // named class with only a constructor\n      const expr = t.toExpression(classState.construct);\n      return classState.isLoose ? expr : createClassHelper([expr]);\n    }\n\n    if (!classState.pushedCreateClass) {\n      body.push(\n        t.returnStatement(\n          classState.isLoose\n            ? t.cloneNode(classState.classRef)\n            : createClassHelper([t.cloneNode(classState.classRef)]),\n        ),\n      );\n    }\n\n    body.unshift(classState.construct);\n\n    const container = t.arrowFunctionExpression(\n      closureParams,\n      t.blockStatement(body, directives),\n    );\n    return t.callExpression(container, closureArgs);\n  }\n\n  return classTransformer(path, file, builtinClasses, isLoose);\n}\n"],"mappings":"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","ignoreList":[]}
=======
{"version":3,"names":["buildConstructor","classRef","constructorBody","node","func","t","functionDeclaration","cloneNode","inherits","transformClass","path","file","builtinClasses","isLoose","assumptions","supportUnicodeId","classState","parent","undefined","scope","classId","superFnId","superName","superReturns","isDerived","extendsNative","construct","userConstructor","userConstructorPath","hasConstructor","body","superThises","pushedConstructor","pushedInherits","pushedCreateClass","protoAlias","dynamicKeys","Map","methods","instance","hasComputed","list","map","static","setState","newState","Object","assign","findThisesVisitor","traverse","visitors","merge","environmentVisitor","ThisExpression","push","createClassHelper","args","callExpression","addHelper","maybeCreateConstructor","paths","get","equals","params","constructor","template","expression","ast","blockStatement","unshiftContainer","classMethod","identifier","buildBody","pushBody","verifyConstructor","pushDescriptors","classBodyPaths","isClassProperty","buildCodeFrameError","decorators","isClassMethod","isConstructor","kind","replaceSupers","ReplaceSupers","methodPath","objectRef","superRef","constantSuper","refToPreserve","replace","ReturnStatement","getFunctionParent","isArrowFunctionExpression","pushConstructor","pushMethod","pushInheritsToBody","props","placement","length","desc","obj","objectExpression","objectProperty","key","properties","arrayExpression","nullLiteral","lastNonNullIndex","i","isNullLiteral","slice","expressionStatement","wrapSuperCall","bareSuper","thisRef","bareSuperNode","call","superIsCallableConstructor","arguments","unshift","thisExpression","isSpreadElement","isIdentifier","argument","name","callee","memberExpression","logicalExpression","optimiseCall","parentPath","isExpressionStatement","container","assignmentExpression","replaceWith","returnStatement","ref","generateDeclaredUidIdentifier","thisPath","isMemberExpression","object","bareSupers","Super","isCallExpression","guaranteedSuperBeforeFinish","find","isLoop","isConditional","wrapReturn","returnArg","thisExpr","returnParams","bodyPaths","pop","isReturnStatement","pushContainer","returnPath","processMethod","descKey","isNumericLiteral","isBigIntLiteral","stringLiteral","String","value","toComputedKey","fn","toExpression","isStringLiteral","nameFunction","id","descriptor","has","set","setClassMethods","insertProtoAliasOnce","methodName","computed","isLiteral","functionExpression","generator","async","expr","inheritsComments","generateUidIdentifier","classProto","protoDeclaration","variableDeclaration","variableDeclarator","method","directives","pushConstructorToBody","hasInstanceDescriptors","hasStaticDescriptors","addCreateSuperHelper","extractDynamicKeys","elem","isPure","generateUidIdentifierBasedOnNode","setupClosureParamsArgs","closureParams","closureArgs","arg","annotateAsPure","param","classTransformer","superClass","hasBinding","noClassCalls","isStrict","isInStrictMode","constructorOnly","directive","directiveLiteral","arrowFunctionExpression"],"sources":["../src/transformClass.ts"],"sourcesContent":["import type { NodePath, Scope, Visitor } from \"@babel/traverse\";\nimport nameFunction from \"@babel/helper-function-name\";\nimport ReplaceSupers from \"@babel/helper-replace-supers\";\nimport environmentVisitor from \"@babel/helper-environment-visitor\";\nimport optimiseCall from \"@babel/helper-optimise-call-expression\";\nimport { traverse, template, types as t, type File } from \"@babel/core\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\n\nimport addCreateSuperHelper from \"./inline-createSuper-helpers\";\n\ntype ClassAssumptions = {\n  setClassMethods: boolean;\n  constantSuper: boolean;\n  superIsCallableConstructor: boolean;\n  noClassCalls: boolean;\n};\n\ntype ClassConstructor = t.ClassMethod & { kind: \"constructor\" };\n\nfunction buildConstructor(\n  classRef: t.Identifier,\n  constructorBody: t.BlockStatement,\n  node: t.Class,\n) {\n  const func = t.functionDeclaration(\n    t.cloneNode(classRef),\n    [],\n    constructorBody,\n  );\n  t.inherits(func, node);\n  return func;\n}\n\ntype Descriptor = {\n  key: t.Expression;\n  get?: t.Expression | null;\n  set?: t.Expression | null;\n  value?: t.Expression | null;\n  constructor?: t.Expression | null;\n};\n\ntype State = {\n  parent: t.Node;\n  scope: Scope;\n  node: t.Class;\n  path: NodePath<t.Class>;\n  file: File;\n\n  classId: t.Identifier | void;\n  classRef: t.Identifier;\n  superFnId: t.Identifier;\n  superName: t.Expression | null;\n  superReturns: NodePath<t.ReturnStatement>[];\n  isDerived: boolean;\n  extendsNative: boolean;\n\n  construct: t.FunctionDeclaration;\n  constructorBody: t.BlockStatement;\n  userConstructor: ClassConstructor;\n  userConstructorPath: NodePath<ClassConstructor>;\n  hasConstructor: boolean;\n\n  body: t.Statement[];\n  superThises: NodePath<t.ThisExpression>[];\n  pushedConstructor: boolean;\n  pushedInherits: boolean;\n  pushedCreateClass: boolean;\n  protoAlias: t.Identifier | null;\n  isLoose: boolean;\n\n  dynamicKeys: Map<string, t.Expression>;\n\n  methods: {\n    // 'list' is in the same order as the elements appear in the class body.\n    // if there aren't computed keys, we can safely reorder class elements\n    // and use 'map' to merge duplicates.\n    instance: {\n      hasComputed: boolean;\n      list: Descriptor[];\n      map: Map<string, Descriptor>;\n    };\n    static: {\n      hasComputed: boolean;\n      list: Descriptor[];\n      map: Map<string, Descriptor>;\n    };\n  };\n};\n\ntype PropertyInfo = {\n  instance: t.ObjectExpression[] | null;\n  static: t.ObjectExpression[] | null;\n};\n\nexport default function transformClass(\n  path: NodePath<t.Class>,\n  file: File,\n  builtinClasses: ReadonlySet<string>,\n  isLoose: boolean,\n  assumptions: ClassAssumptions,\n  supportUnicodeId: boolean,\n) {\n  const classState: State = {\n    parent: undefined,\n    scope: undefined,\n    node: undefined,\n    path: undefined,\n    file: undefined,\n\n    classId: undefined,\n    classRef: undefined,\n    superFnId: undefined,\n    superName: null,\n    superReturns: [],\n    isDerived: false,\n    extendsNative: false,\n\n    construct: undefined,\n    constructorBody: undefined,\n    userConstructor: undefined,\n    userConstructorPath: undefined,\n    hasConstructor: false,\n\n    body: [],\n    superThises: [],\n    pushedConstructor: false,\n    pushedInherits: false,\n    pushedCreateClass: false,\n    protoAlias: null,\n    isLoose: false,\n\n    dynamicKeys: new Map(),\n\n    methods: {\n      instance: {\n        hasComputed: false,\n        list: [],\n        map: new Map(),\n      },\n      static: {\n        hasComputed: false,\n        list: [],\n        map: new Map(),\n      },\n    },\n  };\n\n  const setState = (newState: Partial<State>) => {\n    Object.assign(classState, newState);\n  };\n\n  const findThisesVisitor = traverse.visitors.merge([\n    environmentVisitor,\n    {\n      ThisExpression(path) {\n        classState.superThises.push(path);\n      },\n    },\n  ]);\n\n  function createClassHelper(args: t.Expression[]) {\n    return t.callExpression(classState.file.addHelper(\"createClass\"), args);\n  }\n\n  /**\n   * Creates a class constructor or bail out if there is none\n   */\n  function maybeCreateConstructor() {\n    let hasConstructor = false;\n    const paths = classState.path.get(\"body.body\");\n    for (const path of paths) {\n      // @ts-expect-error: StaticBlock does not have `kind` property\n      hasConstructor = path.equals(\"kind\", \"constructor\");\n      if (hasConstructor) break;\n    }\n    if (hasConstructor) return;\n\n    let params: t.FunctionExpression[\"params\"], body;\n\n    if (classState.isDerived) {\n      const constructor = template.expression.ast`\n        (function () {\n          super(...arguments);\n        })\n      ` as t.FunctionExpression;\n      params = constructor.params;\n      body = constructor.body;\n    } else {\n      params = [];\n      body = t.blockStatement([]);\n    }\n\n    classState.path\n      .get(\"body\")\n      .unshiftContainer(\n        \"body\",\n        t.classMethod(\"constructor\", t.identifier(\"constructor\"), params, body),\n      );\n  }\n\n  function buildBody() {\n    maybeCreateConstructor();\n    pushBody();\n    verifyConstructor();\n\n    if (classState.userConstructor) {\n      const { constructorBody, userConstructor, construct } = classState;\n\n      constructorBody.body.push(...userConstructor.body.body);\n      t.inherits(construct, userConstructor);\n      t.inherits(constructorBody, userConstructor.body);\n    }\n\n    pushDescriptors();\n  }\n\n  function pushBody() {\n    const classBodyPaths: Array<any> = classState.path.get(\"body.body\");\n\n    for (const path of classBodyPaths) {\n      const node = path.node;\n\n      if (path.isClassProperty()) {\n        throw path.buildCodeFrameError(\"Missing class properties transform.\");\n      }\n\n      if (node.decorators) {\n        throw path.buildCodeFrameError(\n          \"Method has decorators, put the decorator plugin before the classes one.\",\n        );\n      }\n\n      if (t.isClassMethod(node)) {\n        const isConstructor = node.kind === \"constructor\";\n\n        const replaceSupers = new ReplaceSupers({\n          methodPath: path,\n          objectRef: classState.classRef,\n          superRef: classState.superName,\n          constantSuper: assumptions.constantSuper,\n          file: classState.file,\n          refToPreserve: classState.classRef,\n        });\n\n        replaceSupers.replace();\n\n        const superReturns: NodePath<t.ReturnStatement>[] = [];\n        path.traverse(\n          traverse.visitors.merge([\n            environmentVisitor,\n            {\n              ReturnStatement(path) {\n                if (!path.getFunctionParent().isArrowFunctionExpression()) {\n                  superReturns.push(path);\n                }\n              },\n            },\n          ]),\n        );\n\n        if (isConstructor) {\n          pushConstructor(superReturns, node as ClassConstructor, path);\n        } else {\n          pushMethod(node, path);\n        }\n      }\n    }\n  }\n\n  function pushDescriptors() {\n    pushInheritsToBody();\n\n    const { body } = classState;\n\n    const props: PropertyInfo = {\n      instance: null,\n      static: null,\n    };\n\n    for (const placement of [\"static\", \"instance\"] as const) {\n      if (classState.methods[placement].list.length) {\n        props[placement] = classState.methods[placement].list.map(desc => {\n          const obj = t.objectExpression([\n            t.objectProperty(t.identifier(\"key\"), desc.key),\n          ]);\n\n          for (const kind of [\"get\", \"set\", \"value\"] as const) {\n            if (desc[kind] != null) {\n              obj.properties.push(\n                t.objectProperty(t.identifier(kind), desc[kind]),\n              );\n            }\n          }\n\n          return obj;\n        });\n      }\n    }\n\n    if (props.instance || props.static) {\n      let args = [\n        t.cloneNode(classState.classRef), // Constructor\n        props.instance ? t.arrayExpression(props.instance) : t.nullLiteral(), // instanceDescriptors\n        props.static ? t.arrayExpression(props.static) : t.nullLiteral(), // staticDescriptors\n      ];\n\n      let lastNonNullIndex = 0;\n      for (let i = 0; i < args.length; i++) {\n        if (!t.isNullLiteral(args[i])) lastNonNullIndex = i;\n      }\n      args = args.slice(0, lastNonNullIndex + 1);\n\n      body.push(t.expressionStatement(createClassHelper(args)));\n      classState.pushedCreateClass = true;\n    }\n  }\n\n  function wrapSuperCall(\n    bareSuper: NodePath<t.CallExpression>,\n    superRef: t.Expression,\n    thisRef: () => t.Identifier,\n    body: NodePath<t.BlockStatement>,\n  ) {\n    const bareSuperNode = bareSuper.node;\n    let call;\n\n    if (assumptions.superIsCallableConstructor) {\n      bareSuperNode.arguments.unshift(t.thisExpression());\n      if (\n        bareSuperNode.arguments.length === 2 &&\n        t.isSpreadElement(bareSuperNode.arguments[1]) &&\n        t.isIdentifier(bareSuperNode.arguments[1].argument, {\n          name: \"arguments\",\n        })\n      ) {\n        // special case single arguments spread\n        bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;\n        bareSuperNode.callee = t.memberExpression(\n          t.cloneNode(superRef),\n          t.identifier(\"apply\"),\n        );\n      } else {\n        bareSuperNode.callee = t.memberExpression(\n          t.cloneNode(superRef),\n          t.identifier(\"call\"),\n        );\n      }\n\n      call = t.logicalExpression(\"||\", bareSuperNode, t.thisExpression());\n    } else {\n      call = optimiseCall(\n        t.cloneNode(classState.superFnId),\n        t.thisExpression(),\n        bareSuperNode.arguments,\n        false,\n      );\n    }\n\n    if (\n      bareSuper.parentPath.isExpressionStatement() &&\n      bareSuper.parentPath.container === body.node.body &&\n      body.node.body.length - 1 === bareSuper.parentPath.key\n    ) {\n      // this super call is the last statement in the body so we can just straight up\n      // turn it into a return\n\n      if (classState.superThises.length) {\n        call = t.assignmentExpression(\"=\", thisRef(), call);\n      }\n\n      bareSuper.parentPath.replaceWith(t.returnStatement(call));\n    } else {\n      bareSuper.replaceWith(t.assignmentExpression(\"=\", thisRef(), call));\n    }\n  }\n\n  function verifyConstructor() {\n    if (!classState.isDerived) return;\n\n    const path = classState.userConstructorPath;\n    const body = path.get(\"body\");\n\n    path.traverse(findThisesVisitor);\n\n    let thisRef = function () {\n      const ref = path.scope.generateDeclaredUidIdentifier(\"this\");\n      thisRef = () => t.cloneNode(ref);\n      return ref;\n    };\n\n    for (const thisPath of classState.superThises) {\n      const { node, parentPath } = thisPath;\n      if (parentPath.isMemberExpression({ object: node })) {\n        thisPath.replaceWith(thisRef());\n        continue;\n      }\n      thisPath.replaceWith(\n        t.callExpression(classState.file.addHelper(\"assertThisInitialized\"), [\n          thisRef(),\n        ]),\n      );\n    }\n\n    const bareSupers: NodePath<t.CallExpression>[] = [];\n    path.traverse(\n      traverse.visitors.merge([\n        environmentVisitor,\n        {\n          Super(path) {\n            const { node, parentPath } = path;\n            if (parentPath.isCallExpression({ callee: node })) {\n              bareSupers.unshift(parentPath);\n            }\n          },\n        } as Visitor,\n      ]),\n    );\n\n    let guaranteedSuperBeforeFinish = !!bareSupers.length;\n\n    for (const bareSuper of bareSupers) {\n      wrapSuperCall(bareSuper, classState.superName, thisRef, body);\n\n      if (guaranteedSuperBeforeFinish) {\n        bareSuper.find(function (parentPath) {\n          // hit top so short circuit\n          if (parentPath === path) {\n            return true;\n          }\n\n          if (\n            parentPath.isLoop() ||\n            parentPath.isConditional() ||\n            parentPath.isArrowFunctionExpression()\n          ) {\n            guaranteedSuperBeforeFinish = false;\n            return true;\n          }\n        });\n      }\n    }\n\n    let wrapReturn;\n\n    if (classState.isLoose) {\n      wrapReturn = (returnArg: t.Expression | void) => {\n        const thisExpr = t.callExpression(\n          classState.file.addHelper(\"assertThisInitialized\"),\n          [thisRef()],\n        );\n        return returnArg\n          ? t.logicalExpression(\"||\", returnArg, thisExpr)\n          : thisExpr;\n      };\n    } else {\n      wrapReturn = (returnArg: t.Expression | undefined) => {\n        const returnParams: t.Expression[] = [thisRef()];\n        if (returnArg != null) {\n          returnParams.push(returnArg);\n        }\n        return t.callExpression(\n          classState.file.addHelper(\"possibleConstructorReturn\"),\n          returnParams,\n        );\n      };\n    }\n\n    // if we have a return as the last node in the body then we've already caught that\n    // return\n    const bodyPaths = body.get(\"body\");\n    if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {\n      body.pushContainer(\n        \"body\",\n        t.returnStatement(\n          guaranteedSuperBeforeFinish ? thisRef() : wrapReturn(),\n        ),\n      );\n    }\n\n    for (const returnPath of classState.superReturns) {\n      returnPath\n        .get(\"argument\")\n        .replaceWith(wrapReturn(returnPath.node.argument));\n    }\n  }\n\n  /**\n   * Push a method to its respective mutatorMap.\n   */\n  function pushMethod(node: t.ClassMethod, path?: NodePath) {\n    const scope = path ? path.scope : classState.scope;\n\n    if (node.kind === \"method\") {\n      if (processMethod(node, scope)) return;\n    }\n\n    const placement = node.static ? \"static\" : \"instance\";\n    const methods = classState.methods[placement];\n\n    const descKey = node.kind === \"method\" ? \"value\" : node.kind;\n    const key =\n      t.isNumericLiteral(node.key) || t.isBigIntLiteral(node.key)\n        ? t.stringLiteral(String(node.key.value))\n        : t.toComputedKey(node);\n\n    let fn: t.Expression = t.toExpression(node);\n\n    if (t.isStringLiteral(key)) {\n      // infer function name\n      if (node.kind === \"method\") {\n        // @ts-expect-error Fixme: we are passing a ClassMethod to nameFunction, but nameFunction\n        // does not seem to support it\n        fn =\n          nameFunction(\n            // @ts-expect-error Fixme: we are passing a ClassMethod to nameFunction, but nameFunction\n            // does not seem to support it\n            { id: key, node: node, scope },\n            undefined,\n            supportUnicodeId,\n          ) ?? fn;\n      }\n    } else {\n      // todo(flow->ts) find a way to avoid \"key as t.StringLiteral\" below which relies on this assignment\n      methods.hasComputed = true;\n    }\n\n    let descriptor: Descriptor;\n    if (\n      !methods.hasComputed &&\n      methods.map.has((key as t.StringLiteral).value)\n    ) {\n      descriptor = methods.map.get((key as t.StringLiteral).value);\n      descriptor[descKey] = fn;\n\n      if (descKey === \"value\") {\n        descriptor.get = null;\n        descriptor.set = null;\n      } else {\n        descriptor.value = null;\n      }\n    } else {\n      descriptor = {\n        key:\n          // private name has been handled in class-properties transform\n          key as t.Expression,\n        [descKey]: fn,\n      } as Descriptor;\n      methods.list.push(descriptor);\n\n      if (!methods.hasComputed) {\n        methods.map.set((key as t.StringLiteral).value, descriptor);\n      }\n    }\n  }\n\n  function processMethod(node: t.ClassMethod, scope: Scope) {\n    if (assumptions.setClassMethods && !node.decorators) {\n      // use assignments instead of define properties for loose classes\n      let { classRef } = classState;\n      if (!node.static) {\n        insertProtoAliasOnce();\n        classRef = classState.protoAlias;\n      }\n      const methodName = t.memberExpression(\n        t.cloneNode(classRef),\n        node.key,\n        node.computed || t.isLiteral(node.key),\n      );\n\n      let func: t.Expression = t.functionExpression(\n        null,\n        // @ts-expect-error Fixme: should throw when we see TSParameterProperty\n        node.params,\n        node.body,\n        node.generator,\n        node.async,\n      );\n      t.inherits(func, node);\n\n      const key = t.toComputedKey(node, node.key);\n      if (t.isStringLiteral(key)) {\n        // @ts-expect-error: requires strictNullCheck\n        func =\n          nameFunction(\n            {\n              node: func,\n              id: key,\n              scope,\n            },\n            undefined,\n            supportUnicodeId,\n          ) ?? func;\n      }\n\n      const expr = t.expressionStatement(\n        t.assignmentExpression(\"=\", methodName, func),\n      );\n      t.inheritsComments(expr, node);\n      classState.body.push(expr);\n      return true;\n    }\n\n    return false;\n  }\n\n  function insertProtoAliasOnce() {\n    if (classState.protoAlias === null) {\n      setState({ protoAlias: classState.scope.generateUidIdentifier(\"proto\") });\n      const classProto = t.memberExpression(\n        classState.classRef,\n        t.identifier(\"prototype\"),\n      );\n      const protoDeclaration = t.variableDeclaration(\"var\", [\n        t.variableDeclarator(classState.protoAlias, classProto),\n      ]);\n\n      classState.body.push(protoDeclaration);\n    }\n  }\n\n  /**\n   * Replace the constructor body of our class.\n   */\n  function pushConstructor(\n    superReturns: NodePath<t.ReturnStatement>[],\n    method: ClassConstructor,\n    path: NodePath<ClassConstructor>,\n  ) {\n    setState({\n      userConstructorPath: path,\n      userConstructor: method,\n      hasConstructor: true,\n      superReturns,\n    });\n\n    const { construct } = classState;\n\n    t.inheritsComments(construct, method);\n\n    // @ts-expect-error Fixme: should throw when we see TSParameterProperty\n    construct.params = method.params;\n\n    t.inherits(construct.body, method.body);\n    construct.body.directives = method.body.directives;\n\n    pushConstructorToBody();\n  }\n\n  function pushConstructorToBody() {\n    if (classState.pushedConstructor) return;\n    classState.pushedConstructor = true;\n\n    // we haven't pushed any descriptors yet\n    // @ts-expect-error todo(flow->ts) maybe remove this block - properties from condition are not used anywhere else\n    if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {\n      pushDescriptors();\n    }\n\n    classState.body.push(classState.construct);\n\n    pushInheritsToBody();\n  }\n\n  /**\n   * Push inherits helper to body.\n   */\n  function pushInheritsToBody() {\n    if (!classState.isDerived || classState.pushedInherits) return;\n\n    const superFnId = path.scope.generateUidIdentifier(\"super\");\n\n    setState({ pushedInherits: true, superFnId });\n\n    // Unshift to ensure that the constructor inheritance is set up before\n    // any properties can be assigned to the prototype.\n\n    if (!assumptions.superIsCallableConstructor) {\n      classState.body.unshift(\n        t.variableDeclaration(\"var\", [\n          t.variableDeclarator(\n            superFnId,\n            t.callExpression(addCreateSuperHelper(classState.file), [\n              t.cloneNode(classState.classRef),\n            ]),\n          ),\n        ]),\n      );\n    }\n\n    classState.body.unshift(\n      t.expressionStatement(\n        t.callExpression(\n          classState.file.addHelper(\n            classState.isLoose ? \"inheritsLoose\" : \"inherits\",\n          ),\n          [t.cloneNode(classState.classRef), t.cloneNode(classState.superName)],\n        ),\n      ),\n    );\n  }\n\n  function extractDynamicKeys() {\n    const { dynamicKeys, node, scope } = classState;\n\n    for (const elem of node.body.body) {\n      if (!t.isClassMethod(elem) || !elem.computed) continue;\n      if (scope.isPure(elem.key, /* constants only*/ true)) continue;\n\n      const id = scope.generateUidIdentifierBasedOnNode(elem.key);\n      dynamicKeys.set(id.name, elem.key);\n\n      elem.key = id;\n    }\n  }\n\n  function setupClosureParamsArgs() {\n    const { superName, dynamicKeys } = classState;\n    const closureParams = [];\n    const closureArgs = [];\n\n    if (classState.isDerived) {\n      let arg = t.cloneNode(superName);\n      if (classState.extendsNative) {\n        arg = t.callExpression(classState.file.addHelper(\"wrapNativeSuper\"), [\n          arg,\n        ]);\n        annotateAsPure(arg);\n      }\n\n      const param =\n        classState.scope.generateUidIdentifierBasedOnNode(superName);\n\n      closureParams.push(param);\n      closureArgs.push(arg);\n\n      setState({ superName: t.cloneNode(param) });\n    }\n\n    for (const [name, value] of dynamicKeys) {\n      closureParams.push(t.identifier(name));\n      closureArgs.push(value);\n    }\n\n    return { closureParams, closureArgs };\n  }\n\n  function classTransformer(\n    path: NodePath<t.Class>,\n    file: File,\n    builtinClasses: ReadonlySet<string>,\n    isLoose: boolean,\n  ) {\n    setState({\n      parent: path.parent,\n      scope: path.scope,\n      node: path.node,\n      path,\n      file,\n      isLoose,\n    });\n\n    setState({\n      classId: classState.node.id,\n      // this is the name of the binding that will **always** reference the class we've constructed\n      classRef: classState.node.id\n        ? t.identifier(classState.node.id.name)\n        : classState.scope.generateUidIdentifier(\"class\"),\n      superName: classState.node.superClass,\n      isDerived: !!classState.node.superClass,\n      constructorBody: t.blockStatement([]),\n    });\n\n    setState({\n      extendsNative:\n        t.isIdentifier(classState.superName) &&\n        builtinClasses.has(classState.superName.name) &&\n        !classState.scope.hasBinding(\n          classState.superName.name,\n          /* noGlobals */ true,\n        ),\n    });\n\n    const { classRef, node, constructorBody } = classState;\n\n    setState({\n      construct: buildConstructor(classRef, constructorBody, node),\n    });\n\n    extractDynamicKeys();\n\n    const { body } = classState;\n    const { closureParams, closureArgs } = setupClosureParamsArgs();\n\n    buildBody();\n\n    // make sure this class isn't directly called (with A() instead new A())\n    if (!assumptions.noClassCalls) {\n      constructorBody.body.unshift(\n        t.expressionStatement(\n          t.callExpression(classState.file.addHelper(\"classCallCheck\"), [\n            t.thisExpression(),\n            t.cloneNode(classState.classRef),\n          ]),\n        ),\n      );\n    }\n\n    const isStrict = path.isInStrictMode();\n    let constructorOnly = classState.classId && body.length === 1;\n    if (constructorOnly && !isStrict) {\n      for (const param of classState.construct.params) {\n        // It's illegal to put a use strict directive into the body of a function\n        // with non-simple parameters for some reason. So, we have to use a strict\n        // wrapper function.\n        if (!t.isIdentifier(param)) {\n          constructorOnly = false;\n          break;\n        }\n      }\n    }\n\n    const directives = constructorOnly\n      ? (body[0] as t.FunctionExpression | t.FunctionDeclaration).body\n          .directives\n      : [];\n    if (!isStrict) {\n      directives.push(t.directive(t.directiveLiteral(\"use strict\")));\n    }\n\n    if (constructorOnly) {\n      // named class with only a constructor\n      const expr = t.toExpression(\n        body[0] as t.FunctionExpression | t.FunctionDeclaration,\n      );\n      return classState.isLoose ? expr : createClassHelper([expr]);\n    }\n\n    let returnArg: t.Expression = t.cloneNode(classState.classRef);\n    if (!classState.pushedCreateClass && !classState.isLoose) {\n      returnArg = createClassHelper([returnArg]);\n    }\n\n    body.push(t.returnStatement(returnArg));\n    const container = t.arrowFunctionExpression(\n      closureParams,\n      t.blockStatement(body, directives),\n    );\n    return t.callExpression(container, closureArgs);\n  }\n\n  return classTransformer(path, file, builtinClasses, isLoose);\n}\n"],"mappings":"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"}
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
=======
{"version":3,"names":["_helperFunctionName","require","_helperReplaceSupers","_helperEnvironmentVisitor","_core","_helperAnnotateAsPure","_inlineCallSuperHelpers","buildConstructor","classRef","constructorBody","node","func","t","functionDeclaration","cloneNode","inherits","transformClass","path","file","builtinClasses","isLoose","assumptions","supportUnicodeId","classState","parent","undefined","scope","classId","superName","superReturns","isDerived","extendsNative","construct","userConstructor","userConstructorPath","hasConstructor","body","superThises","pushedInherits","pushedCreateClass","protoAlias","dynamicKeys","Map","methods","instance","hasComputed","list","map","static","setState","newState","Object","assign","findThisesVisitor","traverse","visitors","merge","environmentVisitor","ThisExpression","push","createClassHelper","args","callExpression","addHelper","maybeCreateConstructor","classBodyPath","get","isClassMethod","kind","params","constructor","template","expression","ast","blockStatement","unshiftContainer","classMethod","identifier","buildBody","pushBody","verifyConstructor","pushDescriptors","classBodyPaths","isClassProperty","isClassPrivateProperty","buildCodeFrameError","decorators","isConstructor","replaceSupers","ReplaceSupers","methodPath","objectRef","superRef","constantSuper","refToPreserve","replace","ReturnStatement","getFunctionParent","isArrowFunctionExpression","pushConstructor","pushMethod","pushInheritsToBody","props","placement","length","desc","obj","objectExpression","objectProperty","key","properties","arrayExpression","nullLiteral","lastNonNullIndex","i","isNullLiteral","slice","returnStatement","wrapSuperCall","bareSuper","thisRef","bareSuperNode","call","superIsCallableConstructor","arguments","unshift","thisExpression","isSpreadElement","isIdentifier","argument","name","callee","memberExpression","logicalExpression","_bareSuperNode$argume","bareSuperNodeArguments","addCallSuperHelper","parentPath","isExpressionStatement","container","assignmentExpression","replaceWith","maxGuaranteedSuperBeforeIndex","ref","generateDeclaredUidIdentifier","buildAssertThisInitialized","bareSupers","Super","isCallExpression","lastParentPath","find","Math","min","isLoop","isConditional","thisPath","isMemberExpression","object","thisIndex","wrapReturn","returnArg","thisExpr","returnParams","bodyPaths","guaranteedSuperBeforeFinish","pop","isReturnStatement","pushContainer","returnPath","processMethod","descKey","isNumericLiteral","isBigIntLiteral","stringLiteral","String","value","toComputedKey","fn","toExpression","isStringLiteral","_nameFunction","nameFunction","id","descriptor","has","set","setClassMethods","insertProtoAliasOnce","methodName","computed","isLiteral","functionExpression","generator","async","_nameFunction2","expr","expressionStatement","inheritsComments","generateUidIdentifier","classProto","protoDeclaration","variableDeclaration","variableDeclarator","method","directives","hasInstanceDescriptors","hasStaticDescriptors","extractDynamicKeys","elem","isPure","generateUidIdentifierBasedOnNode","setupClosureParamsArgs","closureParams","closureArgs","arg","annotateAsPure","param","classTransformer","superClass","hasBinding","noClassCalls","isStrict","isInStrictMode","constructorOnly","directive","directiveLiteral","arrowFunctionExpression"],"sources":["../src/transformClass.ts"],"sourcesContent":["import type { NodePath, Scope, Visitor } from \"@babel/traverse\";\nimport nameFunction from \"@babel/helper-function-name\";\nimport ReplaceSupers from \"@babel/helper-replace-supers\";\nimport environmentVisitor from \"@babel/helper-environment-visitor\";\nimport { traverse, template, types as t, type File } from \"@babel/core\";\nimport annotateAsPure from \"@babel/helper-annotate-as-pure\";\n\nimport addCallSuperHelper from \"./inline-callSuper-helpers.ts\";\n\ntype ClassAssumptions = {\n  setClassMethods: boolean;\n  constantSuper: boolean;\n  superIsCallableConstructor: boolean;\n  noClassCalls: boolean;\n};\n\ntype ClassConstructor = t.ClassMethod & { kind: \"constructor\" };\n\nfunction buildConstructor(\n  classRef: t.Identifier,\n  constructorBody: t.BlockStatement,\n  node: t.Class,\n) {\n  const func = t.functionDeclaration(\n    t.cloneNode(classRef),\n    [],\n    constructorBody,\n  );\n  t.inherits(func, node);\n  return func;\n}\n\ntype Descriptor = {\n  key: t.Expression;\n  get?: t.Expression | null;\n  set?: t.Expression | null;\n  value?: t.Expression | null;\n  constructor?: t.Expression | null;\n};\n\ntype State = {\n  parent: t.Node;\n  scope: Scope;\n  node: t.Class;\n  path: NodePath<t.Class>;\n  file: File;\n\n  classId: t.Identifier | void;\n  classRef: t.Identifier;\n  superName: t.Expression | null;\n  superReturns: NodePath<t.ReturnStatement>[];\n  isDerived: boolean;\n  extendsNative: boolean;\n\n  construct: t.FunctionDeclaration;\n  constructorBody: t.BlockStatement;\n  userConstructor: ClassConstructor;\n  userConstructorPath: NodePath<ClassConstructor>;\n  hasConstructor: boolean;\n\n  body: t.Statement[];\n  superThises: NodePath<t.ThisExpression>[];\n  pushedInherits: boolean;\n  pushedCreateClass: boolean;\n  protoAlias: t.Identifier | null;\n  isLoose: boolean;\n\n  dynamicKeys: Map<string, t.Expression>;\n\n  methods: {\n    // 'list' is in the same order as the elements appear in the class body.\n    // if there aren't computed keys, we can safely reorder class elements\n    // and use 'map' to merge duplicates.\n    instance: {\n      hasComputed: boolean;\n      list: Descriptor[];\n      map: Map<string, Descriptor>;\n    };\n    static: {\n      hasComputed: boolean;\n      list: Descriptor[];\n      map: Map<string, Descriptor>;\n    };\n  };\n};\n\ntype PropertyInfo = {\n  instance: t.ObjectExpression[] | null;\n  static: t.ObjectExpression[] | null;\n};\n\nexport default function transformClass(\n  path: NodePath<t.Class>,\n  file: File,\n  builtinClasses: ReadonlySet<string>,\n  isLoose: boolean,\n  assumptions: ClassAssumptions,\n  supportUnicodeId: boolean,\n) {\n  const classState: State = {\n    parent: undefined,\n    scope: undefined,\n    node: undefined,\n    path: undefined,\n    file: undefined,\n\n    classId: undefined,\n    classRef: undefined,\n    superName: null,\n    superReturns: [],\n    isDerived: false,\n    extendsNative: false,\n\n    construct: undefined,\n    constructorBody: undefined,\n    userConstructor: undefined,\n    userConstructorPath: undefined,\n    hasConstructor: false,\n\n    body: [],\n    superThises: [],\n    pushedInherits: false,\n    pushedCreateClass: false,\n    protoAlias: null,\n    isLoose: false,\n\n    dynamicKeys: new Map(),\n\n    methods: {\n      instance: {\n        hasComputed: false,\n        list: [],\n        map: new Map(),\n      },\n      static: {\n        hasComputed: false,\n        list: [],\n        map: new Map(),\n      },\n    },\n  };\n\n  const setState = (newState: Partial<State>) => {\n    Object.assign(classState, newState);\n  };\n\n  const findThisesVisitor = traverse.visitors.merge([\n    environmentVisitor,\n    {\n      ThisExpression(path) {\n        classState.superThises.push(path);\n      },\n    },\n  ]);\n\n  function createClassHelper(args: t.Expression[]) {\n    return t.callExpression(classState.file.addHelper(\"createClass\"), args);\n  }\n\n  /**\n   * Creates a class constructor or bail out if there is one\n   */\n  function maybeCreateConstructor() {\n    const classBodyPath = classState.path.get(\"body\");\n    for (const path of classBodyPath.get(\"body\")) {\n      if (path.isClassMethod({ kind: \"constructor\" })) return;\n    }\n\n    let params: t.FunctionExpression[\"params\"], body;\n\n    if (classState.isDerived) {\n      const constructor = template.expression.ast`\n        (function () {\n          super(...arguments);\n        })\n      ` as t.FunctionExpression;\n      params = constructor.params;\n      body = constructor.body;\n    } else {\n      params = [];\n      body = t.blockStatement([]);\n    }\n\n    classBodyPath.unshiftContainer(\n      \"body\",\n      t.classMethod(\"constructor\", t.identifier(\"constructor\"), params, body),\n    );\n  }\n\n  function buildBody() {\n    maybeCreateConstructor();\n    pushBody();\n    verifyConstructor();\n\n    if (classState.userConstructor) {\n      const { constructorBody, userConstructor, construct } = classState;\n\n      constructorBody.body.push(...userConstructor.body.body);\n      t.inherits(construct, userConstructor);\n      t.inherits(constructorBody, userConstructor.body);\n    }\n\n    pushDescriptors();\n  }\n\n  function pushBody() {\n    const classBodyPaths: Array<any> = classState.path.get(\"body.body\");\n\n    for (const path of classBodyPaths) {\n      const node = path.node;\n\n      if (path.isClassProperty() || path.isClassPrivateProperty()) {\n        throw path.buildCodeFrameError(\"Missing class properties transform.\");\n      }\n\n      if (node.decorators) {\n        throw path.buildCodeFrameError(\n          \"Method has decorators, put the decorator plugin before the classes one.\",\n        );\n      }\n\n      if (t.isClassMethod(node)) {\n        const isConstructor = node.kind === \"constructor\";\n\n        const replaceSupers = new ReplaceSupers({\n          methodPath: path,\n          objectRef: classState.classRef,\n          superRef: classState.superName,\n          constantSuper: assumptions.constantSuper,\n          file: classState.file,\n          refToPreserve: classState.classRef,\n        });\n\n        replaceSupers.replace();\n\n        const superReturns: NodePath<t.ReturnStatement>[] = [];\n        path.traverse(\n          traverse.visitors.merge([\n            environmentVisitor,\n            {\n              ReturnStatement(path) {\n                if (!path.getFunctionParent().isArrowFunctionExpression()) {\n                  superReturns.push(path);\n                }\n              },\n            },\n          ]),\n        );\n\n        if (isConstructor) {\n          pushConstructor(superReturns, node as ClassConstructor, path);\n        } else {\n          pushMethod(node, path);\n        }\n      }\n    }\n  }\n\n  function pushDescriptors() {\n    pushInheritsToBody();\n\n    const { body } = classState;\n\n    const props: PropertyInfo = {\n      instance: null,\n      static: null,\n    };\n\n    for (const placement of [\"static\", \"instance\"] as const) {\n      if (classState.methods[placement].list.length) {\n        props[placement] = classState.methods[placement].list.map(desc => {\n          const obj = t.objectExpression([\n            t.objectProperty(t.identifier(\"key\"), desc.key),\n          ]);\n\n          for (const kind of [\"get\", \"set\", \"value\"] as const) {\n            if (desc[kind] != null) {\n              obj.properties.push(\n                t.objectProperty(t.identifier(kind), desc[kind]),\n              );\n            }\n          }\n\n          return obj;\n        });\n      }\n    }\n\n    if (props.instance || props.static) {\n      let args = [\n        t.cloneNode(classState.classRef), // Constructor\n        props.instance ? t.arrayExpression(props.instance) : t.nullLiteral(), // instanceDescriptors\n        props.static ? t.arrayExpression(props.static) : t.nullLiteral(), // staticDescriptors\n      ];\n\n      let lastNonNullIndex = 0;\n      for (let i = 0; i < args.length; i++) {\n        if (!t.isNullLiteral(args[i])) lastNonNullIndex = i;\n      }\n      args = args.slice(0, lastNonNullIndex + 1);\n\n      body.push(t.returnStatement(createClassHelper(args)));\n      classState.pushedCreateClass = true;\n    }\n  }\n\n  function wrapSuperCall(\n    bareSuper: NodePath<t.CallExpression>,\n    superRef: t.Expression,\n    thisRef: () => t.Identifier,\n    body: NodePath<t.BlockStatement>,\n  ) {\n    const bareSuperNode = bareSuper.node;\n    let call;\n\n    if (assumptions.superIsCallableConstructor) {\n      bareSuperNode.arguments.unshift(t.thisExpression());\n      if (\n        bareSuperNode.arguments.length === 2 &&\n        t.isSpreadElement(bareSuperNode.arguments[1]) &&\n        t.isIdentifier(bareSuperNode.arguments[1].argument, {\n          name: \"arguments\",\n        })\n      ) {\n        // special case single arguments spread\n        bareSuperNode.arguments[1] = bareSuperNode.arguments[1].argument;\n        bareSuperNode.callee = t.memberExpression(\n          t.cloneNode(superRef),\n          t.identifier(\"apply\"),\n        );\n      } else {\n        bareSuperNode.callee = t.memberExpression(\n          t.cloneNode(superRef),\n          t.identifier(\"call\"),\n        );\n      }\n\n      call = t.logicalExpression(\"||\", bareSuperNode, t.thisExpression());\n    } else {\n      const args: t.Expression[] = [\n        t.thisExpression(),\n        t.cloneNode(classState.classRef),\n      ];\n      if (bareSuperNode.arguments?.length) {\n        const bareSuperNodeArguments = bareSuperNode.arguments as (\n          | t.Expression\n          | t.SpreadElement\n        )[];\n\n        /**\n         * test262/test/language/expressions/super/call-spread-err-sngl-err-itr-get-get.js\n         *\n         * var iter = {};\n         * Object.defineProperty(iter, Symbol.iterator, {\n         *   get: function() {\n         *     throw new Test262Error();\n         *   }\n         * })\n         * super(...iter);\n         */\n\n        if (\n          bareSuperNodeArguments.length === 1 &&\n          t.isSpreadElement(bareSuperNodeArguments[0]) &&\n          t.isIdentifier(bareSuperNodeArguments[0].argument, {\n            name: \"arguments\",\n          })\n        ) {\n          args.push(bareSuperNodeArguments[0].argument);\n        } else {\n          args.push(t.arrayExpression(bareSuperNodeArguments));\n        }\n      }\n      call = t.callExpression(addCallSuperHelper(classState.file), args);\n    }\n\n    if (\n      bareSuper.parentPath.isExpressionStatement() &&\n      bareSuper.parentPath.container === body.node.body &&\n      body.node.body.length - 1 === bareSuper.parentPath.key\n    ) {\n      // this super call is the last statement in the body so we can just straight up\n      // turn it into a return\n\n      if (classState.superThises.length) {\n        call = t.assignmentExpression(\"=\", thisRef(), call);\n      }\n\n      bareSuper.parentPath.replaceWith(t.returnStatement(call));\n    } else {\n      bareSuper.replaceWith(t.assignmentExpression(\"=\", thisRef(), call));\n    }\n  }\n\n  function verifyConstructor() {\n    if (!classState.isDerived) return;\n\n    const path = classState.userConstructorPath;\n    const body = path.get(\"body\");\n\n    const constructorBody = path.get(\"body\");\n\n    let maxGuaranteedSuperBeforeIndex = constructorBody.node.body.length;\n\n    path.traverse(findThisesVisitor);\n\n    let thisRef = function () {\n      const ref = path.scope.generateDeclaredUidIdentifier(\"this\");\n      maxGuaranteedSuperBeforeIndex++;\n      thisRef = () => t.cloneNode(ref);\n      return ref;\n    };\n\n    const buildAssertThisInitialized = function () {\n      return t.callExpression(\n        classState.file.addHelper(\"assertThisInitialized\"),\n        [thisRef()],\n      );\n    };\n\n    const bareSupers: NodePath<t.CallExpression>[] = [];\n    path.traverse(\n      traverse.visitors.merge([\n        environmentVisitor,\n        {\n          Super(path) {\n            const { node, parentPath } = path;\n            if (parentPath.isCallExpression({ callee: node })) {\n              bareSupers.unshift(parentPath);\n            }\n          },\n        } as Visitor,\n      ]),\n    );\n\n    for (const bareSuper of bareSupers) {\n      wrapSuperCall(bareSuper, classState.superName, thisRef, body);\n\n      if (maxGuaranteedSuperBeforeIndex >= 0) {\n        let lastParentPath: NodePath;\n        bareSuper.find(function (parentPath) {\n          // hit top so short circuit\n          if (parentPath === constructorBody) {\n            maxGuaranteedSuperBeforeIndex = Math.min(\n              maxGuaranteedSuperBeforeIndex,\n              lastParentPath.key as number,\n            );\n            return true;\n          }\n\n          if (\n            parentPath.isLoop() ||\n            parentPath.isConditional() ||\n            parentPath.isArrowFunctionExpression()\n          ) {\n            maxGuaranteedSuperBeforeIndex = -1;\n            return true;\n          }\n\n          lastParentPath = parentPath;\n        });\n      }\n    }\n\n    for (const thisPath of classState.superThises) {\n      const { node, parentPath } = thisPath;\n      if (parentPath.isMemberExpression({ object: node })) {\n        thisPath.replaceWith(thisRef());\n        continue;\n      }\n\n      let thisIndex: number;\n      thisPath.find(function (parentPath) {\n        if (parentPath.parentPath === constructorBody) {\n          thisIndex = parentPath.key as number;\n          return true;\n        }\n      });\n\n      if (\n        maxGuaranteedSuperBeforeIndex != -1 &&\n        thisIndex > maxGuaranteedSuperBeforeIndex\n      ) {\n        thisPath.replaceWith(thisRef());\n      } else {\n        thisPath.replaceWith(buildAssertThisInitialized());\n      }\n    }\n\n    let wrapReturn;\n\n    if (classState.isLoose) {\n      wrapReturn = (returnArg: t.Expression | void) => {\n        const thisExpr = buildAssertThisInitialized();\n        return returnArg\n          ? t.logicalExpression(\"||\", returnArg, thisExpr)\n          : thisExpr;\n      };\n    } else {\n      wrapReturn = (returnArg: t.Expression | undefined) => {\n        const returnParams: t.Expression[] = [thisRef()];\n        if (returnArg != null) {\n          returnParams.push(returnArg);\n        }\n        return t.callExpression(\n          classState.file.addHelper(\"possibleConstructorReturn\"),\n          returnParams,\n        );\n      };\n    }\n\n    // if we have a return as the last node in the body then we've already caught that\n    // return\n    const bodyPaths = body.get(\"body\");\n    const guaranteedSuperBeforeFinish =\n      maxGuaranteedSuperBeforeIndex !== -1 &&\n      maxGuaranteedSuperBeforeIndex < bodyPaths.length;\n    if (!bodyPaths.length || !bodyPaths.pop().isReturnStatement()) {\n      body.pushContainer(\n        \"body\",\n        t.returnStatement(\n          guaranteedSuperBeforeFinish\n            ? thisRef()\n            : buildAssertThisInitialized(),\n        ),\n      );\n    }\n\n    for (const returnPath of classState.superReturns) {\n      returnPath\n        .get(\"argument\")\n        .replaceWith(wrapReturn(returnPath.node.argument));\n    }\n  }\n\n  /**\n   * Push a method to its respective mutatorMap.\n   */\n  function pushMethod(node: t.ClassMethod, path?: NodePath) {\n    const scope = path ? path.scope : classState.scope;\n\n    if (node.kind === \"method\") {\n      if (processMethod(node, scope)) return;\n    }\n\n    const placement = node.static ? \"static\" : \"instance\";\n    const methods = classState.methods[placement];\n\n    const descKey = node.kind === \"method\" ? \"value\" : node.kind;\n    const key =\n      t.isNumericLiteral(node.key) || t.isBigIntLiteral(node.key)\n        ? t.stringLiteral(String(node.key.value))\n        : t.toComputedKey(node);\n\n    let fn: t.Expression = t.toExpression(node);\n\n    if (t.isStringLiteral(key)) {\n      // infer function name\n      if (node.kind === \"method\") {\n        // @ts-expect-error Fixme: we are passing a ClassMethod to nameFunction, but nameFunction\n        // does not seem to support it\n        fn =\n          nameFunction(\n            // @ts-expect-error Fixme: we are passing a ClassMethod to nameFunction, but nameFunction\n            // does not seem to support it\n            { id: key, node: node, scope },\n            undefined,\n            supportUnicodeId,\n          ) ?? fn;\n      }\n    } else {\n      // todo(flow->ts) find a way to avoid \"key as t.StringLiteral\" below which relies on this assignment\n      methods.hasComputed = true;\n    }\n\n    let descriptor: Descriptor;\n    if (\n      !methods.hasComputed &&\n      methods.map.has((key as t.StringLiteral).value)\n    ) {\n      descriptor = methods.map.get((key as t.StringLiteral).value);\n      descriptor[descKey] = fn;\n\n      if (descKey === \"value\") {\n        descriptor.get = null;\n        descriptor.set = null;\n      } else {\n        descriptor.value = null;\n      }\n    } else {\n      descriptor = {\n        key:\n          // private name has been handled in class-properties transform\n          key as t.Expression,\n        [descKey]: fn,\n      } as Descriptor;\n      methods.list.push(descriptor);\n\n      if (!methods.hasComputed) {\n        methods.map.set((key as t.StringLiteral).value, descriptor);\n      }\n    }\n  }\n\n  function processMethod(node: t.ClassMethod, scope: Scope) {\n    if (assumptions.setClassMethods && !node.decorators) {\n      // use assignments instead of define properties for loose classes\n      let { classRef } = classState;\n      if (!node.static) {\n        insertProtoAliasOnce();\n        classRef = classState.protoAlias;\n      }\n      const methodName = t.memberExpression(\n        t.cloneNode(classRef),\n        node.key,\n        node.computed || t.isLiteral(node.key),\n      );\n\n      let func: t.Expression = t.functionExpression(\n        null,\n        // @ts-expect-error Fixme: should throw when we see TSParameterProperty\n        node.params,\n        node.body,\n        node.generator,\n        node.async,\n      );\n      t.inherits(func, node);\n\n      const key = t.toComputedKey(node, node.key);\n      if (t.isStringLiteral(key)) {\n        // @ts-expect-error: requires strictNullCheck\n        func =\n          nameFunction(\n            {\n              node: func,\n              id: key,\n              scope,\n            },\n            undefined,\n            supportUnicodeId,\n          ) ?? func;\n      }\n\n      const expr = t.expressionStatement(\n        t.assignmentExpression(\"=\", methodName, func),\n      );\n      t.inheritsComments(expr, node);\n      classState.body.push(expr);\n      return true;\n    }\n\n    return false;\n  }\n\n  function insertProtoAliasOnce() {\n    if (classState.protoAlias === null) {\n      setState({ protoAlias: classState.scope.generateUidIdentifier(\"proto\") });\n      const classProto = t.memberExpression(\n        classState.classRef,\n        t.identifier(\"prototype\"),\n      );\n      const protoDeclaration = t.variableDeclaration(\"var\", [\n        t.variableDeclarator(classState.protoAlias, classProto),\n      ]);\n\n      classState.body.push(protoDeclaration);\n    }\n  }\n\n  /**\n   * Replace the constructor body of our class.\n   */\n  function pushConstructor(\n    superReturns: NodePath<t.ReturnStatement>[],\n    method: ClassConstructor,\n    path: NodePath<ClassConstructor>,\n  ) {\n    setState({\n      userConstructorPath: path,\n      userConstructor: method,\n      hasConstructor: true,\n      superReturns,\n    });\n\n    const { construct } = classState;\n\n    t.inheritsComments(construct, method);\n\n    // @ts-expect-error Fixme: should throw when we see TSParameterProperty\n    construct.params = method.params;\n\n    t.inherits(construct.body, method.body);\n    construct.body.directives = method.body.directives;\n\n    // we haven't pushed any descriptors yet\n    // @ts-expect-error todo(flow->ts) maybe remove this block - properties from condition are not used anywhere else\n    if (classState.hasInstanceDescriptors || classState.hasStaticDescriptors) {\n      pushDescriptors();\n    }\n\n    pushInheritsToBody();\n  }\n\n  /**\n   * Push inherits helper to body.\n   */\n  function pushInheritsToBody() {\n    if (!classState.isDerived || classState.pushedInherits) return;\n\n    classState.pushedInherits = true;\n\n    // Unshift to ensure that the constructor inheritance is set up before\n    // any properties can be assigned to the prototype.\n\n    classState.body.unshift(\n      t.expressionStatement(\n        t.callExpression(\n          classState.file.addHelper(\n            classState.isLoose ? \"inheritsLoose\" : \"inherits\",\n          ),\n          [t.cloneNode(classState.classRef), t.cloneNode(classState.superName)],\n        ),\n      ),\n    );\n  }\n\n  function extractDynamicKeys() {\n    const { dynamicKeys, node, scope } = classState;\n\n    for (const elem of node.body.body) {\n      if (!t.isClassMethod(elem) || !elem.computed) continue;\n      if (scope.isPure(elem.key, /* constants only*/ true)) continue;\n\n      const id = scope.generateUidIdentifierBasedOnNode(elem.key);\n      dynamicKeys.set(id.name, elem.key);\n\n      elem.key = id;\n    }\n  }\n\n  function setupClosureParamsArgs() {\n    const { superName, dynamicKeys } = classState;\n    const closureParams = [];\n    const closureArgs = [];\n\n    if (classState.isDerived) {\n      let arg = t.cloneNode(superName);\n      if (classState.extendsNative) {\n        arg = t.callExpression(classState.file.addHelper(\"wrapNativeSuper\"), [\n          arg,\n        ]);\n        annotateAsPure(arg);\n      }\n\n      const param =\n        classState.scope.generateUidIdentifierBasedOnNode(superName);\n\n      closureParams.push(param);\n      closureArgs.push(arg);\n\n      setState({ superName: t.cloneNode(param) });\n    }\n\n    for (const [name, value] of dynamicKeys) {\n      closureParams.push(t.identifier(name));\n      closureArgs.push(value);\n    }\n\n    return { closureParams, closureArgs };\n  }\n\n  function classTransformer(\n    path: NodePath<t.Class>,\n    file: File,\n    builtinClasses: ReadonlySet<string>,\n    isLoose: boolean,\n  ) {\n    setState({\n      parent: path.parent,\n      scope: path.scope,\n      node: path.node,\n      path,\n      file,\n      isLoose,\n    });\n\n    setState({\n      classId: classState.node.id,\n      // this is the name of the binding that will **always** reference the class we've constructed\n      classRef: classState.node.id\n        ? t.identifier(classState.node.id.name)\n        : classState.scope.generateUidIdentifier(\"class\"),\n      superName: classState.node.superClass,\n      isDerived: !!classState.node.superClass,\n      constructorBody: t.blockStatement([]),\n    });\n\n    setState({\n      extendsNative:\n        t.isIdentifier(classState.superName) &&\n        builtinClasses.has(classState.superName.name) &&\n        !classState.scope.hasBinding(\n          classState.superName.name,\n          /* noGlobals */ true,\n        ),\n    });\n\n    const { classRef, node, constructorBody } = classState;\n\n    setState({\n      construct: buildConstructor(classRef, constructorBody, node),\n    });\n\n    extractDynamicKeys();\n\n    const { body } = classState;\n    const { closureParams, closureArgs } = setupClosureParamsArgs();\n\n    buildBody();\n\n    // make sure this class isn't directly called (with A() instead new A())\n    if (!assumptions.noClassCalls) {\n      constructorBody.body.unshift(\n        t.expressionStatement(\n          t.callExpression(classState.file.addHelper(\"classCallCheck\"), [\n            t.thisExpression(),\n            t.cloneNode(classState.classRef),\n          ]),\n        ),\n      );\n    }\n\n    const isStrict = path.isInStrictMode();\n    let constructorOnly = classState.classId && body.length === 0;\n    if (constructorOnly && !isStrict) {\n      for (const param of classState.construct.params) {\n        // It's illegal to put a use strict directive into the body of a function\n        // with non-simple parameters for some reason. So, we have to use a strict\n        // wrapper function.\n        if (!t.isIdentifier(param)) {\n          constructorOnly = false;\n          break;\n        }\n      }\n    }\n\n    const directives = constructorOnly\n      ? classState.construct.body.directives\n      : [];\n    if (!isStrict) {\n      directives.push(t.directive(t.directiveLiteral(\"use strict\")));\n    }\n\n    if (constructorOnly) {\n      // named class with only a constructor\n      const expr = t.toExpression(classState.construct);\n      return classState.isLoose ? expr : createClassHelper([expr]);\n    }\n\n    if (!classState.pushedCreateClass) {\n      body.push(\n        t.returnStatement(\n          classState.isLoose\n            ? t.cloneNode(classState.classRef)\n            : createClassHelper([t.cloneNode(classState.classRef)]),\n        ),\n      );\n    }\n\n    body.unshift(classState.construct);\n\n    const container = t.arrowFunctionExpression(\n      closureParams,\n      t.blockStatement(body, directives),\n    );\n    return t.callExpression(container, closureArgs);\n  }\n\n  return classTransformer(path, file, builtinClasses, isLoose);\n}\n"],"mappings":"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","ignoreList":[]}
>>>>>>> parent of 99ae58fb (IP)
