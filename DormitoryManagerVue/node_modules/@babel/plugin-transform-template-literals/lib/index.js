"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
<<<<<<< HEAD
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _core = require("@babel/core");
var _default = exports.default = (0, _helperPluginUtils.declare)((api, options) => {
  var _api$assumption, _api$assumption2;
=======

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _core = require("@babel/core");

var _default = (0, _helperPluginUtils.declare)((api, options) => {
  var _api$assumption, _api$assumption2;

>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
  api.assertVersion(7);
  const ignoreToPrimitiveHint = (_api$assumption = api.assumption("ignoreToPrimitiveHint")) != null ? _api$assumption : options.loose;
  const mutableTemplateObject = (_api$assumption2 = api.assumption("mutableTemplateObject")) != null ? _api$assumption2 : options.loose;
  let helperName = "taggedTemplateLiteral";
  if (mutableTemplateObject) helperName += "Loose";
<<<<<<< HEAD
=======

>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
  function buildConcatCallExpressions(items) {
    let avail = true;
    return items.reduce(function (left, right) {
      let canBeInserted = _core.types.isLiteral(right);
<<<<<<< HEAD
=======

>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
      if (!canBeInserted && avail) {
        canBeInserted = true;
        avail = false;
      }
<<<<<<< HEAD
=======

>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
      if (canBeInserted && _core.types.isCallExpression(left)) {
        left.arguments.push(right);
        return left;
      }
<<<<<<< HEAD
      return _core.types.callExpression(_core.types.memberExpression(left, _core.types.identifier("concat")), [right]);
    });
  }
=======

      return _core.types.callExpression(_core.types.memberExpression(left, _core.types.identifier("concat")), [right]);
    });
  }

>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
  return {
    name: "transform-template-literals",
    visitor: {
      TaggedTemplateExpression(path) {
        const {
          node
        } = path;
        const {
          quasi
        } = node;
        const strings = [];
        const raws = [];
        let isStringsRawEqual = true;
<<<<<<< HEAD
=======

>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
        for (const elem of quasi.quasis) {
          const {
            raw,
            cooked
          } = elem.value;
          const value = cooked == null ? path.scope.buildUndefinedNode() : _core.types.stringLiteral(cooked);
          strings.push(value);
          raws.push(_core.types.stringLiteral(raw));
<<<<<<< HEAD
=======

>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
          if (raw !== cooked) {
            isStringsRawEqual = false;
          }
        }
<<<<<<< HEAD
        const helperArgs = [_core.types.arrayExpression(strings)];
        if (!isStringsRawEqual) {
          helperArgs.push(_core.types.arrayExpression(raws));
        }
=======

        const helperArgs = [_core.types.arrayExpression(strings)];

        if (!isStringsRawEqual) {
          helperArgs.push(_core.types.arrayExpression(raws));
        }

>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
        const tmp = path.scope.generateUidIdentifier("templateObject");
        path.scope.getProgramParent().push({
          id: _core.types.cloneNode(tmp)
        });
        path.replaceWith(_core.types.callExpression(node.tag, [_core.template.expression.ast`
              ${_core.types.cloneNode(tmp)} || (
                ${tmp} = ${this.addHelper(helperName)}(${helperArgs})
              )
            `, ...quasi.expressions]));
      },
<<<<<<< HEAD
=======

>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
      TemplateLiteral(path) {
        if (path.parent.type === "TSLiteralType") {
          return;
        }
<<<<<<< HEAD
        const nodes = [];
        const expressions = path.get("expressions");
        let index = 0;
=======

        const nodes = [];
        const expressions = path.get("expressions");
        let index = 0;

>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
        for (const elem of path.node.quasis) {
          if (elem.value.cooked) {
            nodes.push(_core.types.stringLiteral(elem.value.cooked));
          }
<<<<<<< HEAD
          if (index < expressions.length) {
            const expr = expressions[index++];
            const node = expr.node;
=======

          if (index < expressions.length) {
            const expr = expressions[index++];
            const node = expr.node;

>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
            if (!_core.types.isStringLiteral(node, {
              value: ""
            })) {
              nodes.push(node);
            }
          }
        }
<<<<<<< HEAD
        if (!_core.types.isStringLiteral(nodes[0]) && !(ignoreToPrimitiveHint && _core.types.isStringLiteral(nodes[1]))) {
          nodes.unshift(_core.types.stringLiteral(""));
        }
        let root = nodes[0];
=======

        if (!_core.types.isStringLiteral(nodes[0]) && !(ignoreToPrimitiveHint && _core.types.isStringLiteral(nodes[1]))) {
          nodes.unshift(_core.types.stringLiteral(""));
        }

        let root = nodes[0];

>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
        if (ignoreToPrimitiveHint) {
          for (let i = 1; i < nodes.length; i++) {
            root = _core.types.binaryExpression("+", root, nodes[i]);
          }
        } else if (nodes.length > 1) {
          root = buildConcatCallExpressions(nodes);
        }
<<<<<<< HEAD
        path.replaceWith(root);
      }
=======

        path.replaceWith(root);
      }

>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
    }
  };
});

<<<<<<< HEAD
//# sourceMappingURL=index.js.map
=======
exports.default = _default;
>>>>>>> e6897d3eee7dd92889ec4638067e9f9148ca1f07
